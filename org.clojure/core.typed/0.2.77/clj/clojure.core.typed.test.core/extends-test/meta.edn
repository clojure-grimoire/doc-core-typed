{:type :fn, :src "(deftest extends-test\n  ; without extends: never returns a (IPV Number) because we can have\n  ; a type (I (IPM clojure.core.typed/Any clojure.core.typed/Any) (IPV clojure.core.typed/Any))\n  (is-tc-err\n    (fn [a]\n      (if (vector? a)\n        a\n        nil))\n    [(U (Vec Num) (Map Any Any)) -> (U nil (Vec Num))])\n  ; can use assertions to prove non-overlapping interfaces\n  (is-tc-e\n    (fn [a]\n      {:pre [(or (and (vector? a)\n                      (not (map? a)))\n                 (and (map? a)\n                      (not (vector? a))))]}\n      (if (vector? a)\n        a\n        nil))\n    [(U (Vec Num) (Map Any Any)) -> (U nil (Vec Num))])\n  ; or use static types\n  (is-tc-e \n    (fn [a]\n      (if (vector? a)\n        a\n        nil))\n    [(U (Extends [(clojure.lang.IPersistentVector Number)]\n                 :without [(clojure.lang.IPersistentMap Any Any)])\n        (Extends [(clojure.lang.IPersistentMap Any Any)]\n                 :without [(clojure.lang.IPersistentVector Any)]))\n     -> (U nil (clojure.lang.IPersistentVector Number))])\n  ; technically it's ok to implement Number and IPM\n  (is-tc-e \n    (fn [a]\n      {:pre [(number? a)]}\n      (print-env \"a\")\n      (+ 1 a))\n    [(clojure.lang.IPersistentMap Any Any) -> Number]))", :ns "clojure.core.typed.test.core", :name "extends-test", :file "clojure/core/typed/test/core.clj", :column 1, :line 1462, :test #<core$fn__27890 clojure.core.typed.test.core$fn__27890@5ef4b9e0>}
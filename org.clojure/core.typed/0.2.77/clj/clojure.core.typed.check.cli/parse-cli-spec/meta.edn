{:type :fn, :src "(defn parse-cli-spec [check-fn spec-expr]\n  (letfn [(opt? [^String x]\n            (.startsWith x \"-\"))\n          (name-for [k]\n            (str/replace k #\"^--no-|^--\\[no-\\]|^--|^-\" \"\")) \n          (flag? [^String x]\n              (.startsWith x \"--[no-]\"))]\n\n  (let [; (U nil (Seqable '[Form (U nil Expr)]))\n        raw-spec (vector-args spec-expr)]\n    (cond\n      (not raw-spec) (do\n                       ;(prn \"cli: not vector \" spec-expr)\n                       nil)\n      :else\n      (let [; each seq and map entry is a pair of [form expr]\n            [switches raw-spec] (split-with (fn [[frm _]] (and (string? frm) (opt? frm))) raw-spec)\n            [docs raw-spec]     (split-with (fn [[frm _]] (string? frm)) raw-spec)\n            ; keys are [kw expr]\n            options             (apply hash-map raw-spec)\n            ; keys are keywords\n            ; (Map Keyword [Form Expr])\n            options             (into {}\n                                      (for [[[kfrm _] v] options]\n                                        [kfrm v]))\n            ; (Seqable Form)\n            aliases             (map (fn [[frm _]] (name-for frm)) switches)\n            ; assume we fail later if there is anything ambiguous\n            flag                (or (if (seq switches)\n                                      (flag? (first (last switches)))\n                                      :unknown)\n                                    (when (contains? options :flag)\n                                      (let [flg-form (first (:flag options))]\n                                        (if (con/boolean? flg-form)\n                                          flg-form\n                                          :unknown)))\n                                    false)]\n        (cond\n          ;not accurate enough, return nil\n          (not-every? keyword? (keys options)) (do\n                                                 ;(prn \"cli: not every option key was keyword\" options)\n                                                 nil)\n          (#{:unknown} flag) (do \n                               ;(prn \"cli: flag unknown\")\n                               nil)\n          (not\n            (and (#{0 1} (count docs))\n                 ((some-fn nil? string?) (-> docs first first)))) (do\n                                                                    ;(prn \"cli: docs\" docs) \n                                                                    nil)\n          (empty? aliases) (do\n                             ;(prn \"cli: empty aliases\")\n                             nil)\n          :else\n          (let [name (r/-val (keyword (last aliases)))\n                default-type (when-let [[frm default-expr] (:default options)]\n                               (if default-expr\n                                 (-> (check-fn default-expr)\n                                     u/expr-type\n                                     r/ret-t)\n                                 (const/constant-type frm)))\n                parse-fn-type (when-let [[pfrm parse-fn-expr] (:parse-fn options)]\n                                (if parse-fn-expr\n                                  (-> (check-fn parse-fn-expr (r/ret (prs/parse-type\n                                                                       '[String -> Any])))\n                                      u/expr-type\n                                      r/ret-t)\n                                  (const/constant-type pfrm)))\n                parse-fn-ret (when parse-fn-type\n                               (parse-fn-return-type parse-fn-type))\n                type (cond\n                       (and parse-fn-type\n                            (not parse-fn-ret)) (do\n                                                  ;(prn \"cli: parse-fn\")\n                                                  nil)\n                       flag (c/RClass-of Boolean)\n                       :else\n                       (apply c/Un (concat (when default-type\n                                             [default-type])\n                                           (if parse-fn-type\n                                             [parse-fn-ret]\n                                             [(c/RClass-of String)]))))]\n            (when type\n              [name type]))))))))", :ns "clojure.core.typed.check.cli", :name "parse-cli-spec", :file "clojure/core/typed/check/cli.clj", :column 1, :line 33, :arglists ([check-fn spec-expr])}
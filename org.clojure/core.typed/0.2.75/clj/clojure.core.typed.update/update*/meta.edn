{:type :fn, :src "(defn update* [t ft pos? lo]\n  {:pre [(r/Type? t)\n         (r/Type? ft)\n         (con/boolean? pos?)\n         (pr/path-elems? lo)]\n   :post [(r/Type? %)]}\n  (u/p :check/update\n  (let [t (c/fully-resolve-type t)]\n    (cond\n      ; The easy cases: we have a filter without a further path to travel down.\n      ; Just update t with the correct polarity.\n\n      (empty? lo)\n      (if pos?\n        (c/restrict t ft)\n        (remove/remove* t ft))\n\n      ; unwrap unions and intersections to update their members\n\n      (or (r/Union? t)        \n          (r/Intersection? t)) \n      (apply (if (r/Union? t) c/Un c/In)\n             (map #(update* % ft pos? lo) (:types t)))\n\n      ;from here, t is fully resolved and is not a Union or Intersection\n\n      ;heterogeneous map ops\n      ; Positive and negative information down a keyword path\n      ; eg. (number? (-> hmap :a :b))\n      (and (pe/KeyPE? (first lo))\n           (r/HeterogeneousMap? t))\n      (let [polarity pos?\n            update-to-type ft\n            path lo\n            [fkeype & rstpth] path\n            fpth (cu/KeyPE->Type fkeype)\n            update-inner (fn \n                           ([old] (update* old ft pos? rstpth))\n                           ([old new] (update* old new pos? rstpth)))\n            present? (contains? (:types t) fpth)\n            optional? (contains? (:optional t) fpth)\n            absent? (contains? (:absent-keys t) fpth)]\n        ;updating a KeyPE should consider 3 cases:\n        ; 1. the key is declared present\n        ; 2. the key is declared absent\n        ; 3. the key is not declared present, and is not declared absent\n        (cond\n          present?\n            ; -hmap simplifies to bottom if an entry is bottom\n            (c/make-HMap\n              :mandatory (update-in (:types t) [fpth] update-inner)\n              :optional (:optional t)\n              :absent-keys (:absent-keys t)\n              :complete? (c/complete-hmap? t))\n          absent?\n            t\n\n          ; key not declared present or absent\n          :else\n          (let [; KeyPE are only used for `get` operations where `nil` is the\n                ; not-found value. If the filter does not hold when updating\n                ; it to nil, then we can assume this key path is present.\n                update-to-mandatory? (r/Bottom? (update-inner r/-nil))]\n            (if update-to-mandatory?\n              (c/make-HMap \n                :mandatory (assoc-in (:types t) [fpth] (update-inner r/-any))\n                :optional (:optional t)\n                :absent-keys (:absent-keys t)\n                :complete? (c/complete-hmap? t))\n              (c/make-HMap \n                :mandatory (:types t)\n                :optional (if optional?\n                            (update-in (:optional t) [fpth] update-inner)\n                            (assoc-in (:optional t) [fpth] (update-inner r/-any)))\n                :absent-keys (:absent-keys t)\n                :complete? (c/complete-hmap? t))))))\n\n      ; nil returns nil on keyword lookups\n      (and (not pos?)\n           (pe/KeyPE? (first lo))\n           (r/Nil? t))\n      (update* r/-nil ft pos? (next lo))\n\n      ; update count information based on a call to `count`\n      ; eg. (= 1 (count a))\n      (and pos?\n           (pe/CountPE? (first lo)))\n      (let [u ft]\n        (if-let [cnt (cond \n                       ; for (= 1 (count v))\n                       (and (r/Value? u) (integer? (:val u)))\n                       (r/make-ExactCountRange (:val u))\n\n                       ; for (#{1 2 3} (count v))\n                       (and (r/Union? u) \n                            (every? (every-pred r/Value?\n                                                (comp integer? :val))\n                                    (:types u)))\n                       (let [ns (->> (map :val (:types u))\n                                     (remove neg?)\n                                     sort\n                                     vec)]\n                         (when (seq ns)\n                           (r/make-CountRange (first ns)\n                                              (last ns)))))]\n          (c/restrict t cnt)\n          (do (u/tc-warning \"Cannot infer Count from type \" (prs/unparse-type u))\n              t)))\n\n      ;can't do much without a NotCountRange type or difference type\n      (and (not pos?)\n           (pe/CountPE? (first lo)))\n      t\n\n      (and pos?\n           (pe/NthPE? (first lo))\n           (c/AnyHSequential? t))\n      (let [type ft\n            path-expr (first lo)\n            idx (:idx path-expr)\n            fixed-types (conj (vec (repeat idx r/-any)) type)\n            restriction-type (r/-hsequential fixed-types :rest r/-any)]\n        (c/restrict t restriction-type))\n\n      (and (not pos?)\n           (pe/NthPE? (first lo))\n           (c/AnyHSequential? t))\n      t\n\n      ; Update class information based on a call to `class`\n      ; eg. (= java.lang.Integer (class a))\n      (and pos?\n           (pe/ClassPE? (first lo)))\n      (let [_ (assert (not (next lo)))\n            u ft]\n        (cond \n          ;restrict the obvious case where the path is the same as a Class Value\n          ; eg. #(= (class %) Number)\n          (and (r/Value? u)\n               (class? (:val u)))\n          (update* t (c/RClass-of-with-unknown-params (:val u)) pos? nil)\n\n          ; handle (class nil) => nil\n          (r/Nil? u)\n          (update* t r/-nil pos? nil)\n\n          :else\n          (do (u/tc-warning \"Cannot infer type via ClassPE from type \" (prs/unparse-type u))\n              t)))\n\n      ; Does not tell us anything.\n      ; eg. (= Number (class x)) ;=> false\n      ;     does not reveal whether x is a subtype of Number, eg. (= Integer (class %))\n      (and (not pos?)\n           (pe/ClassPE? (first lo)))\n      t\n\n      ; keyword invoke of non-hmaps\n      ; (let [a (ann-form {} (Map Any Any))]\n      ;   (number? (-> a :a :b)))\n      ; \n      ; I don't think there's anything interesting worth encoding:\n      ; use HMap for accurate updating.\n      (pe/KeyPE? (first lo))\n      t\n\n      ; calls to `keys` and `vals`\n      ((some-fn pe/KeysPE? pe/ValsPE?) (first lo))\n      (let [[fstpth & rstpth] lo\n            u ft\n            ;_ (prn \"u\" (prs/unparse-type u))\n\n            ; solve for x:  t <: (Seqable x)\n            x (gensym)\n            subst (free-ops/with-bounded-frees {(r/make-F x) r/no-bounds}\n                    (u/handle-cs-gen-failure\n                      (cgen/infer {x r/no-bounds} {} \n                                  [u]\n                                  [(c/RClass-of clojure.lang.Seqable [(r/make-F x)])]\n                                  r/-any)))\n            ;_ (prn \"subst for Keys/Vals\" subst)\n            _ (when-not subst\n                (err/int-error (str \"Cannot update \" (if (pe/KeysPE? fstpth) \"keys\" \"vals\") \" of an \"\n                                    \"IPersistentMap with type: \" (pr-str (prs/unparse-type u)))))\n            element-t-subst (get subst x)\n            _ (assert (crep/t-subst? element-t-subst))\n            ; the updated 'keys/vals' type\n            element-t (:type element-t-subst)\n            ;_ (prn \"element-t\" (prs/unparse-type element-t))\n            _ (assert element-t)]\n        (assert (empty? rstpth) (str \"Further path NYI keys/vals\"))\n        (if pos?\n          (update* t\n                   (if (pe/KeysPE? fstpth)\n                     (c/RClass-of IPersistentMap [element-t r/-any])\n                     (c/RClass-of IPersistentMap [r/-any element-t]))\n                   pos? nil)\n          ; can we do anything for a NotTypeFilter?\n          t))\n\n\n      :else (err/int-error (str \"update along ill-typed path \" (pr-str (prs/unparse-type t)) \" \" (with-out-str (pr lo))))))))", :ns "clojure.core.typed.update", :name "update*", :file "clojure/core/typed/update.clj", :column 1, :line 128, :arglists ([t ft pos? lo])}
{:type :fn, :src "(defn check-if [check-fn expr ctest thn els expected]\n  {:pre [(-> ctest u/expr-type r/TCResult?)\n         ((some-fn r/TCResult? nil?) expected)]\n   :post [(-> % u/expr-type r/TCResult?)]}\n  (let [check-if-checkfn (if-let [c check-fn]\n                           c\n                           (err/int-error \"No checkfn passed for if\"))]\n    (letfn [(tc [expr reachable?]\n              {:post [(-> % u/expr-type r/TCResult?)]}\n              (when-not reachable?\n                #_(prn \"Unreachable code found.. \" expr))\n              (cond\n                ;; if reachable? is #f, then we don't want to verify that this branch has the appropriate type\n                ;; in particular, it might be (void)\n                (and expected reachable?)\n                (check-if-checkfn expr (-> expected\n                                                 (assoc :fl (fo/-FS fl/-top fl/-top))\n                                                 (assoc :o obj/-empty)\n                                                 (assoc :flow (r/-flow fl/-top))))\n                ;; this code is reachable, but we have no expected type\n                reachable? (check-if-checkfn expr)\n                ;; otherwise, this code is unreachable\n                ;; and the resulting type should be the empty type\n                :else (do ;(prn \"Not checking unreachable code\")\n                          (assoc expr \n                                 u/expr-type (r/ret (c/Un))))))]\n      (let [tst (u/expr-type ctest)\n            {fs+ :then fs- :else :as f1} (r/ret-f tst)\n            ;          _ (prn \"check-if: fs+\" (prs/unparse-filter fs+))\n            ;          _ (prn \"check-if: fs-\" (prs/unparse-filter fs-))\n            flag+ (atom true :validator con/boolean?)\n            flag- (atom true :validator con/boolean?)\n\n            ;_ (print-env)\n            ;idsym (gensym)\n            env-thn (update/env+ lex/*lexical-env* [fs+] flag+)\n            ;          _ (do (pr \"check-if: env-thn\")\n            ;              (print-env* env-thn))\n            env-els (update/env+ lex/*lexical-env* [fs-] flag-)\n            ;          _ (do (pr \"check-if: env-els\")\n            ;              (print-env* env-els))\n            ;          new-thn-props (set\n            ;                          (filter atomic-filter?\n            ;                                  (set/difference\n            ;                                    (set (:props lex/*lexical-env*))\n            ;                                    (set (:props env-thn)))))\n            ;_ (prn idsym\"env+: new-thn-props\" (map unparse-filter new-thn-props))\n            ;          new-els-props (set\n            ;                          (filter atomic-filter?\n            ;                                  (set/difference\n            ;                                    (set (:props lex/*lexical-env*))\n            ;                                    (set (:props env-els)))))\n            ;_ (prn idsym\"env+: new-els-props\" (map unparse-filter new-els-props))\n            cthen\n            (binding [vs/*current-expr* thn]\n              (var-env/with-lexical-env env-thn\n                (tc thn @flag+)))\n\n            {ts :t fs2 :fl os2 :o flow2 :flow :as then-ret}\n            (u/expr-type cthen)\n\n            celse\n            (binding [vs/*current-expr* els]\n              (var-env/with-lexical-env env-els\n                (tc els @flag-)))\n\n            {us :t fs3 :fl os3 :o flow3 :flow :as else-ret} \n            (u/expr-type celse)\n\n            ;_ (prn \"flow2\" (prs/unparse-flow-set flow2))\n            ;_ (prn \"flow3\" (prs/unparse-flow-set flow3))\n            ]\n\n        ;some optimization code here, contraditions etc? omitted\n\n        ;      (prn \"check-if: then branch:\" (prs/unparse-TCResult then-ret))\n        ;      (prn \"check-if: else branch:\" (prs/unparse-TCResult else-ret))\n        (let [if-ret \n              (cond\n                ;both branches reachable\n                (and (not (= (c/Un) ts))\n                     (not (= (c/Un) us)))\n                (let [;_ (prn \"both branches reachable\")\n                      r (let [filter (cond\n                                       (or (fl/NoFilter? fs2)\n                                           (fl/NoFilter? fs3)) (fo/-FS fl/-top fl/-top)\n                                       (and (fl/FilterSet? fs2)\n                                            (fl/FilterSet? fs3))\n                                       (let [{f2+ :then f2- :else} fs2\n                                             {f3+ :then f3- :else} fs3\n                                             ; +ve test, +ve then\n                                             new-thn-props (:props env-thn)\n                                             ;_ (prn \"new-thn-props\" (map prs/unparse-filter new-thn-props))\n                                             new-els-props (:props env-els)\n                                             ;_ (prn \"new-els-props\" (map prs/unparse-filter new-els-props))\n                                             +t+t (apply fo/-and fs+ f2+ new-thn-props)\n                                             ;_ (prn \"+t+t\" (prs/unparse-filter +t+t))\n                                             ; -ve test, +ve else\n                                             -t+e (apply fo/-and fs- f3+ new-els-props)\n                                             ;_ (prn \"-t+e\" (prs/unparse-filter -t+e))\n                                             ; +ve test, -ve then\n                                             +t-t (apply fo/-and fs+ f2- new-thn-props)\n                                             ;_ (prn \"+t-t\" (prs/unparse-filter +t-t))\n                                             ; -ve test, -ve else\n                                             -t-e (apply fo/-and fs- f3- new-els-props)\n                                             ;_ (prn \"-t-e\" (prs/unparse-filter -t-e))\n\n                                             final-thn-prop (fo/-or +t+t -t+e)\n                                             ;_ (prn \"final-thn-prop\" (prs/unparse-filter final-thn-prop))\n                                             final-els-prop (fo/-or +t-t -t-e)\n                                             ;_ (prn \"final-els-prop\" (prs/unparse-filter final-els-prop))\n                                             fs (fo/-FS final-thn-prop final-els-prop)]\n                                         fs)\n                                       :else (err/int-error (str \"What are these?\" fs2 fs3)))\n                              type (c/Un ts us)\n                              object (if (= os2 os3) os2 (obj/EmptyObject-maker))\n\n                              ;only bother with something interesting if a branch is unreachable (the next two cond cases)\n                              ;Should be enough for `assert`\n                              ;flow (r/-flow (fo/-or flow2 flow3))\n                              flow (r/-flow fl/-top)\n                              ]\n                          (r/ret type filter object flow))]\n                  ;(prn \"check if:\" \"both branches reachable, with combined result\" (prs/unparse-TCResult r))\n                  (if expected (below/check-below r expected) r))\n                ;; both branches unreachable, flow-set is ff\n                (and (= us (c/Un))\n                     (= ts (c/Un)))\n                (r/ret (c/Un) (fo/-FS fl/-top fl/-top) obj/-empty (r/-flow fl/-bot))\n                ;; special case if one of the branches is unreachable\n                (= us (c/Un))\n                (if expected (below/check-below (r/ret ts fs2 os2 flow2) expected) (r/ret ts fs2 os2 flow2))\n                (= ts (c/Un))\n                (if expected (below/check-below (r/ret us fs3 os3 flow3) expected) (r/ret us fs3 os3 flow3))\n                :else (err/int-error \"Something happened\"))\n              _ (assert (r/TCResult? if-ret))]\n          (assoc expr\n                 :test ctest\n                 :then cthen\n                 :else celse\n                 u/expr-type if-ret))))))", :ns "clojure.core.typed.check.if", :name "check-if", :file "clojure/core/typed/check/if.clj", :column 1, :line 17, :arglists ([check-fn expr ctest thn els expected])}
{:type :fn, :src "(defn abstract-object [ids keys o]\n  {:pre [(every? symbol? ids)\n         (every? integer? keys)\n         (obj/RObject? o)]\n   :post [(obj/RObject? %)]}\n  ;(prn \"abstract-object\" ids keys o)\n  (letfn [ ; Difference from Typed Racket:\n            ;   because abstract-result calls abstract-type, we could have\n            ;   already-abstracted filters at this point. We relax the contract\n            ;   to allow naturals.\n            ;\n            ; eg. (ann-form (fn [] (fn [b] b)) [-> [Any -> Any]])\n            ;\n            ;    In this type the (fn [b] b) is already abstracted as \n            ;      [Any -> Any :filters {:then (! (U nil false) 0), :else (is (U nil false) 0)} :object {:id 0}]\n            ;    by the time we call abstract-result.\n          (lookup [y]\n            {:pre [((some-fn symbol? con/znat?) y)]\n             :post [((some-fn nil? integer?) %)]}\n            (some (fn [[x i]] (and (= x y) i))\n                  (map vector ids keys)))]\n    (cond\n      (and (obj/Path? o)\n           (lookup (:id o))) (update-in o [:id] lookup)\n      :else obj/-empty)))", :ns "clojure.core.typed.abo", :name "abstract-object", :file "clojure/core/typed/abo.clj", :column 1, :line 30, :arglists ([ids keys o])}
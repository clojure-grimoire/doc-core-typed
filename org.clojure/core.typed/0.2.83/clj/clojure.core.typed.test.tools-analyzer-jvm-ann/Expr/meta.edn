{:ns "clojure.core.typed.test.tools-analyzer-jvm-ann", :name "Expr", :file "clojure/core/typed/test/tools_analyzer_jvm_ann.clj", :type :var, :src "(t/defalias Expr\n  (t/Rec [Expr]\n  ; ----- start tools.analyzer specific ----\n  (t/U (t/HMap :mandatory\n           {:op ':const\n            :env Env\n            :type t/Keyword\n            :literal Boolean\n            :val Form\n            :form Form}\n           :optional\n           {:meta Expr\n            :children Children})\n     (t/HMap :mandatory\n           {:op ':vector\n            :env Env\n            :items (t/Vec Expr)\n            :form Form\n            :children Children})\n     (t/HMap :mandatory\n           {:op ':with-meta\n            :env Env\n            :form Form\n            :meta Expr\n            :expr Expr\n            :children Children})\n     (t/HMap :mandatory\n           {:op ':map\n            :env Env\n            :keys (t/Vec Expr)\n            :vals (t/Vec Expr)\n            :form Form\n            :children Children})\n     (t/HMap :mandatory\n           {:op ':set\n            :env Env\n            :items (t/Vec Expr)\n            :form Form\n            :children Children})\n     (t/HMap :mandatory\n           {:op ':local\n            :form Form\n            :name t/Symbol\n            :assignable? Boolean\n            :children Children}\n           :optional\n           ;env is sometimes omitted. eg. :local entry in :fn-method\n           {:env Env})\n     (t/HMap :mandatory\n           {:op ':var\n            :env Env\n            :form Form\n            :assignable? Boolean\n            ;:var (t/Var2 Nothing t/Any)\n            })\n     (t/HMap :mandatory\n           {:op ':maybe-host-form\n            :env Env\n            :form Form\n            :class (t/U nil t/Symbol)\n            :field t/Symbol})\n     (t/HMap :mandatory\n           {:op ':maybe-class\n            :env Env\n            :form Form\n            ; is this just Symbol?\n            :class (t/U nil t/Symbol)})\n     (t/HMap :mandatory\n           {:op ':do\n            :env Env\n            :form Form\n            :statements (t/Vec Expr)\n            :ret Expr\n            :children Children})\n     (t/HMap :mandatory\n           {:op ':if\n            :env Env\n            :form Form\n            :test Expr\n            :then Expr\n            :else Expr\n            :children Children})\n     (t/HMap :mandatory\n           {:op ':new\n            :env Env\n            :form Form\n            :class Class\n            :args (t/Vec Expr)\n            :children Children})\n     (t/HMap :mandatory\n           {:op ':quote\n            :env Env\n            :form Form\n            :expr Expr\n            :literal? Boolean\n            :children Children})\n     (t/HMap :mandatory\n           {:op ':set!\n            :env Env\n            :form Form\n            :target Expr\n            :val Expr\n            :children Children})\n     (t/HMap :mandatory\n           {:op ':try\n            :env Env\n            :form Form\n            :body Expr\n            :catches (t/Vec Expr)\n            :children Children}\n           :optional\n           {:finally Expr})\n     (t/HMap :mandatory\n           {:op ':binding\n            :env Env\n            :form Form\n            :name t/Symbol\n            :local t/Any}\n           :optional\n           {:tag Tag\n            :arg-id t/Int\n            :variadic? Boolean\n            ;---- start t.a.j specific ----\n            ; not sure what o-tag is\n            :o-tag OTag\n            ; added in :deftype\n            :mutable t/Any\n            ;---- end t.a.j specific ----\n            })\n     (t/HMap :mandatory\n           {:op ':catch\n            :env Env\n            :form Form\n            :class Class\n            :local Expr\n            :body Expr\n            :children Children})\n     (t/HMap :mandatory\n           {:op ':throw\n            :env Env\n            :form Form\n            :exception Expr})\n     (t/HMap :mandatory\n           {:op ':letfn\n            :env Env\n            :form Form\n            :body Expr\n            :bindings (t/Vec Expr)\n            :children Children})\n     (t/HMap :mandatory\n           {:op ':let\n            :form Form\n            :env Env\n            :body Expr\n            :bindings (t/Vec Expr)\n            :children Children})\n     (t/HMap :mandatory\n           {:op ':loop\n            :form Form\n            :env Env\n            :loop-id t/Symbol\n            :body Expr\n            :bindings (t/Vec Expr)\n            :children Children})\n     (t/HMap :mandatory\n           {:op ':recur\n            :env Env\n            :form Form\n            :exprs (t/Vec Expr)\n            :loop-id t/Symbol\n            :children Children})\n     (t/HMap :mandatory\n           {:op ':fn-method\n            :env Env\n            :form Form\n            :loop-id t/Symbol\n            :variadic? Boolean\n            :params (t/Vec Expr)\n            :fixed-arity t/Int\n            :body Expr\n            :children Children}\n           :optional\n           {:local Expr})\n     (t/HMap :mandatory\n           {:op ':fn\n            :env Env\n            :form Form\n            ;unsure if nilable\n            :name (t/U nil t/Symbol)\n            :variadic? Boolean\n            :max-fixed-arity (t/U nil t/Int)\n            :methods (t/Vec Expr)\n            :children Children}\n           :optional\n           {:local Expr})\n     (t/HMap :mandatory\n           {:op ':def\n            :env Env\n            :form Form\n            :name t/Symbol\n            ;:var (t/Var2 Nothing t/Any)\n            }\n           :optional\n           {:meta Expr\n            :init Expr\n            :doc String\n            :children Children})\n     (t/HMap :mandatory\n           {:op ':host-call\n            :env Env\n            :form Form\n            :target Expr\n            :method t/Symbol\n            :args (t/Vec Expr)\n            :children Children})\n     (t/HMap :mandatory\n           {:op ':host-field\n            :env Env\n            :form Form\n            :target Expr\n            :field t/Symbol\n            :children Children})\n     (t/HMap :mandatory\n           {:op ':host-interop\n            :env Env\n            :form Form\n            :target Expr\n            :m-or-f t/Symbol\n            :children Children})\n     (t/HMap :mandatory\n           {:op ':invoke\n            :env Env\n            :form Form\n            :fn Expr\n            :args (t/Vec Expr)\n            :children Children}\n           :optional\n           {:meta Expr})\n; ---- end tools.analyzer specific -----\n           \n; ---- start tools.analyzer.jvm specific ----\n\n     (t/HMap :mandatory\n           {:op ':the-var\n            :env Env\n            :form Form\n            ;:var (t/Var2 Nothing t/Any)\n            })\n     (t/HMap :mandatory\n           {:op ':monitor-enter\n            :env Env\n            :form Form\n            :target Expr\n            :children Children})\n     (t/HMap :mandatory\n           {:op ':monitor-exit\n            :env Env\n            :form Form\n            :target Expr\n            :children Children})\n     (t/HMap :mandatory\n           {:op ':import\n            :env Env\n            :form Form\n            ;cannot be a Class. j.t.a calls this :class-str\n            :class String})\n     (t/HMap :mandatory\n           {:op ':method\n            :env Env\n            :form Form\n            :loop-id t/Symbol\n            :params (t/Vec Expr)\n            :fixed-arity t/Int\n            :body Expr\n            :children Children}\n           :optional\n           ; possibly inherited from :fn-method\n           {:local Expr\n            ; added in :reify\n            :interfaces (t/Set (t/U nil Class))\n            })\n     (t/HMap :mandatory\n           {:op ':reify\n            :env Env\n            :form Form\n            :class-name t/Symbol\n            :methods (t/Vec Expr)\n            :children Children})\n     (t/HMap :mandatory\n           {:op ':deftype\n            :env Env\n            :form Form\n            :name t/Symbol\n            :class-name t/Symbol\n            :fields (t/Vec Expr)\n            :methods (t/Vec Expr)\n            ; not sure what :interfaces is\n            :interfaces (t/Set t/Any)\n            :children Children})\n     (t/HMap :mandatory\n           {:op ':case-test\n            ;TODO\n            :hash t/Any\n            :test Expr\n            :children Children})\n     (t/HMap :mandatory\n           {:op ':case-then\n            ;TODO\n            :hash t/Any\n            :then Expr\n            :children Children})\n     (t/HMap :mandatory\n           {:op ':case\n            :env Env\n            :form Form\n            :test Expr\n            :default Expr\n            :tests (t/Vec Expr)\n            :thens (t/Vec Expr)\n            ;TODO\n            :shift t/Any\n            :mask t/Any\n            :low t/Any\n            :high t/Any\n            :switch-type t/Any\n            :test-type t/Any\n            :skip-check? Boolean\n            :children Children})\n\n;       --- start analyze-host-expr pass ---\n      ;maybe-instance-method / analyze-host-call\n      (t/HMap :mandatory\n            {:op ':instance-call\n             :form Form\n             :env Env\n             :tag Tag\n             :o-tag OTag\n             :instance Expr\n             :method t/Symbol\n             :class Class\n             :children Children}\n            :optional\n            {:args (t/Vec Expr)}) ;absent in maybe-instance-method\n      ;maybe-static-method / analyze-host-call\n      (t/HMap :mandatory\n            {:op ':static-call\n             :form Form\n             :env Env\n             :tag Tag\n             :o-tag OTag\n             :class Class\n             :method t/Symbol}\n            :optional\n            {:args (t/Vec Expr)}) ; absent in maybe-static-method\n      ;maybe-static-field / analyze-host-field\n      (t/HMap :mandatory\n            {:op ':static-field\n             :form Form\n             :env Env\n             :assignable? Boolean\n             :class Class\n             :field t/Symbol\n             :o-tag OTag\n             :tag Tag})\n      ;maybe-instance-field / analyze-host-field\n      (t/HMap :mandatory\n            {:op ':instance-field\n             :form Form\n             :env Env\n             :assignable? Boolean\n             :class Class\n             :instance Expr\n             :field t/Symbol\n             :o-tag OTag\n             :tag Tag\n             :children Children})\n;       --- end analyze-host-expr pass ---\n\n;       --- start classify-invoke pass ---\n      (t/HMap :mandatory\n            {:op ':keyword-invoke\n             :env Env\n             :form Form\n             :fn Expr\n             :args (t/Vec Expr)\n             :children Children}\n            :optional\n            {:meta Expr})\n\n      (t/HMap :mandatory\n            {:op ':instance?\n             :env Env\n             :form Form\n             :class Class\n             :target Expr\n             :o-tag OTag\n             :tag Tag\n             :children Children})\n\n      (t/HMap :mandatory\n            {:op ':protocol-invoke\n             :env Env\n             :form Form\n             :fn Expr\n             :args (t/Vec Expr)\n             :children Children}\n            :optional\n            {:meta Expr})\n\n      (t/HMap :mandatory\n            {:op ':prim-invoke\n             :env Env\n             :form Form\n             :fn Expr\n             :prim-interface Class\n             :args (t/Vec Expr)\n             :tag Tag\n             :o-tag OTag\n             :children Children}\n            :optional\n            {:meta Expr})\n\n\n; ---- end tools.analyzer.jvm specific ----\n\n)))", :column 1, :line 40, :declared true}
{:type :fn, :src "(deftest invoke-merge-test\n  \n  ; basic literal case\n  (equal-types (merge {:a 5 :b 6} {:c 7 :d 8} {:e 9})\n               (HMap :mandatory {:a '5 :b '6 :c '7 :d '8 :e '9} :complete? true))\n  \n  ; right hand optionals\n  (equal-types (merge {:a 5 :b 6}\n                      (clojure.core.typed/ann-form {} (HMap :optional {:c String} :complete? true)))\n               (HMap :mandatory {:a '5 :b '6}\n                     :optional {:c String}\n                     :complete? true))\n  \n  ; left hand optionals\n  (equal-types (merge (clojure.core.typed/ann-form {} (HMap :optional {:a Number} :complete? true))\n                      (clojure.core.typed/ann-form {} (HMap :optional {:b String} :complete? true)))\n               (HMap :optional {:a Number :b String} :complete? true))\n  \n  ; nil first argument\n  (equal-types (merge nil\n                      (clojure.core.typed/ann-form {} (HMap :optional {:a Number} :complete? true))\n                      (clojure.core.typed/ann-form {} (HMap :optional {:b String} :complete? true)))\n               (HMap :optional {:a Number :b String} :complete? true))\n  \n  ; nils in other arguments\n  (equal-types (merge nil\n                      nil\n                      (clojure.core.typed/ann-form {} (HMap :optional {:a Number} :complete? true))\n                      nil\n                      nil\n                      (clojure.core.typed/ann-form {} (HMap :optional {:b String} :complete? true))\n                      nil)\n               (HMap :optional {:a Number :b String} :complete? true))\n  \n  ; all nils\n  (equal-types (merge nil)\n               nil)\n  (equal-types (merge nil nil nil)\n               nil)\n  \n  ; (Option HMap) first argument\n  (equal-types (merge (clojure.core.typed/ann-form {:c 5} (U nil (HMap :mandatory {:c '5} :complete? true)))\n                      (clojure.core.typed/ann-form {} (HMap :optional {:a Number} :complete? true))\n                      (clojure.core.typed/ann-form {} (HMap :optional {:b String} :complete? true)))\n               (HMap :optional {:a Number :b String :c '5} :complete? true))\n  \n  ; (Option HMap) arguments\n  (equal-types (merge (clojure.core.typed/ann-form {} (U nil (HMap :complete? true)))\n                      (clojure.core.typed/ann-form {} (U nil (HMap :optional {:a Number} :complete? true)))\n                      (clojure.core.typed/ann-form {} (U nil (HMap :optional {:b String} :complete? true))))\n               (U nil (HMap :optional {:a Number :b String} :complete? true)))\n  \n  ; this merge doesn't actually give us any information about :b because\n  ; the second map might not have a :b key, and the first map is partial.\n  (equal-types (merge (clojure.core.typed/ann-form {} (HMap :optional {:a Number} :complete? false))\n                      (clojure.core.typed/ann-form {} (HMap :optional {:b String} :complete? true)))\n               (HMap :optional {:a Number}))\n  \n  ; but this does\n  (equal-types (merge (clojure.core.typed/ann-form {} (HMap :optional {:a Number} :complete? false))\n                      (clojure.core.typed/ann-form {:b \"s\"} (HMap :mandatory {:b String} :complete? true)))\n               (HMap :mandatory {:b String} :optional {:a Number}))\n  \n  ; multiple optionals\n  (equal-types (merge (clojure.core.typed/ann-form {} (HMap :optional {:a Number} :complete? true))\n                      (clojure.core.typed/ann-form {} (HMap :optional {:b String} :complete? true))\n                      (clojure.core.typed/ann-form {} (HMap :optional {:c Long} :complete? true)))\n               (HMap :optional {:a Number :b String :c Long} :complete? true))\n  \n  ;; incomplete right handsides\n  \n  ; non-covering right hand side\n  (equal-types (merge {:a 5 :b 6}\n                      (clojure.core.typed/ann-form {} '{}))\n               '{:a clojure.core.typed/Any :b clojure.core.typed/Any})\n  \n  (equal-types (merge (clojure.core.typed/ann-form {:a 6} '{:a Number})\n                      (clojure.core.typed/ann-form {:b \"s\"} '{:b String}))\n               '{:a clojure.core.typed/Any :b String})\n  \n  ; incomplete covering mandatory\n  (equal-types (merge {:a 5}\n                      (clojure.core.typed/ann-form {:a 10} '{:a '10}))\n               '{:a '10})\n  \n  ; incomplete covering optional\n  (equal-types (merge {:a 5}\n                      (clojure.core.typed/ann-form {} (HMap :optional {:a (Value 10)})))\n               '{:a (U (Value 5) (Value 10))})\n  \n  \n  ; both incomplete optionals\n  (equal-types (merge (clojure.core.typed/ann-form {} (HMap :optional {:a '5}))\n                      (clojure.core.typed/ann-form {} (HMap :optional {:a '10})))\n               (HMap :optional {:a (U '5 '10)}))\n  \n  ; (Option HMap) first argument incomplete\n  (equal-types (merge (clojure.core.typed/ann-form {:a 5} (U nil '{:a '5}))\n                      (clojure.core.typed/ann-form {:b 8} (HMap :mandatory {:b Number} :complete? true)))\n               (U (HMap :mandatory {:b Number} :complete? true)\n                  '{:a '5 :b Number}))\n  \n  ;; nil (HMap :absent-keys #{:a}) -> (HMap :absent-keys #{:a})\n  ;; '{:a 5} '{} -> '{:a 5}\n  ;; nil '{:a Number} -> '{:a Number}\n  ;; '{:a 5} '{:a Number} -> '{:a Number}\n  ; clojure.core.typed/All together: (U '{:a Number} (HMap :absent-keys #{:a})) or (HMap :optional {:a Number})\n  (equal-types (merge (clojure.core.typed/ann-form {:a 5} (U nil '{:a '5}))\n                      (clojure.core.typed/ann-form {} (HMap :optional {:a Number} :complete? false)))\n               (HMap :optional {:a Number}))\n  \n  ; Basic maps\n  (equal-types (merge (clojure.core.typed/ann-form {} (clojure.lang.IPersistentMap clojure.core.typed/Any clojure.core.typed/Any)) {:a 5})\n               (clojure.lang.IPersistentMap clojure.core.typed/Any clojure.core.typed/Any))\n  \n  (equal-types (merge {} {'a 5})\n               (clojure.lang.IPersistentMap 'a '5))\n  \n  (equal-types (merge {:b 6} {'a 5})\n               (clojure.lang.IPersistentMap (U 'a ':b) (U '5 '6)))\n\n  (is-tc-e (fn [m1 :- '{:a Num}\n                m2 :- '{:b Num}]\n             :- '{:a Any :b Num}\n             (merge m1 m2)))\n\n  (is-tc-err (fn [m1 :- '{:a Num}\n                  m2 :- '{:b Num}]\n               :- '{:a Num :b Num}\n               (merge m1 m2)))\n\n;;  TODO not handling presence of non keyword keys yet\n;;   (equal-types (merge {'a 5} {:b 6})\n;;                (clojure.lang.IPersistentMap (U 'a ':b) (U '5 '6)))\n  \n  )", :ns "clojure.core.typed.test.core", :name "invoke-merge-test", :file "clojure/core/typed/test/core.clj", :column 1, :line 2187, :test #<core$fn__29099 clojure.core.typed.test.core$fn__29099@3ea5c544>}
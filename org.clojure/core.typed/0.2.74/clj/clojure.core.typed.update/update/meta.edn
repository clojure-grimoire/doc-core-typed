{:type :fn, :src "(defn update [t lo]\n  {:pre [((some-fn fl/TypeFilter? fl/NotTypeFilter?) lo)]\n   :post [(r/Type? %)]}\n  (u/p :check/update\n  (let [t (c/fully-resolve-type t)]\n    (cond\n      ; The easy cases: we have a filter without a further path to travel down.\n      ; Just update t with the correct polarity.\n\n      (and (fl/TypeFilter? lo)\n           (empty? (:path lo))) \n      (let [u (:type lo)\n            _ (assert (r/Type? u))\n            r (c/restrict t u)]\n        r)\n\n      (and (fl/NotTypeFilter? lo)\n           (empty? (:path lo))) \n      (let [u (:type lo)]\n        (assert (r/Type? u))\n        (remove/remove* t u))\n\n      ; unwrap unions and intersections to update their members\n\n      (r/Union? t) (let [ts (:types t)\n                       new-ts (mapv (fn [t] \n                                      (let [n (update t lo)]\n                                        n))\n                                    ts)]\n                   (apply c/Un new-ts))\n      (r/Intersection? t) (let [ts (:types t)]\n                          (apply c/In (doall (map (fn [t] (update t lo)) ts))))\n\n      ;from here, t is fully resolved and is not a Union or Intersection\n\n      ;heterogeneous map ops\n      ; Positive and negative information down a keyword path\n      ; eg. (number? (-> hmap :a :b))\n      (and ((some-fn fl/TypeFilter? fl/NotTypeFilter?) lo)\n           (pe/KeyPE? (first (:path lo)))\n           (r/HeterogeneousMap? t))\n      (let [polarity (fl/TypeFilter? lo)\n            {update-to-type :type :keys [path id]} lo\n            [fkeype & rstpth] path\n            fpth (cu/KeyPE->Type fkeype)\n            ; use this filter to update the right hand side value\n            next-filter ((if polarity fo/-filter fo/-not-filter) \n                         update-to-type id rstpth)\n            present? (contains? (:types t) fpth)\n            optional? (contains? (:optional t) fpth)\n            absent? (contains? (:absent-keys t) fpth)]\n        ;updating a KeyPE should consider 3 cases:\n        ; 1. the key is declared present\n        ; 2. the key is declared absent\n        ; 3. the key is not declared present, and is not declared absent\n        (cond\n          present?\n            ; -hmap simplifies to bottom if an entry is bottom\n            (c/make-HMap\n              :mandatory (update-in (:types t) [fpth] update next-filter)\n              :optional (:optional t)\n              :absent-keys (:absent-keys t)\n              :complete? (c/complete-hmap? t))\n          absent?\n            t\n\n          ; key not declared present or absent\n          :else\n          (let [; KeyPE are only used for `get` operations where `nil` is the\n                ; not-found value. If the filter does not hold when updating\n                ; it to nil, then we can assume this key path is present.\n                update-to-mandatory? (r/Bottom? (update r/-nil next-filter))]\n            (if update-to-mandatory?\n              (c/make-HMap \n                :mandatory (assoc-in (:types t) [fpth] (update r/-any next-filter))\n                :optional (:optional t)\n                :absent-keys (:absent-keys t)\n                :complete? (c/complete-hmap? t))\n              (c/make-HMap \n                :mandatory (:types t)\n                :optional (if optional?\n                            (update-in (:optional t) [fpth] update next-filter)\n                            (assoc-in (:optional t) [fpth] (update r/-any next-filter)))\n                :absent-keys (:absent-keys t)\n                :complete? (c/complete-hmap? t))))))\n\n      ; nil returns nil on keyword lookups\n      (and (fl/NotTypeFilter? lo)\n           (pe/KeyPE? (first (:path lo)))\n           (r/Nil? t))\n      (update r/-nil (update-in lo [:path] next))\n\n      ; update count information based on a call to `count`\n      ; eg. (= 1 (count a))\n      (and (fl/TypeFilter? lo)\n           (pe/CountPE? (first (:path lo))))\n      (let [u (:type lo)]\n        (if-let [cnt (cond \n                       ; for (= 1 (count v))\n                       (and (r/Value? u) (integer? (:val u)))\n                       (r/make-ExactCountRange (:val u))\n\n                       ; for (#{1 2 3} (count v))\n                       (and (r/Union? u) \n                            (every? (every-pred r/Value?\n                                                (comp integer? :val))\n                                    (:types u)))\n                       (let [ns (->> (map :val (:types u))\n                                     (remove neg?)\n                                     sort\n                                     vec)]\n                         (when (seq ns)\n                           (r/make-CountRange (first ns)\n                                              (last ns)))))]\n          (c/restrict t cnt)\n          (do (u/tc-warning \"Cannot infer Count from type \" (prs/unparse-type u))\n              t)))\n\n      ;can't do much without a NotCountRange type or difference type\n      (and (fl/NotTypeFilter? lo)\n           (pe/CountPE? (first (:path lo))))\n      t\n\n      (and (fl/TypeFilter? lo)\n           (pe/NthPE? (-> lo :path first))\n           (c/AnyHSequential? t))\n      (let [type (:type lo)\n            path-expr (-> lo :path first)\n            idx (:idx path-expr)\n            fixed-types (conj (vec (repeat idx r/-any)) type)\n            restriction-type (r/-hsequential fixed-types :rest r/-any)]\n        (c/restrict t restriction-type))\n\n      (and (fl/NotTypeFilter? lo)\n           (pe/NthPE? (-> lo :path first))\n           (c/AnyHSequential? t))\n      t\n\n      ; Update class information based on a call to `class`\n      ; eg. (= java.lang.Integer (class a))\n      (and (fl/TypeFilter? lo)\n           (pe/ClassPE? (-> lo :path first)))\n      (let [_ (assert (empty? (rest (:path lo))))\n            u (:type lo)]\n        (cond \n          ;restrict the obvious case where the path is the same as a Class Value\n          ; eg. #(= (class %) Number)\n          (and (r/Value? u)\n               (class? (:val u)))\n          (c/restrict t (c/RClass-of-with-unknown-params (:val u)))\n\n          ; handle (class nil) => nil\n          (r/Nil? u)\n          (c/restrict t r/-nil)\n\n          :else\n          (do (u/tc-warning \"Cannot infer type via ClassPE from type \" (prs/unparse-type u))\n              t)))\n\n      ; Does not tell us anything.\n      ; eg. (= Number (class x)) ;=> false\n      ;     does not reveal whether x is a subtype of Number, eg. (= Integer (class %))\n      (and (fl/NotTypeFilter? lo)\n           (pe/ClassPE? (-> lo :path first)))\n      t\n\n      ; keyword invoke of non-hmaps\n      ; (let [a (ann-form {} (Map Any Any))]\n      ;   (number? (-> a :a :b)))\n      ; \n      ; I don't think there's anything interesting worth encoding:\n      ; use HMap for accurate updating.\n      (and (or (fl/TypeFilter? lo)\n               (fl/NotTypeFilter? lo))\n           (pe/KeyPE? (first (:path lo))))\n      t\n\n      ; calls to `keys` and `vals`\n      (and ((some-fn fl/TypeFilter? fl/NotTypeFilter?) lo)\n           ((some-fn pe/KeysPE? pe/ValsPE?) (first (:path lo))))\n      (let [[fstpth & rstpth] (:path lo)\n            u (:type lo)\n            ;_ (prn \"u\" (prs/unparse-type u))\n\n            ; solve for x:  t <: (Seqable x)\n            x (gensym)\n            subst (free-ops/with-bounded-frees {(r/make-F x) r/no-bounds}\n                    (u/handle-cs-gen-failure\n                      (cgen/infer {x r/no-bounds} {} \n                                  [u]\n                                  [(c/RClass-of clojure.lang.Seqable [(r/make-F x)])]\n                                  r/-any)))\n            ;_ (prn \"subst for Keys/Vals\" subst)\n            _ (when-not subst\n                (err/int-error (str \"Cannot update \" (if (pe/KeysPE? fstpth) \"keys\" \"vals\") \" of an \"\n                                  \"IPersistentMap with type: \" (pr-str (prs/unparse-type u)))))\n            element-t-subst (get subst x)\n            _ (assert (crep/t-subst? element-t-subst))\n            ; the updated 'keys/vals' type\n            element-t (:type element-t-subst)\n            ;_ (prn \"element-t\" (prs/unparse-type element-t))\n            _ (assert element-t)]\n        (assert (empty? rstpth) (str \"Further path NYI keys/vals\"))\n        (if (fl/TypeFilter? lo)\n          (c/restrict t\n                      (if (pe/KeysPE? fstpth)\n                        (c/RClass-of IPersistentMap [element-t r/-any])\n                        (c/RClass-of IPersistentMap [r/-any element-t])))\n          ; can we do anything for a NotTypeFilter?\n          t))\n\n\n      :else (err/int-error (str \"update along ill-typed path \" (pr-str (prs/unparse-type t)) \" \" (with-out-str (pr lo))))))))", :ns "clojure.core.typed.update", :name "update", :file "clojure/core/typed/update.clj", :column 1, :line 121, :arglists ([t lo])}
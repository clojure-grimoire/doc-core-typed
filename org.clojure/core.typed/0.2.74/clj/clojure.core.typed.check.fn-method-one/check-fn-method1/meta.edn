{:type :fn, :src "(defn check-fn-method1 [method {:keys [dom rest drest kws] :as expected}\n                        & {:keys [recur-target-fn ignore-rng]}]\n  {:pre [(r/Function? expected)]\n   :post [(r/Function? (:ftype %))\n          (-> % :cmethod ::t/ftype r/Function?)\n          (:cmethod %)]}\n  (impl/impl-case\n    :clojure (assert (#{:fn-method :method} (:op method))\n                     (:op method))\n    ; is there a better :op check here?\n    :cljs (assert method))\n  #_(prn \"checking syntax:\" (ast-u/emit-form-fn method))\n  ;(prn \"check-fn-method1\" \"ignore-rng\" ignore-rng)\n  (u/p :check/check-fn-method1\n  (let [body ((ast-u/method-body-kw) method)\n        required-params (ast-u/method-required-params method)\n        rest-param (ast-u/method-rest-param method)\n\n        param-obj (comp #(obj/-path nil %)\n                        :name)\n        ; Difference from Typed Racket:\n        ;\n        ; Because types can contain abstracted names, we instantiate\n        ; the expected type in the range before using it.\n        ;\n        ; eg. Checking against this function type:\n        ;      [Any Any\n        ;       -> (HVec [(U nil Class) (U nil Class)]\n        ;                :objects [{:path [Class], :id 0} {:path [Class], :id 1}])]\n        ;     means we need to instantiate the HVec type to the actual argument\n        ;     names with open-Result.\n        ;\n        ;     If the actual function method is (fn [a b] ...) we check against:\n        ;\n        ;       (HVec [(U nil Class) (U nil Class)]\n        ;              :objects [{:path [Class], :id a} {:path [Class], :id b}])\n        expected-rng (when-not ignore-rng\n                       (apply r/ret\n                              (open-result/open-Result \n                                (:rng expected)\n                                (map param-obj\n                                     (concat required-params \n                                             (when rest-param [rest-param]))))))\n        ;_ (prn \"expected-rng\" expected-rng)\n        ;ensure Function fits method\n        _ (when-not ((if (or rest drest kws) <= =) (count required-params) (count dom))\n            (err/int-error (str \"Checking method with incorrect number of expected parameters\"\n                              \", expected \" (count dom) \" required parameter(s) with\"\n                              (if rest \" a \" \" no \") \"rest parameter, found \" (count required-params)\n                              \" required parameter(s) and\" (if rest-param \" a \" \" no \")\n                              \"rest parameter.\")))\n\n        _ (when-not (or (not rest-param)\n                        (some identity [drest rest kws]))\n            (err/int-error (str \"No type for rest parameter\")))\n\n        ;;unhygienic version\n        ;        ; Update filters that reference bindings that the params shadow.\n        ;        ; Abstracting references to parameters is handled later in abstract-result, but\n        ;        ; suffers from bugs due to un-hygienic macroexpansion (see `abstract-result`).\n        ;        ; c/In short, don't shadow parameters if you want meaningful filters.\n        ;        props (mapv (fn [oldp]\n        ;                      (reduce (fn [p sym]\n        ;                                {:pre [(fl/Filter? p)\n        ;                                       (symbol? sym)]}\n        ;                                (subst-filter p sym obj/-empty true))\n        ;                              oldp (map :sym required-params)))\n        ;                    (:props lex/*lexical-env*))\n\n        props (:props lex/*lexical-env*)\n        crequired-params (map (fn [p t] (assoc p u/expr-type (r/ret t)))\n                              required-params\n                              (concat dom \n                                      (repeat (or rest (:pre-type drest)))))\n        _ (assert (every? (comp r/TCResult? u/expr-type) crequired-params))\n        fixed-entry (map (juxt :name (comp r/ret-t u/expr-type)) crequired-params)\n        ;_ (prn \"checking function:\" (prs/unparse-type expected))\n        check-fn-method1-rest-type fn-method-u/*check-fn-method1-rest-type*\n        _ (assert check-fn-method1-rest-type \"No check-fn bound for rest type\")\n        crest-param (when rest-param\n                      (assoc rest-param\n                             u/expr-type (r/ret (check-fn-method1-rest-type (drop (count crequired-params) dom) rest drest kws))))\n        rest-entry (when crest-param\n                     [[(:name crest-param) (r/ret-t (u/expr-type crest-param))]])\n        ;_ (prn \"rest entry\" rest-entry)\n        _ (assert ((con/hash-c? symbol? r/Type?) (into {} fixed-entry))\n                  (into {} fixed-entry))\n        _ (assert ((some-fn nil? (con/hash-c? symbol? r/Type?)) (when rest-entry\n                                                              (into {} rest-entry))))\n\n        ; if this fn method is a multimethod dispatch method, then infer\n        ; a new filter that results from being dispatched \"here\"\n        mm-filter (when-let [{:keys [dispatch-fn-type dispatch-val-ret]} multi-u/*current-mm*]\n                    (u/p :check/check-fn-method1-inner-mm-filter-calc\n                    (assert (and dispatch-fn-type dispatch-val-ret))\n                    (assert (not (or drest rest rest-param)))\n                    (let [disp-app-ret (funapp/check-funapp nil nil \n                                                     (r/ret dispatch-fn-type)\n                                                     (map r/ret dom (repeat (fo/-FS fl/-top fl/-top)) \n                                                          (map param-obj required-params))\n                                                     nil)\n                          ;_ (prn \"disp-app-ret\" disp-app-ret)\n                          ;_ (prn \"disp-fn-type\" (prs/unparse-type dispatch-fn-type))\n                          ;_ (prn \"dom\" dom)\n                          isa-ret (isa/tc-isa? disp-app-ret dispatch-val-ret)\n                          then-filter (-> isa-ret r/ret-f :then)\n                          _ (assert then-filter)]\n                      then-filter)))\n        ;_ (prn \"^^^ mm-filter\")\n\n        ;_ (prn \"funapp1: inferred mm-filter\" mm-filter)\n\n        env (let [env (-> lex/*lexical-env*\n                          ;add mm-filter\n                          (assoc-in [:props] (set (concat props (when mm-filter [mm-filter]))))\n                          ;add parameters to scope\n                          ;IF UNHYGIENIC order important, (fn [a a & a]) prefers rightmost name\n                          (update-in [:l] merge (into {} fixed-entry) (into {} rest-entry)))\n                  flag (atom true :validator con/boolean?)\n                  env (if mm-filter\n                        (let [t (update/env+ env [mm-filter] flag)]\n                          t)\n                        env)]\n              (when-not @flag\n                (err/int-error \"Unreachable method: Local inferred to be bottom when applying multimethod filter\"))\n              env)\n\n        check-fn-method1-checkfn fn-method-u/*check-fn-method1-checkfn*\n        _ (assert check-fn-method1-checkfn \"No check-fn bound for method1\")\n        ; rng before adding new filters\n        crng-nopass\n        (u/p :check/check-fn-method1-chk-rng-pass1\n        (binding [multi-u/*current-mm* nil]\n          (var-env/with-lexical-env env\n            (let [rec (or ; if there's a custom recur behaviour, use the provided\n                          ; keyword argument to generate the RecurTarget.\n                          (when recur-target-fn\n                            (recur-target-fn expected))\n                          ; Otherwise, assume we are checking a regular `fn` method\n                          (recur-u/->RecurTarget dom rest drest nil))\n                  _ (assert (recur-u/RecurTarget? rec))]\n              (recur-u/with-recur-target rec\n                (check-fn-method1-checkfn body expected-rng))))))\n\n        ; Apply the filters of computed rng to the environment and express\n        ; changes to the lexical env as new filters, and conjoin with existing filters.\n\n        {:keys [then]} (-> crng-nopass u/expr-type r/ret-f)\n        then-env (u/p :check/check-fn-method1-env+-rng\n                   (update/env+ env [then] (atom true)))\n        new-then-props (reduce (fn [fs [sym t]]\n                                 {:pre [((con/set-c? fl/Filter?) fs)]}\n                                 (if (= t (get-in env [:l sym]))\n                                   ;type hasn't changed, no new propositions\n                                   fs\n                                   ;new type, add positive proposition\n                                   (conj fs (fo/-filter t sym))))\n                               #{}\n                               (:l then-env))\n\n        crng (u/p :check/check-fn-method1-add-rng-filters\n               (update-in crng-nopass [u/expr-type :fl :then] \n                          (fn [f]\n                            (apply fo/-and f new-then-props))))\n        ;_ (prn \"crng\" (u/expr-type crng))\n        rest-param-name (when rest-param\n                          (:name rest-param))\n        \n        ftype (fn-method-u/FnResult->Function \n                (fn-method-u/->FnResult \n                  fixed-entry \n                  (when (and kws rest-param)\n                    [rest-param-name kws])\n                  (when (and rest rest-param)\n                    [rest-param-name rest])\n                  (when (and drest rest-param) \n                    [rest-param-name drest])\n                  (u/expr-type crng)))\n                        \n        cmethod (-> (assoc method\n                           (ast-u/method-body-kw) crng\n                           ::t/ftype ftype)\n                    (ast-u/reconstruct-arglist crequired-params crest-param))\n        _ (assert (vector? (:params cmethod)))\n        _ (assert (every? (comp r/TCResult? u/expr-type) (:params cmethod)))]\n     {:ftype ftype\n      :cmethod cmethod})))", :ns "clojure.core.typed.check.fn-method-one", :name "check-fn-method1", :file "clojure/core/typed/check/fn_method_one.clj", :column 1, :line 41, :arglists ([method {:keys [dom rest drest kws], :as expected} & {:keys [recur-target-fn ignore-rng]}])}
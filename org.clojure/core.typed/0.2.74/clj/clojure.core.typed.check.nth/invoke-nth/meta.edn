{:type :fn, :src "(defn invoke-nth [check-fn {:keys [args] :as expr} expected & {:keys [cargs]}]\n  {:pre [((some-fn nil? vector?) cargs)\n         (#{:static-call} (:op expr))]\n   :post [(or (#{cu/not-special} %)\n              (-> % u/expr-type r/TCResult?))]}\n  (let [_ (assert (#{2 3} (count args)) (str \"nth takes 2 or 3 arguments, actual \" (count args)))\n        [te ne de :as cargs] (or cargs (mapv check-fn args))\n        types (let [ts (c/fully-resolve-type (expr->type te))]\n                (if (r/Union? ts)\n                  (map c/fully-resolve-type (:types ts))\n                  [ts]))\n        num-t (expr->type ne)\n        default-t (expr->type de)]\n    (cond\n      (and (nat-value? num-t)\n           (every? (some-fn r/Nil?\n                            r/HeterogeneousVector?\n                            r/HeterogeneousList?\n                            r/HeterogeneousSeq?)\n                   types))\n      (let [idx (:val num-t)]\n        (assoc expr\n          :args cargs\n          u/expr-type (r/ret (nth-type types idx default-t)\n                             (nth-filter te de idx default-t)\n                             (nth-object te idx))))\n\n      ; rewrite nth type to be more useful when we have an exact (and interesting) index.\n      (nat-value? num-t)\n      (method/check-invoke-method\n        check-fn expr expected false\n        :method-override (nth-function-type (-> num-t :val))\n        :cargs cargs)\n      :else cu/not-special)))", :ns "clojure.core.typed.check.nth", :name "invoke-nth", :file "clojure/core/typed/check/nth.clj", :column 1, :line 125, :arglists ([check-fn {:keys [args], :as expr} expected & {:keys [cargs]}])}
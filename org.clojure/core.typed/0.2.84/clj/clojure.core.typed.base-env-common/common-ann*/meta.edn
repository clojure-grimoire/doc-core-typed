{:type :var, :src "(def common-ann*\n  \"\n    clojure.core/*1 Any\n    clojure.core/*2 Any\n    clojure.core/*3 Any\n    clojure.core/identical? [Any Any -> Boolean]\n    clojure.core/number? (Pred Number)\n    clojure.core/not [Any -> Boolean]\n    clojure.core/string? (Pred String)\n    clojure.core/type [Any -> Any]\n    clojure.core/aclone (All [x] [(ReadOnlyArray x) -> (Array x)])\n\n    clojure.core/aget\n    (All [x]\n         (IFn [(ReadOnlyArray x)\n               AnyInteger -> x]\n              [(ReadOnlyArray (ReadOnlyArray x))\n               AnyInteger AnyInteger -> x]\n              [(ReadOnlyArray (ReadOnlyArray (ReadOnlyArray x)))\n               AnyInteger AnyInteger AnyInteger -> x]\n              [(ReadOnlyArray (ReadOnlyArray (ReadOnlyArray (ReadOnlyArray x))))\n               AnyInteger AnyInteger AnyInteger AnyInteger -> x]\n                                        ; don't support unsound cases\n              [(ReadOnlyArray (ReadOnlyArray (ReadOnlyArray (ReadOnlyArray (ReadOnlyArray x)))))\n               AnyInteger AnyInteger AnyInteger AnyInteger AnyInteger -> x]))\n    clojure.core/aset\n    (All [x]\n         (IFn\n          [(Array x) AnyInteger x -> x]\n          [(Array x) AnyInteger AnyInteger x -> x]\n          [(Array x) AnyInteger AnyInteger AnyInteger x -> x]\n          [(Array x) AnyInteger AnyInteger AnyInteger AnyInteger x -> x]\n          [(Array x) AnyInteger AnyInteger AnyInteger AnyInteger AnyInteger x -> x]\n          [(Array x) AnyInteger AnyInteger AnyInteger AnyInteger AnyInteger AnyInteger x -> x]\n          [(Array x) AnyInteger AnyInteger AnyInteger AnyInteger AnyInteger AnyInteger AnyInteger x -> x]\n          [(Array x) AnyInteger AnyInteger AnyInteger AnyInteger AnyInteger AnyInteger AnyInteger AnyInteger x -> x]\n          [(Array x) AnyInteger AnyInteger AnyInteger AnyInteger AnyInteger AnyInteger AnyInteger AnyInteger AnyInteger x -> x]\n          [(Array x) AnyInteger AnyInteger AnyInteger AnyInteger AnyInteger AnyInteger AnyInteger AnyInteger AnyInteger AnyInteger x -> x]))\n\n    clojure.core/alength [(ReadOnlyArray Any) -> AnyInteger]\n    ;clojure.core/instance? [Class Any -> Booelan]\n    clojure.core/symbol? (Pred Symbol)\n    clojure.core/symbol (IFn [(U Symbol String) -> Symbol]\n                             [(U nil String) String -> Symbol])\n    clojure.core/seq (All [x]\n                          (IFn\n                           [(NonEmptyColl x) -> (NonEmptyASeq x)]\n                           [(Option (Coll x)) -> (Option (NonEmptyASeq x))\n                            :filters {:then (& (is NonEmptyCount 0)\n                                               (! nil 0))\n                                      :else (| (is nil 0)\n                                               (is EmptyCount 0))}]\n                           [(Option (Seqable x)) -> (Option (NonEmptyASeq x))]))\n    clojure.core/first (All [x]\n                            (IFn [(HSequential [x Any *]) -> x\n                                  :object {:id 0 :path [(Nth 0)]}]\n                                 [(Option (EmptySeqable x)) -> nil]\n                                 [(NonEmptySeqable x) -> x]\n                                 [(Option (Seqable x)) -> (Option x)]))\n    clojure.core/rest (All [x]\n                           [(Option (Seqable x)) -> (ASeq x)])\n    clojure.core/next (All [x]\n                           (IFn [(Option (Coll x)) -> (Option (NonEmptyASeq x))\n                                 :filters {:then (& (is (CountRange 2) 0)\n                                                    (! nil 0))\n                                           :else (| (is (CountRange 0 1) 0)\n                                                    (is nil 0))}]\n                                [(Option (Seqable x)) -> (Option (NonEmptyASeq x))]))\n    clojure.core/= [Any Any * -> Boolean]\n    ;clojure.core/reduced (All [x] [x -> (Reduced x)])\n    ;clojure.core/reduced? (Pred (Reduced Any))\n    clojure.core/second\n    (All [x]\n         (IFn [(HSequential [Any x Any *]) -> x\n               :object {:id 0 :path [(Nth 1)]}]\n              [(Option (I (Seqable x) (CountRange 0 1))) -> nil]\n              [(I (Seqable x) (CountRange 2)) -> x]\n              [(Option (Seqable x)) -> (Option x)]))\n    clojure.core/ffirst (All [x]\n                             [(Option (Seqable (U nil (Seqable x)))) -> (Option x)])\n                                        ;clojure.core/nfirst\n    #_(All [x]\n           [(Option (Seqable (Option (Seqable x))))\n            -> (Option (NonEmptyASeq x))])\n                                        ;clojure.core/fnext\n    #_(All [x]\n           [(Option (Seqable (Option (Seqable x)))) -> (Option x)])\n    clojure.core/nnext (All [x]\n                            [(Option (Seqable x)) -> (Option (NonEmptyASeq x))])\n    clojure.core/last (All [x]\n                           (IFn [(NonEmptySeqable x) -> x]\n                                [(Option (Seqable x)) -> (U nil x)]))\n    clojure.core/conj (All [x y]\n                           (IFn [(IPersistentVector x) x x * -> (IPersistentVector x)]\n                                [(APersistentMap x y)\n                                 (U nil (Seqable (IMapEntry x y))\n                                    (IMapEntry x y) '[x y] (Map x y))\n                                 (U nil (Seqable (IMapEntry x y))\n                                    (IMapEntry x y) '[x y] (Map x y)) *\n                                    -> (APersistentMap x y)]\n                                [(IPersistentMap x y)\n                                 (U nil (Seqable (IMapEntry x y))\n                                    (IMapEntry x y) '[x y] (Map x y))\n                                 (U nil (Seqable (IMapEntry x y))\n                                    (IMapEntry x y) '[x y] (Map x y)) * -> (IPersistentMap x y)]\n                                [(IPersistentSet x) x x * -> (IPersistentSet x)]\n                                [(ASeq x) x x * -> (ASeq x)]\n                                ;[nil x x * -> (clojure.lang.PersistentList x)]\n                                [(Coll Any) Any Any * -> (Coll Any)]))\n    clojure.core/get (All [x y]\n                          (IFn\n                           ;;no default\n                           [(U nil (Set x) (ILookup Any x)) Any -> (Option x)]\n                           ;[(Option String) Any -> (Option Character)]\n                           ;;default\n                           [(U nil (Set x) (ILookup Any x)) Any y -> (U y x)]\n                           [(Option (Map x y)) x -> (Option y)]\n                           [(Option (Map x y)) x y -> y]\n                           [(Option (Map Any Any)) Any -> (Option Any)]\n                           [(Option (Map Any Any)) Any y -> (U y Any)]\n                           ;[(Option String) Any y -> (U y Character)]\n                           ))\n    clojure.core/assoc (All [b c d]\n                            (IFn [(Map b c) b c -> (Map b c)]\n                                 [(Vec d) AnyInteger d -> (Vec d)]))\n    clojure.core/dissoc (All [k v]\n                             (IFn [(Map k v) Any * -> (Map k v)]))\n                                        ;clojure.core/with-meta\n    #_(All [[x :< clojure.lang.IObj]]\n           [x (U nil (Map Any Any)) -> x])\n    clojure.core/meta [Any -> (U nil (Map Any Any))]\n    clojure.core/peek\n    (All [x]\n           (IFn [(I NonEmptyCount (Stack x)) -> x]\n                [(Stack x) -> x]))\n    ;;clojure.core/pop (All [x]\n    ;;                      (IFn\n    ;;                       [(List x) -> (List x)]\n    ;;                       [(Vec x) -> (Vec x)]\n    ;;                       [(Stack x) -> (Stack x)]))\n    clojure.core/disj\n    (All [x]\n         (IFn #_[(SortedSet x) Any Any * -> (SortedSet x)]\n              [(Set x) Any Any * -> (Set x)]))\n    clojure.core/hash [Any -> AnyInteger]\n    clojure.core/empty? (IFn [(Option (HSequential [Any *])) -> Boolean\n                              :filters {:then (| (is EmptyCount 0)\n                                                 (is nil 0))\n                                        :else (is NonEmptyCount 0)}]\n                             [(Option (Coll Any)) -> Boolean\n                              :filters {:then (| (is EmptyCount 0)\n                                                 (is nil 0))\n                                        :else (is NonEmptyCount 0)}]\n                             [(Option (Seqable Any)) -> Boolean])\n    clojure.core/coll? (Pred (Coll Any))\n                                        ;clojure.core/set? (Pred (Set Any))\n    ;clojure.core/associative? (Pred (clojure.lang.Associative Any Any))\n    ;clojure.core/sequential? (Pred clojure.lang.Sequential)\n                                        ;clojure.core/sorted? (Pred Sorted)\n    clojure.core/map? (Pred (Map Any Any))\n    clojure.core/vector? (Pred (Vec Any))\n    clojure.core/chunked-seq? [Any -> Any]\n    clojure.core/false? (Pred false)\n    clojure.core/true? (Pred true)\n    clojure.core/seq? (Pred (Seq Any))\n    clojure.core/boolean [Any -> Boolean]\n    clojure.core/integer? (Pred AnyInteger)\n    clojure.core/contains? [(Option (Seqable Any)) Any -> Boolean]\n    clojure.core/find (All [x y]\n                           [(U nil (Associative x y)) Any -> (U nil (HVec [x y]))])\n    clojure.core/distinct? [Any Any * -> Boolean]\n    clojure.core/compare [Any Any -> Number]\n    clojure.core/sort (All [x]\n                           (IFn [(U nil (Seqable x)) -> (U nil (ASeq x))]\n                                [[x x -> AnyInteger] (U nil (Seqable x)) -> (U nil (ASeq x))]))\n    clojure.core/shuffle (All [x]\n                              (IFn [(I (Collection x) (Seqable x)) -> (Vec x)]\n                                   [(Collection x) -> (Vec x)]))\n    clojure.core/reduce\n    (All [a c]\n         (IFn\n          ;;Without accumulator\n          ;; default\n          ;; (reduce + my-coll)\n          [[a c -> (U (Reduced a) a)] (NonEmptySeqable c) -> a]\n          [(IFn [a c -> (U (Reduced a) a)] [-> (U (Reduced a) a)]) (Option (Seqable c)) -> a]\n          ;; default\n          ;; (reduce + 3 my-coll)\n          [[a c -> (U (Reduced a) a)] a (Option (Seqable c)) -> a]))\n    clojure.core/reduce-kv\n    (All [a c k v]\n         [[a k v -> (U (Reduced a) a)] a (Option (Associative k v)) -> a])\n    clojure.core/< [Number Number * -> Boolean]\n    clojure.core/<= [Number Number * -> Boolean]\n    clojure.core/> [Number Number * -> Boolean]\n    clojure.core/>= [Number Number * -> Boolean]\n    clojure.core/== [Number Number * -> Boolean]\n    clojure.core/max [Number Number * -> Number]\n    clojure.core/min [Number Number * -> Number]\n    clojure.core/int (IFn [Number -> Integer]\n                          ;[Character -> Integer]\n                          )\n    clojure.core/booleans [Any -> (Array boolean)]\n    clojure.core/ints [Any -> (Array int)]\n    clojure.core/mod (IFn [AnyInteger AnyInteger -> AnyInteger]\n                          [Number Number -> Number])\n    clojure.core/rand (IFn [-> Number]\n                           [Number -> Number])\n    clojure.core/rand-int [Int -> Int]\n    clojure.core/bit-xor [AnyInteger AnyInteger AnyInteger * -> AnyInteger]\n    clojure.core/bit-or [AnyInteger AnyInteger AnyInteger * -> AnyInteger]\n    clojure.core/bit-and-not [AnyInteger AnyInteger AnyInteger * -> AnyInteger]\n    clojure.core/bit-clear [AnyInteger AnyInteger -> AnyInteger]\n    clojure.core/bit-flip [AnyInteger AnyInteger -> AnyInteger]\n    clojure.core/bit-not [AnyInteger -> AnyInteger]\n    clojure.core/bit-set [AnyInteger AnyInteger -> AnyInteger]\n    clojure.core/bit-test [AnyInteger AnyInteger -> AnyInteger]\n    clojure.core/bit-shift-left [AnyInteger AnyInteger -> AnyInteger]\n    clojure.core/bit-shift-right [AnyInteger AnyInteger -> AnyInteger]\n    clojure.core/pos? (IFn [Number -> Boolean])\n                                        ;clojure.core/zero? (Pred (Value 0))\n    clojure.core/neg? (IFn [Number -> Boolean])\n    clojure.core/nthnext\n    (All [x]\n         (IFn [nil AnyInteger -> nil]\n              [(Option (Seqable x)) AnyInteger -> (Option (NonEmptyASeq x))]))\n    clojure.core/str [Any * -> String]\n    clojure.core/subs (IFn [String AnyInteger -> String]\n                           [String AnyInteger AnyInteger -> String])\n    clojure.core/hash-combine [AnyInteger Any -> AnyInteger]\n    ;clojure.core/rseq\n    #_(All [x]\n         [(Reversible x) -> (Option (NonEmptyASeq x))])\n    clojure.core/reverse (All [x]\n                              [(Option (Seqable x)) -> (ASeq x)])\n    clojure.core/list (All [x] [x * -> (PersistentList x)])\n    clojure.core/cons (All [x]\n                           [x (Option (Seqable x)) -> (ASeq x)])\n    clojure.core/list? (Pred (List Any))\n    clojure.core/keyword? (Pred Keyword)\n    clojure.core/namespace [(U Symbol String Keyword) -> (Option String)]\n    clojure.core/keyword (IFn [(U Keyword Symbol String) -> Keyword]\n                              [String String -> Keyword])\n    #_clojure.core/chunk-cons\n    #_(All [x]\n         [(clojure.lang.IChunk x) (Option (Seqable x)) -> (Option (Seqable x))])\n    #_clojure.core/chunk-append \n    #_(All [x]\n                                   [(clojure.lang.ChunkBuffer x) x -> Any])\n    #_clojure.core/chunk\n    #_(All [x]\n         [(clojure.lang.ChunkBuffer x) -> (clojure.lang.IChunk x)])\n    #_clojure.core/chunk-first #_(All [x]\n                                  ;;should be IChunkedSeq -> IChunk\n                                  [(Seqable x) -> (clojure.lang.IChunk x)])\n    #_clojure.core/chunk-rest\n    #_(All [x]\n         ;;should be IChunkRest -> Seq\n         [(clojure.lang.Seqable x) -> (ASeq x)])\n    clojure.core/int-array\n    (IFn [(U nil Number (Seqable Number)) -> (Array int)]\n         [Number (U nil Number (Seqable Number)) -> (Array int)])\n    clojure.core/concat (All [x] [(Option (Seqable x)) * -> (ASeq x)])\n    clojure.core/list*\n    (All [x]\n         (IFn [(U nil (Seqable x)) -> (NilableNonEmptyASeq x)]\n              [x (U nil (Seqable x)) -> (NilableNonEmptyASeq x)]\n              [x x (U nil (Seqable x)) -> (NilableNonEmptyASeq x)]\n              [x x x (U nil (Seqable x)) -> (NilableNonEmptyASeq x)]\n              [x x x x (U nil (Seqable x)) -> (NilableNonEmptyASeq x)]\n              [x x x x x (U nil (Seqable x)) -> (NilableNonEmptyASeq x)]\n              [x x x x x x (U nil (Seqable x)) -> (NilableNonEmptyASeq x)]\n              [x x x x x x x (U nil (Seqable x)) -> (NilableNonEmptyASeq x)]\n              [x x x x x x x x (U nil (Seqable x)) -> (NilableNonEmptyASeq x)]\n              [x x x x x x x x x (U nil (Seqable x)) -> (NilableNonEmptyASeq x)]\n              [x x x x x x x x x x (U nil (Seqable x)) -> (NilableNonEmptyASeq x)]))\n    clojure.core/apply\n    (All [y a b c d r z ...]\n         (IFn [[z ... z -> y] (HSequential [z ... z]) -> y]\n              [[a z ... z -> y] a (HSequential [z ... z]) -> y]\n              [[a b z ... z -> y] a b (HSequential [z ... z]) -> y]\n              [[a b c z ... z -> y] a b c (HSequential [z ... z]) -> y]\n              [[a b c d z ... z -> y] a b c d (HSequential [z ... z]) -> y]\n              [[r * -> y] (U nil (Seqable r)) -> y]\n              [[a r * -> y] a (U nil (Seqable r)) -> y]\n              [[a b r * -> y] a b (U nil (Seqable r)) -> y]\n              [[a b c r * -> y] a b c (U nil (Seqable r)) -> y]\n              [[a b c d r * -> y] a b c d (U nil (Seqable r)) -> y]))\n                                        ;clojure.core/vary-meta\n    #_(All [[x :< clojure.lang.IObj] b ...]\n           [x [(U nil (Map Any Any)) b ... b -> (U nil (Map Any Any))] b ... b -> x])\n    clojure.core/not= [Any Any * -> Boolean]\n    clojure.core/every?\n    (All [x y]\n         (IFn [[x -> Any :filters {:then (is y 0)}] (Coll x) -> Boolean\n               :filters {:then (is (Coll y) 1)}]\n                                        ; argument could be nil\n              [[x -> Any :filters {:then (is y 0)}] (U nil (Coll x)) -> Boolean\n               :filters {:then (is (U nil (Coll y)) 1)}]\n              [[x -> Any] (U nil (Seqable x)) -> Boolean]))\n    clojure.core/some (All [x y] [[x -> y] (Option (Seqable x)) -> (Option y)])\n    clojure.core/even? [AnyInteger -> Boolean]\n    clojure.core/odd? [AnyInteger -> Boolean]\n    clojure.core/identity (All [x] [x -> x\n                                    :filters {:then (! (U nil false) 0)\n                                              :else (is (U nil false) 0)}\n                                    :object {:id 0}])\n    clojure.core/complement (All [x] [[x -> Any] -> [x -> Boolean]])\n    clojure.core/constantly (All [x] [x -> [Any * -> x]])\n    clojure.core/comp (All [x y b ...]\n                           [[x -> y] [b ... b -> x] -> [b ... b -> y]])\n    clojure.core/partial\n    (All [y a b c d z ...]\n         (IFn [[z ... z -> y] -> [z ... z -> y]]\n              [[a z ... z -> y] a -> [z ... z -> y]]\n              [[a b z ... z -> y] a b -> [z ... z -> y]]\n              [[a b c z ... z -> y] a b c -> [z ... z -> y]]\n              [[a b c d z ... z -> y] a b c d -> [z ... z -> y]]\n              [[a * -> y] a * -> [a * -> y]]))\n    clojure.core/fnil\n    (All [x y z a b ...]\n         (IFn [[x b ... b -> a] x -> [(U nil x) b ... b -> a]]\n              [[x y b ... b -> a] x y -> [(U nil x) (U nil y) b ... b -> a]]\n              [[x y z b ... b -> a] x y z -> [(U nil x) (U nil y) (U nil z) b ... b -> a]]))\n    clojure.core/map-indexed\n    (All [x y] [[AnyInteger x -> y] (Option (Seqable x)) -> (Seqable y)])\n\n    clojure.core/every-pred\n    (All [t0 t1 t2 t3 t4 t5]\n         (IFn [[Any -> Boolean :filters {:then (is t0 0) :else (! t0 0)}]\n               -> (IFn [Any -> Boolean :filters {:then (is t0 0) :else (! t0 0)}]\n                       [Any * -> Any])]\n              [[Any -> Boolean :filters {:then (is t0 0) :else (! t0 0)}]\n               [Any -> Boolean :filters {:then (is t1 0) :else (! t1 0)}]\n               -> (IFn [Any -> Boolean :filters {:then (is (I t0 t1) 0) :else (! (I t0 t1) 0)}]\n                       [Any * -> Any])]\n              [[Any -> Boolean :filters {:then (is t0 0) :else (! t0 0)}]\n               [Any -> Boolean :filters {:then (is t1 0) :else (! t1 0)}]\n               [Any -> Boolean :filters {:then (is t2 0) :else (! t2 0)}]\n               -> (IFn [Any -> Boolean :filters {:then (is (I t0 t1 t2) 0) :else (! (I t0 t1 t2) 0)}]\n                       [Any * -> Any])]\n              [[Any -> Boolean :filters {:then (is t0 0) :else (! t0 0)}]\n               [Any -> Boolean :filters {:then (is t1 0) :else (! t1 0)}]\n               [Any -> Boolean :filters {:then (is t2 0) :else (! t2 0)}]\n               [Any -> Boolean :filters {:then (is t3 0) :else (! t3 0)}]\n               -> (IFn [Any -> Boolean :filters {:then (is (I t0 t1 t2 t3) 0) :else (! (I t0 t1 t2 t3) 0)}]\n                       [Any * -> Any])]\n              [[Any -> Boolean :filters {:then (is t0 0) :else (! t0 0)}]\n               [Any -> Boolean :filters {:then (is t1 0) :else (! t1 0)}]\n               [Any -> Boolean :filters {:then (is t2 0) :else (! t2 0)}]\n               [Any -> Boolean :filters {:then (is t3 0) :else (! t3 0)}]\n               [Any -> Boolean :filters {:then (is t4 0) :else (! t4 0)}]\n               -> (IFn [Any -> Boolean :filters {:then (is (I t0 t1 t2 t3 t4) 0) :else (! (I t0 t1 t2 t3 t4) 0)}]\n                       [Any * -> Any])]\n              [[Any -> Any :filters {:then (is t0 0) :else (! t0 0)}]\n               [Any -> Any :filters {:then (is t1 0) :else (! t1 0)}]\n               [Any -> Any :filters {:then (is t2 0) :else (! t2 0)}]\n               [Any -> Any :filters {:then (is t3 0) :else (! t3 0)}]\n               [Any -> Any :filters {:then (is t4 0) :else (! t4 0)}]\n               [Any -> Any :filters {:then (is t5 0) :else (! t5 0)}]\n               -> (IFn [Any -> Boolean :filters {:then (is (I t0 t1 t2 t3 t4 t5) 0) :else (! (I t0 t1 t2 t3 t4 t5) 0)}]\n                       [Any * -> Any])]\n              [[Any -> Any] [Any -> Any] * -> [Any * -> Any]]))\n\n\n    clojure.core/map\n    (All [c a b ...]\n         (IFn [[a b ... b -> c] (NonEmptySeqable a) (NonEmptySeqable b) ... b -> (NonEmptyASeq c)]\n              [[a b ... b -> c] (U nil (Seqable a)) (U nil (Seqable b)) ... b -> (ASeq c)]))\n\n    clojure.core/mapcat\n    (All [c b ...]\n         [[b ... b -> (Option (Seqable c))] (Option (Seqable b)) ... b -> (ASeq c)])\n\n    clojure.core/pmap\n    (All [c a b ...]\n         (IFn [[a b ... b -> c] (NonEmptySeqable a) (NonEmptySeqable b) ... b -> (NonEmptyASeq c)]\n              [[a b ... b -> c] (U nil (Seqable a)) (U nil (Seqable b)) ... b -> (ASeq c)]))\n\n    clojure.core/take (All [x]\n                           [AnyInteger (Seqable x) -> (ASeq x)])\n    clojure.core/drop (All [x]\n                           [AnyInteger (Seqable x) -> (ASeq x)])\n    clojure.core/drop-last (All [x]\n                                [AnyInteger (Seqable x) -> (NilableNonEmptyASeq x)])\n    clojure.core/take-last (All [x]\n                                [AnyInteger (Seqable x) -> (NilableNonEmptyASeq x)])\n    clojure.core/drop-while (All [x]\n                                 [[x -> Any] (Option (Seqable x)) -> (ASeq x)])\n    clojure.core/cycle (All [x]\n                            [(U nil (Seqable x)) -> (ASeq x)])\n    clojure.core/split-at\n    (All [x y z]\n         [AnyInteger (Option (Seqable x)) -> '[(ASeq x) (ASeq x)]])\n    clojure.core/repeat (All [x]\n                             (IFn [x -> (ASeq x)]\n                                  [AnyInteger x -> (ASeq x)]))\n    clojure.core/repeatedly (All [x]\n                                 (IFn [[-> x] -> (ASeq x)]\n                                      [AnyInteger [-> x] -> (ASeq x)]))\n    clojure.core/iterate (All [x]\n                              [[x -> x] x -> (ASeq x)])\n    clojure.core/interleave (All [x] [(Option (Seqable x)) (Option (Seqable x)) (Option (Seqable x)) * -> (ASeq x)])\n    clojure.core/interpose (All [x] (IFn [x (Option (Seqable x)) -> (ASeq x)]))\n    clojure.core/filter\n    (All [x y]\n         (IFn\n          [[x -> Any :filters {:then (is y 0)}] (Option (Seqable x)) -> (ASeq y)]\n          [[x -> Any :filters {:then (! y 0)}] (Option (Seqable x)) -> (ASeq (I x (Not y)))]\n          [[x -> Any] (Option (Seqable x)) -> (ASeq x)]))\n    clojure.core/remove\n    (All [x y]\n         (IFn\n          [[x -> Any :filters {:else (is y 0)}] (Option (Seqable x)) -> (ASeq y)]\n          [[x -> Any :filters {:else (! y 0)}] (Option (Seqable x)) -> (ASeq (I x (Not y)))]\n          [[x -> Any] (Option (Seqable x)) -> (ASeq x)]))\n    clojure.core/flatten [Any -> Any]\n    clojure.core/into\n    (All [x y]\n         (IFn [(Map x y) (U nil (Seqable (U nil (Seqable (IMapEntry x y)) (IMapEntry x y) '[x y]))) -> (Map x y)]\n              [(Vec x) (U nil (Seqable x)) -> (Vec x)]\n              [(Set x) (U nil (Seqable x)) -> (Set x)]\n              [(Coll Any) (U nil (Seqable Any)) -> (Coll Any)]))\n    clojure.core/mapv\n    (All [c a b ...]\n         (IFn [[a b ... b -> c] (NonEmptySeqable a) (NonEmptySeqable b) ... b -> (NonEmptyAVec c)]\n              [[a b ... b -> c] (U nil (Seqable a)) (U nil (Seqable b)) ... b -> (AVec c)]))\n    clojure.core/filterv\n    (All [x y]\n         (IFn\n          [[x -> Any :filters {:then (is y 0)}] (Option (Seqable x)) -> (AVec y)]\n          [[x -> Any] (Option (Seqable x)) -> (AVec x)]))\n    clojure.core/get-in\n    (IFn [Any (U nil (Seqable Any)) -> Any]\n         [Any (U nil (Seqable Any)) Any -> Any])\n    clojure.core/assoc-in\n    [(U nil (Associative Any Any)) (Seqable Any) Any -> Any]\n    clojure.core/vec (All [x] [(Option (Seqable x)) -> (AVec x)])\n    clojure.core/vector (All [r b ...]\n                             (IFn [b ... b -> '[b ... b]]\n                                  [r * -> (AVec r)]))\n    clojure.core/subvec (All [x]\n                             (IFn [(Vec x) AnyInteger -> (Vec x)]\n                                  [(Vec x) AnyInteger AnyInteger -> (Vec x)]))\n    clojure.core/keys\n    (All [k]\n         [(Map k Any) -> (ASeq k) :object {:id 0 :path [Keys]}])\n    clojure.core/key (All [x]\n                          [(IMapEntry x Any) -> x])\n    clojure.core/vals\n    (All [v]\n         [(Map Any v) -> (ASeq v) :object {:id 0 :path [Vals]}])\n    clojure.core/val (All [x]\n                          [(IMapEntry Any x) -> x])\n    clojure.core/merge\n    (All [k v]\n         (IFn [nil * -> nil]\n              [(IPersistentMap k v) (IPersistentMap k v) * -> (IPersistentMap k v)]\n              [(Option (IPersistentMap k v)) * -> (Option (IPersistentMap k v))]))\n    clojure.core/merge-with\n    (All [k v]\n         (IFn [[v v -> v] nil * -> nil]\n              [[v v -> v] (Map k v) * -> (Map k v)]\n              [[v v -> v] (Option (Map k v)) * -> (Option (Map k v))]))\n    clojure.core/select-keys (All [k v] [(Map k v) (U nil (Seqable Any))\n                                         -> (Map k v)])\n                                        ;clojure.core/set (All [x] [(Option (Seqable x)) -> (PersistentHashSet x)])\n                                        ;clojure.core/hash-set (All [x] [x * -> (PersistentHashSet x)])\n                                        ;clojure.core/sorted-set (All [x] [x * -> (PersistentTreeSet x)])\n                                        ;clojure.core/sorted-set-by (All [x] [[x x -> AnyInteger] x * -> (PersistentTreeSet x)])\n    clojure.core/distinct (All [x] [(U nil (Seqable x)) -> (ASeq x)])\n    clojure.core/butlast (All [x]\n                              [(Option (Seqable x)) -> (ASeq x)])\n                                        ;clojure.core/name [(U String Named) -> String]\n    clojure.core/zipmap\n    (All [k v]\n         [(U nil (Seqable k)) (U nil (Seqable v)) -> (APersistentMap k v)])\n    clojure.core/max-key (All [x]\n                              [[x -> Number] x x x * -> x])\n    clojure.core/min-key (All [x]\n                              [[x -> Number] x x x * -> x])\n    clojure.core/partition-all\n    (All [x]\n         (IFn [Int (Nilable (Seqable x)) -> (ASeq (ASeq x))]\n              [Int Int (Nilable (Seqable x)) -> (ASeq (ASeq x))]))\n    clojure.core/take-while\n    (All [x y]\n         (IFn\n          [[x -> Any :filters {:then (is y 0)}] (Option (Seqable x)) -> (ASeq y)]\n          [[x -> Any] (Option (Seqable x)) -> (ASeq x)]))\n    clojure.core/range\n    (IFn [-> (ASeq AnyInteger)]\n         [Number -> (ASeq AnyInteger)]\n         [AnyInteger Number -> (ASeq AnyInteger)]\n         [Number Number -> (ASeq Number)]\n         [AnyInteger Number AnyInteger -> (ASeq AnyInteger)]\n         [Number Number Number -> (ASeq Number)])\n    clojure.core/take-nth (All [x] [AnyInteger (U nil (Seqable x)) -> (ASeq x)])\n    clojure.core/split-with\n    (All [x y z]\n         (IFn\n          [[x -> Any :filters {:then (is y 0), :else (is z 0)}] (Option (Seqable x)) -> '[(ASeq y) (ASeq z)]]\n          [[x -> Any] (Option (Seqable x)) -> '[(ASeq x) (ASeq x)]]))\n    clojure.core/dorun (IFn [(U nil (Seqable Any)) -> nil]\n                            [AnyInteger (U nil (Seqable Any)) -> nil])\n    clojure.core/doall (All [[c :< (U nil (Seqable Any))]]\n                            (IFn [c -> c]\n                                 [AnyInteger c -> c]))\n    clojure.core/newline [-> nil]\n    clojure.core/prn-str [Any * -> String]\n    clojure.core/pr-str [Any * -> String]\n    clojure.core/pr [Any * -> nil]\n    clojure.core/print [Any * -> nil]\n    clojure.core/println [Any * -> nil]\n    clojure.core/print-str [Any * -> String]\n    clojure.core/println-str [Any * -> String]\n    clojure.core/prn [Any * -> nil]\n    clojure.core/atom\n    (All [x]\n         [x & :optional {:validator (U nil [x -> Any]) :meta Any} -> (Atom2 x x)])\n    clojure.core/reset! (All [w r]\n                             [(Atom2 w r) w -> w])\n                                        ;clojure.core/deref\n    #_(All [x y]\n           (IFn\n            [(Deref x) -> x]\n            [(U (Deref Any) java.util.concurrent.Future) -> Any]\n            [(BlockingDeref x) AnyInteger y -> (U x y)]\n            [(U java.util.concurrent.Future (BlockingDeref Any)) AnyInteger Any -> Any]))\n    clojure.core/swap! (All [w r b ...]\n                            [(Atom2 w r) [r b ... b -> w] b ... b -> w])\n    clojure.core/compare-and-set!\n    (All [w]\n         [(Atom2 w Any) Any w -> Boolean])\n\n                                        ;clojure.core/set-validator!\n    #_(All [w]\n           [(clojure.lang.IRef w Any) (U nil [w -> Any]) -> Any])\n                                        ;clojure.core/get-validator\n    #_(All [w]\n           [(clojure.lang.IRef w Any) -> (U nil [w -> Any])])\n                                        ;clojure.core/alter-meta!\n    #_(All [b ...]\n           [clojure.lang.IReference [(U nil (Map Any Any)) b ... b -> (U nil (Map Any Any))] b ... b -> (U nil (Map Any Any))])\n                                        ;clojure.core/reset-meta! [clojure.lang.IReference (U nil (Map Any Any)) -> (U nil (Map Any Any))]\n                                        ;clojure.core/add-watch\n    #_(All [x [a :< (IRef Nothing x)]]\n           (IFn\n            ;; this arity remembers the type of reference we pass to the function\n            [a Any [Any a x x -> Any] -> Any]\n            ;; if the above cannot be inferred,\n            [(IRef Nothing x) Any [Any (IRef Nothing x) x x -> Any] -> Any]))\n                                        ;clojure.core/remove-watch [(IRef Nothing Any) Any -> Any]\n    clojure.core/gensym (IFn [-> Symbol]\n                             [(U Symbol String) -> Symbol])\n    clojure.core/delay? (Pred (Delay Any))\n    clojure.core/force (All [x]\n                            (IFn [(Delay x) -> x]\n                                 [Any -> Any]))\n    ;clojure.core/realized? [clojure.lang.IPending -> Boolean]\n    clojure.core/memoize (All [x y ...]\n                              [[y ... y -> x] -> [y ... y -> x]])\n    clojure.core/trampoline\n    (All [r b ...]\n         [[b ... b -> (Rec [f] (U r [-> (U f r)]))]\n          b ... b -> r])\n                                        ;clojure.core/make-hierarchy [-> Hierarchy]\n    clojure.core/isa? (IFn [Any Any -> Boolean]\n                                        ;[Hierarchy Any Any -> Boolean]\n                           )\n                                        ;clojure.core/derive\n    #_(IFn [(U Symbol Keyword Class) (U Symbol Keyword) -> nil]\n                                        ;[Hierarchy (U Symbol Keyword Class) (U Symbol Keyword) -> Hierarchy]\n           )\n                                        ;clojure.core/prefer-method [Multi Any Any -> Any]\n                                        ;clojure.core/methods [Multi -> (Map Any Any)]\n                                        ;clojure.core/ex-info\n    #_(IFn [(U nil String) (Map Any Any) -> ExInfo]\n           [(U nil String) (Map Any Any) (U nil Throwable) -> ExInfo])\n                                        ;clojure.core/ex-data\n    #_(IFn [ExInfo -> (Map Any Any)]\n           [Any -> (U nil (Map Any Any))])\n    clojure.core/special-symbol? [Any -> Boolean]\n\n\n\n    ;;;;;;;; add-hook annotations just to improve coverage. correctness isn't assured\n    clojure.core/reductions (All [a b] (IFn [[a b -> a] (Seqable b) -> (ASeq a)]\n                                            [[a b -> a] a (Seqable b) -> (ASeq a)]))\n    clojure.core/reduced? [Any -> Boolean]\n    clojure.core/sequence (All [a] (IFn [(Seqable a) -> (ASeq a)]\n                                        [Any -> (EmptySeqable a)]))\n    clojure.core/dec [Number -> Number]\n    clojure.core/inc [Number -> Number]\n    clojure.core/set (All [a] [(Coll a) -> (Set a)])\n    clojure.core/nfirst (All [a b c] [(Seqable (Seqable a)) -> (ASeq a)])\n    clojure.core/group-by (All [x y] [[x -> y] (U nil (Seqable x)) -> (Map y (Vec x))])\n    clojure.core/keep (All [a b] [[a -> (Option b)] (Coll a) -> (Option (ASeq b))])\n    clojure.core/seqable? [Any -> Boolean]\n    clojure.core/sort-by (All [a] (IFn [(Coll a) -> (ASeq a)]\n                                       [[a -> Number] (Coll a) -> (ASeq a)]))\n    clojure.core/replicate (All [a] [Number a -> (ASeq a)])\n    clojure.core/quot [Number Number -> Number]\n    clojure.core/partition (All [a] (IFn [Number (Coll a) -> (ASeq (ASeq a))]\n                                         [Number Number (Coll a) -> (ASeq (ASeq a))]\n                                         [Number Number Number (Coll a) -> (ASeq (ASeq a))]))\n    clojure.core/name [(U Keyword String Symbol) -> String]\n    ;todo clojure.core/replace\n    clojure.core/fnext (All [a] [(Seqable a) -> a])\n    clojure.core/rem [Number Number -> Number]\")", :ns "clojure.core.typed.base-env-common", :name "common-ann*", :file "clojure/core/typed/base_env_common.clj", :column 1, :line 52}
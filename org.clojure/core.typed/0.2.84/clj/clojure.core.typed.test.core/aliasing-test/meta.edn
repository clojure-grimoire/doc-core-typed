{:type :fn, :src "(deftest aliasing-test\n  (is-tc-e\n    (let* [map__64934 {} \n           map__64934 (if (clojure.core/seq? map__64934) \n                        (clojure.lang.PersistentHashMap/create (clojure.core/seq map__64934)) \n                        map__64934)\n           b (clojure.core/get map__64934 :b)] \n      (ann-form b (U nil Number))))\n  (is-tc-err\n    (let [{:keys [b]} {}] (ann-form b Number)))\n  (is-tc-e\n    (let [m {}\n          b (or (:b m) 3)]\n      (ann-form b Number)))\n  (is-tc-e\n    (let [m {}\n          b (get m :b 3)]\n      (ann-form b Number)))\n  (is-tc-e\n    (let [m {}\n          b (if (print-filterset \"a\" (:b m)) (:b m) 3)]\n      (ann-form b Number)))\n  (is-tc-e\n    (do\n      (ann-record FooRec [a :- Number])\n      (defrecord FooRec [a])\n      (let [{:keys [a]} (->FooRec 1)]\n        (ann-form a Number))))\n  (is-tc-e\n    (do\n      (ann-record FooRec [a :- Number])\n      (defrecord FooRec [a])\n      (:a (->FooRec 1))))\n  ;FIXME weird error?\n  #_(is-tc-e\n    (do\n      (ann-record FooRec [a :- Number])\n      (defrecord FooRec [a])\n      (:a (:a (->FooRec 1)))))\n  ; used to take infinite time\n  (is-tc-e\n    (let [{:keys [a b c d e f g h] :as props}\n          (ann-form {} '{})]\n      (when-not (and a b c d e f g h)\n        #_(print-env \"\")\n        props)))\n  (testing \"simultaneous local updates\"\n    (is-tc-e\n      (let [old :- (U nil Num) 1\n            new old]\n        (when (number? new)\n          (+ old new))))\n    (is-tc-e\n      (let [old :- (U nil Num) 1\n            new old]\n        (when (number? old)\n          (+ old new))))\n    (is-tc-e\n      (let [{lkup :a} :- '{:a (U nil Num)} {:a 1}\n            alias lkup]\n        (when (number? lkup)\n          (inc alias))))\n    (is-tc-e\n      (let [{lkup :a :as old} :- '{:a (U nil Num)} {:a 1}\n            alias lkup]\n        (when (number? (:a old))\n          (inc lkup))))\n    (is-tc-e\n      (let [{lkup :a :as old} :- '{:a (U nil Num)} {:a 1}\n            alias lkup]\n        (when (number? (:a old))\n          (inc (:a old)))))\n    (is-tc-e\n      (let [{lkup :a :as old} :- '{:a (U nil Num)} {:a 1}\n            alias lkup]\n        (when (number? (:a old))\n          (inc alias))))\n    (is-tc-e\n      (let [{lkup :a :as old} :- '{:a (U nil Num)} {:a 1}\n            alias lkup]\n        (when (number? alias)\n          (inc (:a old)))))\n    (is-tc-e\n      (let [{lkup :a :as old} :- '{:a (U nil Num)} {:a 1}\n            alias lkup]\n        (when (number? alias)\n          (inc lkup))))\n    (is-tc-e\n      (let [{lkup :a :as old} :- '{:a (U nil Num)} {:a 1}\n            alias lkup]\n        (when (number? lkup)\n          (inc alias))))\n    (is-tc-e\n      (let [{lkup :a :as old} :- '{:a (U nil Num)} {:a 1}\n            alias lkup]\n        (when (number? lkup)\n          (inc (:a old)))))\n    (is-tc-e\n      (do\n        (ann parent ['{:file (U nil java.io.File)} -> (U nil Str)])\n        (defn parent [m]\n          (let [^java.io.File file (:file m)]\n            (when (instance? java.io.File (:file m))\n              (.getParent file))))))\n    (is-tc-e\n      (defn parent [m :- '{:str (U nil Str)}]\n        (when (:str m)\n          (ann-form (:str m) Str))))\n    (is-tc-e\n      (do\n        (ann parent ['{:file (U nil java.io.File)} -> (U nil Str)])\n        (defn parent [m]\n          (let [^java.io.File file (:file m)]\n            (when (:file m)\n              (.getParent file))))))\n    (is-tc-e\n      (fn [{:keys [a]} :- (HMap :mandatory {:a Num}\n                                :absent-keys #{:b})]\n        (when a\n          (inc a))))\n    (is-tc-e\n      (fn [{:keys [a] :as m} :- (HMap :optional {:a Num})]\n        (when (print-filterset \"a\" a)\n          (inc a))))\n    (is-tc-e\n      (fn [{:keys [a] :as m} :- (U (HMap :mandatory {:a Num})\n                                   (HMap :absent-keys #{:a}))]\n        (when (print-filterset \"a\" a)\n          (inc a))))\n    (is-tc-e\n      (fn [{:keys [a b]} :- (U (HMap :mandatory {:a Num}\n                                     :complete? true)\n                               (HMap :mandatory {:b Num}\n                                     :complete? true))]\n        (when (and a b)\n          (+ a b))))\n    (is-tc-e\n      (fn [{:keys [a b]} :- (U (HMap :mandatory {:a Num}\n                                     :absent-keys #{:b})\n                               (HMap :mandatory {:b Num}\n                                     :absent-keys #{:a}))]\n        (when (and a b)\n          (+ a b))))))", :ns "clojure.core.typed.test.core", :name "aliasing-test", :file "clojure/core/typed/test/core.clj", :column 1, :line 4521, :test #<core$fn__37162 clojure.core.typed.test.core$fn__37162@128b39c7>}
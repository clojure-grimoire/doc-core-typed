{:type :fn, :src "(deftest filter-expected-test\n  (testing \"integers are truthy\"\n    (is-tc-e 1\n             :expected-ret (ret (parse-clj `Num)\n                                (-FS -top -bot)\n                                -empty))\n    (is-tc-err 1 \n               :expected-ret (ret (parse-clj `Num)\n                                  (-FS -bot -top)\n                                  -empty))\n    (is-tc-err 1 \n               :expected-ret (ret (parse-clj 'Num)\n                                  (-FS -bot -bot)\n                                  -empty))\n    (testing \"checks object\"\n      (is-tc-err 1 \n                 :expected-ret (ret (parse-clj `Num)\n                                    (-FS -top -top)\n                                    (-path nil 'a))))\n    (is-tc-err 1\n               :expected-ret (ret (parse-clj `Sym)))\n    (is (= (ret (parse-clj `Num)\n                (-true-filter))\n           (tc-e 1\n                 :expected-ret\n                 (ret (parse-clj `Num)\n                      (-true-filter)\n                      -no-object)))))\n  (testing \"nil is falsy\"\n    (is-tc-e nil\n             :expected-ret (ret -nil\n                                (-FS -bot -top)\n                                -empty))\n    (is-tc-err nil\n               :expected-ret (ret -nil\n                                  (-FS -top -bot)\n                                  -empty)))\n  (testing \"false is falsy\"\n    (is-tc-e false\n             :expected-ret (ret -false\n                                (-FS -bot -top)))\n    (is-tc-e false\n             :expected-ret (ret -false\n                                (-FS -bot -top)))\n    (is-tc-err false\n             :expected-ret (ret -false\n                                (-FS -top -bot))))\n  (testing \"conditionals\"\n    (is-tc-e (if 1 2 3) Num)\n    (is-tc-err (if 1 2 3) Sym)\n    ;TODO\n    #_(is-tc-e (if 1 2 3) \n             :expected-ret (ret (parse-clj `Num)\n                                (-FS -top -bot)))\n    (is-tc-err (if 1 2 3) \n               :expected-ret (ret (parse-clj `Num)\n                                  (-FS -bot -top))))\n  (testing \"functions are truthy\"\n    (is-tc-e (fn [])\n             :expected-ret (ret -any\n                                (-true-filter)))\n    (is-tc-err (fn [])\n             :expected-ret (ret -any\n                                (-false-filter)))\n    ;TODO\n    #_(is-tc-e (core/fn [])\n             :expected-ret (ret -any\n                                (-false-filter))))\n  (testing \"quote\"\n    (is-tc-e 'a \n             :expected-ret\n             (ret (parse-clj `Sym)\n                  (-true-filter)))\n    (is-tc-err 'a \n             :expected-ret\n             (ret (parse-clj `Sym)\n                  (-false-filter)))\n    (is-tc-err 'a \n             :expected-ret\n             (ret (parse-clj `Sym)\n                  (-true-filter)\n                  (-path nil 'a)))\n    (is-tc-e ''a \n             :expected-ret\n             (ret (parse-clj `(Coll Sym))\n                  (-true-filter)\n                  ))\n    (is-tc-e '''a \n             :expected-ret\n             (ret (parse-clj `(Coll (U Sym (Coll Sym))))\n                  (-true-filter)))\n    )\n  (testing \"do\"\n    (is-tc-e (do 1 2)\n             :expected-ret\n             (ret (parse-clj `Num)\n                  (-true-filter)))\n    (is-tc-err (do 1 2)\n             :expected-ret\n             (ret (parse-clj `Num)\n                  (-false-filter))))\n  (testing \"let\"\n    (is-tc-e (let [] 1)\n             :expected-ret\n             (ret (parse-clj `Num)\n                  (-true-filter)))\n    (is-tc-err (let [] 1)\n             :expected-ret\n             (ret (parse-clj `Num)\n                  (-false-filter)))\n    (is-tc-err (let [] 1)\n             :expected-ret\n             (ret (parse-clj `Num)\n                  (-true-filter)\n                  (-path nil 'a))))\n  (testing \"map values\"\n    (is-tc-e {:a 1}\n             :expected-ret\n             (ret (parse-clj `'{:a Num})\n                  (-true-filter)))\n    (is-tc-err {:a 1}\n             :expected-ret\n             (ret (parse-clj `'{:a Num})\n                  (-false-filter)))\n    (is-tc-err {:a 1}\n             :expected-ret\n             (ret (parse-clj `'{:a Num})\n                  (-true-filter)\n                  (-path nil 'a)))\n    )\n  (testing \"map expressions\"\n    (is-tc-e (let [a 1] {:a a})\n             :expected-ret\n             (ret (parse-clj `'{:a Num})\n                  (-true-filter)))\n    (is-tc-err (let [a 1] {:a a})\n             :expected-ret\n             (ret (parse-clj `'{:a Num})\n                  (-false-filter)))\n    (is-tc-err (let [a 1] {:a a})\n             :expected-ret\n             (ret (parse-clj `'{:a Num})\n                  (-true-filter)\n                  (-path nil 'a)))\n    (is-tc-err (let [a 1] {:a a})\n             :expected-ret\n             (ret (parse-clj `'{:a Num})\n                  (-true-filter)\n                  -empty\n                  (-flow -bot)))\n    )\n  (testing \"set values\"\n    (is-tc-e #{1})\n    (is-tc-e #{1} (Set Num))\n    (is-tc-err #{1} \n               (Set Sym))\n    (is-tc-e #{1} \n               :expected-ret\n               (ret (parse-clj `(Set Num))\n                    (-true-filter)))\n    (is-tc-err #{1} \n               :expected-ret\n               (ret (parse-clj `(Set Num))\n                    (-false-filter)))\n    (is-tc-err #{1} \n               :expected-ret\n               (ret (parse-clj `(Set Num))\n                    (-true-filter)\n                    (-path nil 'a)))\n    (is-tc-err #{1} \n               :expected-ret\n               (ret (parse-clj `(Set Num))\n                    (-true-filter)\n                    -empty\n                    (-flow -bot)))\n    )\n  (testing \"set expression\"\n    (is-tc-e (let [a 1]\n                 #{a}))\n    (is-tc-e (let [a 1]\n                 #{a}) (Set Num))\n    (is-tc-err (let [a 1]\n                 #{a})\n               (Set Sym))\n    (is-tc-e (let [a 1]\n                 #{a})\n               :expected-ret\n               (ret (parse-clj `(Set Num))\n                    (-true-filter)))\n    (is-tc-err (let [a 1]\n                 #{a})\n               :expected-ret\n               (ret (parse-clj `(Set Num))\n                    (-false-filter)))\n    (is-tc-err (let [a 1]\n                 #{a})\n               :expected-ret\n               (ret (parse-clj `(Set Num))\n                    (-true-filter)\n                    (-path nil 'a)))\n    (is-tc-err (let [a 1]\n                 #{a})\n               :expected-ret\n               (ret (parse-clj `(Set Num))\n                    (-true-filter)\n                    -empty\n                    (-flow -bot)))\n    )\n  (testing \"vector values\"\n    (is-tc-e [1])\n    (is-tc-e [1] (Vec Num))\n    (is-tc-err [1]\n               (Vec Sym))\n    (is-tc-e [1]\n               :expected-ret\n               (ret (parse-clj `(Vec Num))\n                    (-true-filter)))\n    (is-tc-err [1]\n               :expected-ret\n               (ret (parse-clj `(Vec Num))\n                    (-false-filter)))\n    (is-tc-err [1]\n               :expected-ret\n               (ret (parse-clj `(Vec Num))\n                    (-true-filter)\n                    (-path nil 'a)))\n    (is-tc-err [1]\n               :expected-ret\n               (ret (parse-clj `(Vec Num))\n                    (-true-filter)\n                    -empty\n                    (-flow -bot)))\n    )\n  (testing \"vector expressions\"\n    (is-tc-e (let [a 1]\n               [a]))\n    (is-tc-e (let [a 1]\n               [a]) (Vec Num))\n    (is-tc-err (let [a 1]\n                 [a])\n               (Vec Sym))\n    (is-tc-e (let [a 1]\n               [a])\n             :expected-ret\n             (ret (parse-clj `(Vec Num))\n                  (-true-filter)))\n    (is-tc-err (let [a 1]\n                 [a])\n               :expected-ret\n               (ret (parse-clj `(Vec Num))\n                    (-false-filter)))\n    (is-tc-err (let [a 1]\n                 [a])\n               :expected-ret\n               (ret (parse-clj `(Vec Num))\n                    (-true-filter)\n                    (-path nil 'a)))\n    (is-tc-err (let [a 1]\n                 [a])\n               :expected-ret\n               (ret (parse-clj `(Vec Num))\n                    (-true-filter)\n                    -empty\n                    (-flow -bot)))\n    )\n  (testing \"ann-form\"\n    (is-tc-e (ann-form 1 Num)\n             :expected-ret\n             (ret (parse-clj `Num)\n                  (-true-filter)\n                  -empty))\n    (is-tc-err (ann-form 1 Num)\n             :expected-ret\n             (ret (parse-clj `Num)\n                  (-false-filter)\n                  -empty))\n    (is-tc-err (ann-form 1 Num)\n             :expected-ret\n             (ret (parse-clj `Num)\n                  (-true-filter)\n                  -empty\n                  (-flow -bot)))\n)\n  (testing \"loop\"\n    (is-tc-e (loop [a :- Num 1] a)\n             :expected-ret\n             (ret (parse-clj `Num)))\n    (is-tc-e (loop [a :- Num 1] a)\n             :expected-ret\n             (ret (parse-clj `Num)\n                  (-true-filter)\n                  ))\n    (is-tc-err (loop [a :- Num 1] a)\n             :expected-ret\n             (ret (parse-clj `Num)\n                  (-false-filter)\n                  ))\n    ;TODO better gensyms?\n    #_(is-tc-err (loop [a :- Num 1] a)\n             :expected-ret\n             (ret (parse-clj `Num)\n                  (-FS -top -top)\n                  (-path nil 'a__#0)))\n    )\n  (testing \"application\"\n    (is-tc-e ((fn []))\n             :expected-ret\n             (ret (parse-clj 'nil)))\n    (is-tc-err ((fn []))\n             :expected-ret\n             (ret (parse-clj 'nil)\n                  (-true-filter)))\n    (is-tc-e ((fn []))\n             :expected-ret\n             (ret (parse-clj 'nil)\n                  (-false-filter)))\n    (is-tc-err ((fn []))\n             :expected-ret\n             (ret (parse-clj 'nil)\n                  (-false-filter)\n                  (-path nil 'a)))\n    )\n\n  (testing \"instance method\"\n    (is-tc-e (.getParent (java.io.File. \"a\"))\n             :expected-ret\n             (ret (parse-clj `(U nil Str))))\n    (is-tc-err (.getParent (java.io.File. \"a\"))\n             :expected-ret\n             (ret (parse-clj `(U nil Str))\n                  (-true-filter)))\n    (is-tc-err (.getParent (java.io.File. \"a\"))\n             :expected-ret\n             (ret (parse-clj `(U nil Str))\n                  (-false-filter)))\n    (is-tc-err (.getParent (java.io.File. \"a\"))\n             :expected-ret\n             (ret (parse-clj `(U nil Str))\n                  (-FS -top -top)\n                  (-path nil 'a)))\n    )\n  (testing \"static fields\"\n    (is-tc-e Long/SIZE\n             :expected-ret\n             (ret (parse-clj `Num)))\n    (is-tc-err Long/SIZE\n             :expected-ret\n             (ret (parse-clj `Sym)))\n    (is-tc-err Long/SIZE\n             :expected-ret\n             (ret (parse-clj `Num)\n                  (-false-filter)))\n    (is-tc-err Long/SIZE\n             :expected-ret\n             (ret (parse-clj `Num)\n                  (-true-filter)))\n    (is-tc-err Long/SIZE\n             :expected-ret\n             (ret (parse-clj `Num)\n                  (-FS -top -top)\n                  (-path nil 'a)))\n    )\n  (testing \"instance fields\"\n    (is-tc-e (do (ann-datatype A [a :- Num])\n                 (deftype A [a])\n                 (.a (A. 1)))\n             :expected-ret\n             (ret (parse-clj `Num)))\n    (is-tc-err (do (ann-datatype A [a :- Num])\n                 (deftype A [a])\n                 (.a (A. 1)))\n             :expected-ret\n             (ret (parse-clj `Num)\n                  (-true-filter)))\n    (is-tc-err (do (ann-datatype A [a :- Num])\n                 (deftype A [a])\n                 (.a (A. 1)))\n             :expected-ret\n             (ret (parse-clj `Num)\n                  (-false-filter)))\n    (is-tc-err (do (ann-datatype A [a :- Num])\n                 (deftype A [a])\n                 (.a (A. 1)))\n             :expected-ret\n             (ret (parse-clj `Num)\n                  (-FS -top -top)\n                  (-path nil 'a)))\n    )\n  (testing \"static methods\"\n    (is-tc-e (Long/valueOf 1)\n             :expected-ret\n             (ret (parse-clj `(U nil Num))))\n    (is-tc-err (Long/valueOf 1)\n             :expected-ret\n             (ret (parse-clj `(U nil Num))\n                  (-true-filter)))\n    (is-tc-err (Long/valueOf 1)\n             :expected-ret\n             (ret (parse-clj `(U nil Num))\n                  (-false-filter)))\n    (is-tc-err (Long/valueOf 1)\n             :expected-ret\n             (ret (parse-clj `(U nil Num))\n                  (-FS -top -top)\n                  (-path nil 'a)))\n    )\n  (testing \"instance? call\"\n    (is-tc-e (instance? Long 1)\n             Boolean)\n    ;TODO scoping\n    #_(is-tc-err (let [a 1]\n                 (instance? Long a))\n               :expected-ret\n               (ret (parse-clj `Boolean)\n                    (-FS (-filter (parse-clj `Long)\n                                  'a__#0)\n                         (-not-filter (parse-clj `Long)\n                                  'a__#0))))\n    (is-tc-e (fn [a] (instance? Long a))\n             (Pred Long))\n    )\n  (testing \"multifn\"\n    ;FIXME\n    #_(is-tc-e (clojure.lang.MultiFn. 'foo\n                                    class\n                                    :default\n                                    #'clojure.core/global-hierarchy)\n             :expected-ret\n             (ret (parse-clj `[Any :-> Any]))\n             ))\n  (testing \"new\"\n    (is-tc-e (Boolean. true)\n             Boolean)\n    (is-tc-e (Boolean. true)\n             :expected-ret\n             (ret (parse-clj `Boolean)\n                  (-true-filter)))\n    (is-tc-err (Boolean. true)\n             :expected-ret\n             (ret (parse-clj `Boolean)\n                  (-false-filter)))\n    (is-tc-err (Boolean. true)\n             :expected-ret\n             (ret (parse-clj `Boolean)\n                  (-true-filter)\n                  (-path nil 'a)))\n    )\n  (testing \"throw\"\n    (is-tc-e (fn [a :- Throwable] :- Nothing\n               (throw a)))\n    (is-tc-err (fn [a :- Any]\n                 (throw a)))\n    (is-tc-e (fn [a]\n               (throw a))\n             [Throwable -> Nothing\n              :filters {:then ff :else ff}])\n    (is-tc-e (fn [a]\n               (throw a))\n             [Throwable -> Nothing\n              :flow ff])\n    (is-tc-e (fn [a]\n               (throw a))\n             [Throwable -> Nothing\n              :filters {:then ff :else ff}\n              :flow ff])\n    (is-tc-err (fn [a]\n                 1)\n             [Throwable -> Any\n              :flow ff])\n    (is-tc-err (fn [a]\n                 1)\n             [Throwable -> Any\n              :filters {:then ff :else ff}])\n    (is-tc-err (fn [a]\n                 1)\n               [Throwable -> Any\n                :filters {:then ff :else ff}\n                :flow ff])\n    (is-tc-e (core/fn [a]\n               (throw a))\n             [Throwable -> Nothing\n              :filters {:then ff :else ff}\n              :flow ff])\n    (is-tc-e (fn [a :- Throwable]\n               (throw a))\n             [Throwable -> Nothing\n              :filters {:then ff :else ff}\n              :flow ff])\n    (is-tc-err (core/fn [a]\n                 1)\n             [Throwable -> Any\n              :flow ff])\n    (is-tc-err (core/fn [a]\n                 1)\n             [Throwable -> Any\n              :filters {:then ff :else ff}])\n    (is-tc-err (core/fn [a]\n                 1)\n               [Throwable -> Any\n                :filters {:then ff :else ff}\n                :flow ff]))\n  (testing \"try catch\"\n    (is-tc-e (try (throw (Exception.))\n                  (catch Exception e))\n             nil)\n    (is-tc-err (try (throw (Exception.))\n                  (catch Exception e))\n             Num)\n    (is-tc-e (try (throw (Exception.))\n                  (catch Exception e\n                    2))\n             Num)\n    (is-tc-e (try (throw (Exception.))\n                  (catch Exception e))\n             :expected-ret\n             (ret -nil\n                  (-false-filter)))\n    (is-tc-err (try (throw (Exception.))\n                  (catch Exception e))\n             :expected-ret\n             (ret -nil\n                  (-true-filter)))\n    (is-tc-err (try (throw (Exception.))\n                  (catch Exception e))\n             :expected-ret\n             (ret -nil\n                  (-FS -top -top)\n                  -empty\n                  (-flow -bot))))\n  (testing \"finally\"\n    (is-tc-e (try (throw (Exception.))\n                  (catch Exception e\n                    2)\n                  (finally nil))\n             Num)\n    (is-tc-err (try (throw (Exception.))\n                  (catch Exception e\n                    2)\n                  (finally nil))\n             nil)\n    (is-tc-e (try (throw (Exception.))\n                  (catch Exception e\n                    2)\n                  (finally nil))\n             :expected-ret\n             (ret (parse-clj `Num)\n                  (-true-filter)))\n    (is-tc-err (try (throw (Exception.))\n                  (catch Exception e\n                    2)\n                  (finally nil))\n             :expected-ret\n             (ret (parse-clj `Num)\n                  (-false-filter))))\n  (testing \"var\"\n    (is-tc-e (do (t/def foo :- Num 1)\n                 foo))\n    (is-tc-e (do (t/def foo :- Num 1)\n                 foo)\n             Num)\n    (is-tc-err (do (t/def foo :- Num 1)\n                 foo)\n             nil))\n  (testing \"set!\"\n    (is-tc-e (do (t/def ^:dynamic *foo* :- Number 1)\n                 (binding [*foo* 1]\n                   (set! *foo* 2))))\n    (is-tc-err (do (t/def ^:dynamic *foo* :- Number 1)\n                   (binding [*foo* 1]\n                     (set! *foo* nil))))\n    (is-tc-e (do (t/def ^:dynamic *foo* :- Number 1)\n                   (binding [*foo* 1]\n                     (set! *foo* 2)))\n             Num)\n    (is-tc-err (do (t/def ^:dynamic *foo* :- Number 1)\n                   (binding [*foo* 1]\n                     (set! *foo* 2)))\n             nil))\n  (testing \"the var\"\n    (is-tc-e (do (t/def foo :- Num 1)\n                 #'foo))\n    (is-tc-e (do (t/def foo :- Num 1)\n                 #'foo)\n             :expected-ret\n             (ret (parse-clj `(Var1 Num))))\n    (is-tc-e (do (t/def foo :- Num 1)\n                 #'foo)\n             :expected-ret\n             (ret (parse-clj `(Var1 Num))\n                  (-true-filter)))\n    (is-tc-err (do (t/def foo :- Num 1)\n                 #'foo)\n             :expected-ret\n             (ret (parse-clj `(Var1 Num))\n                  (-false-filter)))\n    (is-tc-err (do (t/def foo :- Num 1)\n                 #'foo)\n             :expected-ret\n             (ret (parse-clj `(Var1 Num))\n                  (-true-filter)\n                  (-path nil 'a)))\n    (is-tc-err (do (t/def foo :- Num 1)\n                 #'foo)\n             :expected-ret\n             (ret (parse-clj `(Var1 Num))\n                  (-true-filter)\n                  -empty\n                  (-flow -bot)))\n    )\n  (testing \"cast\"\n    (is-tc-e (cast Number 1))\n    (is-tc-e (cast Number 1)\n             Num)\n    (is-tc-err (cast Number 1)\n             :expected-ret\n             (ret (parse-clj `Num)\n                  (-true-filter)))\n    (is-tc-err (cast Number 1)\n             :expected-ret\n             (ret (parse-clj `Num)\n                  (-false-filter)))\n    (is-tc-err (cast Number 1)\n             :expected-ret\n             (ret (parse-clj `Num)\n                  (-FS -top -top)\n                  (-path nil 'a)))\n    (is-tc-err (cast Number 1)\n             :expected-ret\n             (ret (parse-clj `Num)\n                  (-FS -top -top)\n                  -empty\n                  (-flow -bot)))\n    (is-tc-err (do (cast Number 1))\n             :expected-ret\n             (ret (parse-clj `Num)\n                  (-FS -top -top)\n                  -empty\n                  (-flow -bot)))\n    )\n  (testing \"tc-ignore\"\n    (is-tc-e (tc-ignore 1)\n             Any)\n    (is-tc-err (tc-ignore 1)\n             Num)\n    (is-tc-err (tc-ignore 1)\n               :expected-ret\n               (ret (parse-clj `Any)\n                    (-true-filter)))\n    (is-tc-err (tc-ignore 1)\n               :expected-ret\n               (ret (parse-clj `Any)\n                    (-false-filter)))\n    (is-tc-err (tc-ignore 1)\n               :expected-ret\n               (ret (parse-clj `Any)\n                    (-FS -top -top)\n                    (-path nil 'a)))\n    (is-tc-err (tc-ignore 1)\n               :expected-ret\n               (ret (parse-clj `Any)\n                    (-FS -top -top)\n                    -empty\n                    (-flow -bot)))\n    )\n  (testing \"local\"\n    (is-tc-e (let [a 1]\n               a))\n    (is-tc-e (let [a 1]\n               a)\n             Num)\n    (is-tc-err (let [a 1]\n               a)\n             Sym)\n    (is-tc-e (let [a 1]\n               a)\n             :expected-ret\n             (ret (parse-clj `Any)\n                  (-true-filter)))\n    (is-tc-err (let [a 1]\n                 a)\n               :expected-ret\n               (ret (parse-clj `Any)\n                    (-false-filter)\n                    ))\n    (is-tc-err (let [a 1]\n                 a)\n               :expected-ret\n               (ret (parse-clj `Any)\n                    (-FS -top -top)\n                    (-path nil 'a)))\n    (is-tc-err (let [a 1]\n                 a)\n               :expected-ret\n               (ret (parse-clj `Any)\n                    (-FS -top -top)\n                    -empty\n                    (-flow -bot))))\n  (testing \"monitor-enter\"\n    (is-tc-e #(monitor-enter 1))\n    (is-tc-err #(monitor-enter nil))\n    (is-tc-e #(monitor-enter 1)\n             [-> nil :filters {:then ff :else tt}])\n    (is-tc-err #(monitor-enter 1)\n               [-> nil :filters {:then tt :else ff}])\n    (is-tc-err #(monitor-enter 1)\n               [-> nil :filters {:then ff :else tt} :flow ff])\n    (is-tc-err (fn [a] (monitor-enter 1))\n               [Any -> nil :filters {:then ff :else tt} :object {:id 0}]))\n  (testing \"monitor-exit\"\n    (is-tc-e #(monitor-exit 1))\n    (is-tc-err #(monitor-exit nil))\n    (is-tc-e #(monitor-exit 1)\n             [-> nil :filters {:then ff :else tt}])\n    (is-tc-err #(monitor-exit 1)\n               [-> nil :filters {:then tt :else ff}])\n    (is-tc-err #(monitor-exit 1)\n               [-> nil :filters {:then ff :else tt} :flow ff])\n    (is-tc-err (fn [a] (monitor-exit 1))\n               [Any -> nil :filters {:then ff :else tt} :object {:id 0}]))\n)", :ns "clojure.core.typed.test.core", :name "filter-expected-test", :file "clojure/core/typed/test/core.clj", :column 1, :line 3608, :test #<core$fn__33377 clojure.core.typed.test.core$fn__33377@28e3899e>}
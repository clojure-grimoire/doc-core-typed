{:ns "clojure.core.typed.test.union", :name "Expr", :file "clojure/core/typed/test/union.clj", :type :var, :src "(t/defalias Expr\n  \"An AST node\"\n  (t/Rec [Expr]\n  (t/U ;; values\n     '{:op ':keyword\n       :env Env\n       :val t/Kw}\n     '{:op ':constant\n       :env Env\n       :val t/Any}\n     '{:op ':number\n       :env Env\n       :val Number}\n     '{:op ':string\n       :env Env\n       :val String}\n     '{:op ':nil\n       :env Env\n       :val nil}\n     '{:op ':boolean\n       :env Env\n       :val Boolean}\n     \n     ;; def\n     (t/HMap :mandatory\n           {:op ':def\n            :env Env\n            :var (t/Var2 t/Nothing t/Any)\n            :meta (t/U nil Expr)\n            :init Expr\n            :init-provided t/Any\n            :is-dynamic t/Any}\n           :optional\n           {:children Children\n            :Expr-obj Compiler$DefExpr})\n\n     ;; local binding\n     (t/HMap :mandatory\n           {:op ':local-binding\n            :env Env\n            :sym t/Sym\n            :tag (t/U nil t/Sym)\n            :init Expr}\n           :optional\n           {:children Children\n             :LocalBinding-obj Compiler$LocalBinding})\n\n     ;binding init\n     (t/HMap :mandatory\n           {:op ':binding-init\n            :env Env\n            :local-binding Expr\n            :init Expr}\n           :optional\n           {:children Children\n            :BindingInit-obj Compiler$BindingInit})\n\n     ; let\n     (t/HMap :mandatory\n           {:op ':let\n            :env Env\n            :binding-inits (t/Seqable Expr)\n            :body Expr\n            :is-loop t/Any}\n           :optional\n           {:children Children\n             :Expr-obj Compiler$LetExpr})\n\n     ;letfn\n     (t/HMap :mandatory\n           {:op ':letfn\n            :env Env\n            :body Expr\n            :binding-inits (t/Seqable Expr)}\n           :optional\n           {:children Children\n             :Expr-obj Compiler$LetFnExpr})\n\n     ;local binding expr\n     (t/HMap :mandatory\n           {:op ':local-binding-expr\n            :env Env\n            :local-binding Expr\n            :tag (t/U nil t/Sym)}\n           :optional\n           {:children Children\n             :Expr-obj Compiler$LocalBindingExpr})\n\n     ;static method\n     (t/HMap :mandatory\n           {:op ':static-method\n            :env Env\n            :class Class\n            :method-name t/Sym\n            ; probably need to type clojure.reflect\n            :method t/Nothing\n            :args (t/Seqable Expr)\n            :tag (t/U nil t/Sym)}\n           :optional\n           {:children Children\n             :Expr-obj Compiler$StaticMethodExpr})\n\n     ;instance method\n     (t/HMap :mandatory\n           {:op ':instance-method\n            :env Env\n            :target Expr\n            :method-name t/Sym\n            :method t/Nothing\n            :args (t/Seqable Expr)\n            :tag (t/U nil t/Sym)}\n           :optional\n           {:children Children\n             :Expr-obj Compiler$InstanceMethodExpr})\n\n    ;static field\n    (t/HMap :mandatory\n          {:op ':static-field\n           :env Env\n           :class Class\n           :field-name t/Sym\n           :field t/Nothing\n           :tag (t/U nil t/Sym)}\n          :optional\n          {:Expr-obj Compiler$StaticFieldExpr})\n\n    ;instance field\n    (t/HMap :mandatory\n          {:op ':instance-field\n           :env Env\n           :target Expr\n           :target-class Class\n           :field t/Nothing\n           :field-name t/Sym\n           :tag (t/U nil t/Sym)}\n          :optional\n          {:children Children\n           :Expr-obj Compiler$InstanceFieldExpr})\n\n    ;new\n    (t/HMap :mandatory\n          {:op ':new\n           :env Env\n           :ctor t/Nothing\n           :class Class\n           :args (t/Seqable Expr)}\n          :optional\n          {:children Children\n           :Expr-obj Compiler$NewExpr})\n\n    ;empty\n    (t/HMap :mandatory\n          {:op ':empty-expr\n           :env Env\n           :coll (t/I (t/Seqable t/Nothing) (t/ExactCount 0))}\n          :optional\n          {:Expr-obj Compiler$EmptyExpr})\n\n    ;set\n    (t/HMap :mandatory\n          {:op ':set\n           :env Env\n           :keys (t/Seqable Expr)}\n          :optional\n          {:children Children\n           :Expr-obj Compiler$SetExpr})\n\n    ;vector\n    (t/HMap :mandatory\n          {:op ':vector\n           :env Env\n           :args (t/Seqable Expr)}\n          :optional\n          {:children Children\n           :Expr-obj Compiler$VectorExpr})\n\n    ;map\n    (t/HMap :mandatory\n          {:op ':map\n           :env Env\n           :keyvals (t/Seqable Expr)}\n          :optional\n          {:children Children\n           :Expr-obj Compiler$MapExpr})\n\n    ;monitor enter\n    (t/HMap :mandatory\n          {:op ':monitor-enter\n           :env Env\n           :target Expr}\n          :optional\n          {:children Children\n           :Expr-obj Compiler$MonitorEnterExpr})\n\n    ;monitor exit\n    (t/HMap :mandatory\n          {:op ':monitor-exit\n           :env Env\n           :target Expr}\n          :optional\n          {:children Children\n           :Expr-obj Compiler$MonitorExitExpr})\n\n    ;throw\n    (t/HMap :mandatory\n          {:op ':throw\n           :env Env\n           :exception Expr}\n          :optional\n          {:children Children\n           :Expr-obj Compiler$ThrowExpr})\n\n    ;invoke\n    (t/HMap :mandatory\n          {:op ':invoke\n           :env Env\n           :fexpr Expr\n           :tag (t/U nil t/Sym)\n           :args (t/Seqable Expr)\n           :is-protocol t/Any\n           :is-direct t/Any\n           :site-index t/Any\n           :protocol-on t/Any}\n          :optional\n          {:method t/Nothing\n           :children Children\n           :Expr-obj Compiler$InvokeExpr})\n\n    ;keyword invoke\n    (t/HMap :mandatory\n          {:op ':keyword-invoke\n           :env Env\n           :kw Expr\n           :tag (t/U nil t/Sym)\n           :target Expr}\n          :optional\n          {:children Children\n           :Expr-obj Compiler$KeywordInvokeExpr})\n\n    ;the var\n    (t/HMap :mandatory\n          {:op ':the-var\n           :env Env\n           :var Var}\n          :optional\n          {:Expr-obj Compiler$TheVarExpr})\n\n    ;var\n    (t/HMap :mandatory\n          {:op ':var\n           :env Env\n           :var Var\n           :tag (t/U nil t/Sym)}\n          :optional\n          {:Expr-obj Compiler$VarExpr})\n\n    ;unresolved var\n    (t/HMap :mandatory\n          {:op ':unresolved-var\n           :env Env\n           :sym t/Sym}\n          :optional\n          {:Expr-obj Compiler$UnresolvedVarExpr})\n\n    ;objexpr\n    (t/HMap :mandatory\n          {:op ':obj-expr\n           :env Env\n           :tag (t/U nil t/Sym)}\n          :optional\n          {:Expr-obj Compiler$ObjExpr})\n\n    ;new instance method\n    (t/HMap :mandatory\n          {:op ':new-instance-method\n           :env Env\n           :name t/Sym\n           :required-params (t/Seqable Expr)\n           :body Expr}\n          :optional\n          {:children Children\n           :ObjMethod-obj Compiler$NewInstanceMethod})\n\n    ;fn method\n    (t/HMap :mandatory\n          {:op ':fn-method\n           :env Env\n           :body Expr\n           :required-params (t/Seqable Expr)\n           :rest-param (t/U nil Expr)}\n          :optional\n          {:children Children\n           :ObjMethod-obj Compiler$FnMethod})\n\n    ;fn expr\n    (t/HMap :mandatory\n          {:op ':fn-expr\n           :env Env\n           :methods (t/Seqable Expr)\n           :variadic-method (t/U nil Expr)\n           :tag (t/U nil t/Sym)}\n          :optional\n          {:name t/Sym\n           :children Children\n           :Expr-obj Compiler$FnExpr})\n\n    ;new instance expr\n    (t/HMap :mandatory\n          {:op ':deftype*\n           :name t/Sym\n           :env Env\n           :methods (t/Seqable Expr)\n           :mmap t/Any\n           :compiled-class Class\n           :internal-name t/Sym\n           :this-name t/Sym\n           :fields (t/Set Expr)\n           :covariants t/Any\n           :tag (t/U nil t/Sym)}\n          :optional\n          {:children Children\n           :Expr-obj Compiler$NewInstanceExpr})\n\n    ;instanceof\n    (t/HMap :mandatory\n          {:op ':instance-of\n           :env Env\n           :class Class\n           :the-expr Expr}\n          :optional\n          {:children Children\n           :Expr-obj Compiler$InstanceOfExpr})\n\n    ;meta\n    (t/HMap :mandatory\n          {:op ':meta\n           :env Env\n           :meta Expr\n           :expr Expr}\n          :optional\n          {:children Children\n           :Expr-obj Compiler$MetaExpr})\n\n    ;do\n    (t/HMap :mandatory\n          {:op ':do\n           :env Env\n           :exprs (t/Seqable Expr)}\n          :optional\n          {:children Children\n           :Expr-obj Compiler$BodyExpr})\n\n    ;if\n    (t/HMap :mandatory\n          {:op ':if\n           :env Env\n           :test Expr\n           :then Expr\n           :else Expr}\n          :optional\n          {:children Children\n           :Expr-obj Compiler$IfExpr})\n\n    ;case\n    (t/HMap :mandatory\n          {:op ':case*\n           :env Env\n           :the-expr Expr\n           :tests (t/Seqable Expr)\n           :thens (t/Seqable Expr)\n           :default Expr\n           :tests-hashes t/Any\n           :shift t/Any\n           :mask t/Any\n           :test-type t/Any\n           :switch-type t/Any\n           :skip-check t/Any}\n          :optional\n          {:children Children\n           :Expr-obj Compiler$CaseExpr})\n\n    ;import\n    (t/HMap :mandatory\n          {:op ':import*\n           :env Env\n           :class-str String}\n          :optional\n          {:Expr-obj Compiler$ImportExpr})\n\n    ;set!\n    (t/HMap :mandatory\n          {:op ':set!\n           :env Env\n           :target Expr\n           :val Expr}\n          :optional\n          {:children Children\n           :Expr-obj Compiler$AssignExpr})\n\n    ;catch\n    (t/HMap :mandatory\n          {:op ':catch\n           :env Env\n           :class Class\n           :local-binding Expr\n           :handler Expr}\n          :optional\n          {:children Children\n           :CatchClause-obj Compiler$TryExpr$CatchClause})\n\n    ;try\n    (t/HMap :mandatory\n          {:op ':try\n           :env Env\n           :try-expr Expr\n           :finally-expr (t/U nil Expr)\n           :catch-exprs (t/Seqable Expr)\n           :ret-local t/Any\n           :finally-local t/Any}\n          :optional\n          {:children Children\n           :Expr-obj Compiler$TryExpr})\n\n    ;recur\n    (t/HMap :mandatory\n          {:op ':recur\n           :env Env\n           :loop-locals (t/Seqable Expr)\n           :args (t/Seqable Expr)}\n          :optional\n          {:children Children\n           :Expr-Obj Compiler$RecurExpr})\n\n    ;method param\n    (t/HMap :mandatory\n          {:op ':method-param\n           :env Env\n           :class Class\n           :can-emit-primitive t/Any}\n          :optional\n          {:Expr-obj Compiler$MethodParamExpr}))))", :column 1, :line 32, :declared true, :doc "An AST node"}
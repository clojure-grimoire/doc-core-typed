{:type :fn, :src "(defn check-case-thens [check-fn target-ret tst-rets case-thens expected]\n  {:pre [(r/TCResult? target-ret)\n         (every? r/TCResult? tst-rets)\n         (== (count tst-rets)\n             (count case-thens))]\n   :post [((every-pred vector?\n                       (con/every-c? (comp #{:case-then} :op)))\n           %)]}\n  (letfn [(check-case-then [tst-ret {:keys [then] :as case-then}]\n            (let [{{fs+ :then} :fl :as rslt} (equiv/tc-equiv := [target-ret tst-ret] nil)\n                  flag+ (atom true)\n                  env-thn (update/env+ lex/*lexical-env* [fs+] flag+)\n                  _ (when-not @flag+\n                      ;; FIXME should we ignore this branch?\n                      (u/tc-warning \"Local became bottom when checking case then\"))\n                  cthen (var-env/with-lexical-env env-thn\n                          (check-fn then expected))]\n              (assoc case-then\n                     :then cthen\n                     u/expr-type (u/expr-type cthen))))]\n    (mapv check-case-then\n      tst-rets \n      case-thens)))", :ns "clojure.core.typed.check.case", :name "check-case-thens", :file "clojure/core/typed/check/case.clj", :column 1, :line 10, :arglists ([check-fn target-ret tst-rets case-thens expected])}
{:type :fn, :src "(defn check-do [check internal-special-form expr expected]\n  (u/enforce-do-folding expr spec/special-form)\n  (cond\n    (internal-form? expr)\n    (internal-special-form expr expected)\n\n    :else\n    (let [exprs (vec (concat (:statements expr) [(:ret expr)]))\n          nexprs (count exprs)\n          [env cexprs]\n          (reduce (fn [[env cexprs] [^long n expr]]\n                    {:pre [(lex/PropEnv? env)\n                           (integer? n)\n                           (< n nexprs)]\n                     ; :post checked after the reduce\n                     }\n                    (let [cexpr (binding [; always prefer envs with :line information, even if inaccurate\n                                          vs/*current-env* (if (:line (:env expr))\n                                                             (:env expr)\n                                                             vs/*current-env*)\n                                          vs/*current-expr* expr]\n                                  (var-env/with-lexical-env env\n                                    (check expr\n                                           ;propagate expected type only to final expression\n                                           (when (= (inc n) nexprs)\n                                             expected))))\n                          res (u/expr-type cexpr)\n                          flow (-> res r/ret-flow r/flow-normal)\n                          flow-atom (atom true)\n                          ;_ (prn flow)\n                          ;add normal flow filter\n                          nenv (if (fl/NoFilter? flow)\n                                 env\n                                 (update/env+ env [flow] flow-atom))\n                          ;_ (prn nenv)\n                          ]\n  ;                        _ (when-not @flow-atom \n  ;                            (binding [; always prefer envs with :line information, even if inaccurate\n  ;                                                  vs/*current-env* (if (:line (:env expr))\n  ;                                                                     (:env expr)\n  ;                                                                     vs/*current-env*)\n  ;                                      vs/*current-expr* expr]\n  ;                              (err/int-error (str \"Applying flow filter resulted in local being bottom\"\n  ;                                                \"\\n\"\n  ;                                                (with-out-str (print-env* nenv))\n  ;                                                \"\\nOld: \"\n  ;                                                (with-out-str (print-env* env))))))]\n                      (if @flow-atom\n                        ;reachable\n                        [nenv (conj cexprs cexpr)]\n                        ;unreachable\n                        (do ;(prn \"Detected unreachable code\")\n                          (reduced [nenv (conj cexprs \n                                               (assoc cexpr \n                                                      u/expr-type (r/ret (r/Bottom))))])))))\n                  [lex/*lexical-env* []] (map-indexed vector exprs))\n          actual-types (map u/expr-type cexprs)\n          _ (assert (lex/PropEnv? env))\n          _ (assert ((every-pred vector? seq) cexprs)) ; make sure we conj'ed in the right order\n          _ (assert ((every-pred (con/every-c? r/TCResult?) seq) actual-types))]\n      (assoc expr\n             :statements (ast-u/do-statements-value cexprs)\n             :ret (last cexprs)\n             u/expr-type (last actual-types)))))", :ns "clojure.core.typed.check.do", :name "check-do", :file "clojure/core/typed/check/do.clj", :column 1, :line 17, :arglists ([check internal-special-form expr expected])}
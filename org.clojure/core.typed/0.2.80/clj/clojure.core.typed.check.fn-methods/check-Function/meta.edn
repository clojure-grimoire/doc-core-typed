{:type :fn, :src "(defn check-Function\n  \"Check individual Function type against all methods\"\n  [mthods {:keys [dom rest drest kws] :as f} {:keys [recur-target-fn]}]\n  {:pre [((every-pred methods? seq) mthods)\n         (r/Function? f)\n         ((some-fn nil? ifn?) recur-target-fn)]\n   :post [(methods? %)]}\n  ;(prn \"check-Function\" f)\n  (let [ndom (count dom)\n        expected-for-method \n        (fn [{:keys [fixed-arity] :as method}]\n          {:pre [(method? method)]\n           :post [((some-fn nil? r/Function?) %)]}\n          ;; fn-method-u/*check-fn-method1-rest-type*, and check-fn-method1\n          ;; actually distribute the types amongst the fixed and rest parameters\n          (let [variadic?   (ast-u/variadic-method? method)\n                fixed-arity (ast-u/fixed-arity method)]\n            (cond\n              (or rest drest)\n              (cond\n                (not variadic?) nil\n\n                ; extra domains flow into the rest argument\n                (<= fixed-arity ndom) f\n\n                ;otherwise method doesn't fit\n                :else nil)\n\n              ; kw and drest functions must have exact fixed domain match\n              (or kws drest)\n              (cond\n                (not variadic?) nil\n                (== ndom fixed-arity) f\n                :else nil)\n\n              ; no variable arity\n              (= nil rest drest kws)\n              (cond\n                variadic? nil\n                (== ndom fixed-arity) f\n                :else nil))))\n\n        maybe-check (fn [method]\n                      {:pre [(method? method)]\n                       :post [((some-fn nil? method?) %)]}\n                      (when-let [fe (expected-for-method method)]\n                        ;(prn \"inner expected in check-Function\" fe)\n                        (let [{:keys [cmethod]} (fn-method1/check-fn-method1\n                                                  method \n                                                  fe\n                                                  :recur-target-fn recur-target-fn)]\n                          (assert (method? cmethod))\n                          cmethod)))\n        ms (->> mthods\n                (map maybe-check)\n                (filter identity)\n                vec)]\n    ;(prn \"checked ms\" (count ms))\n    (when (empty? ms)\n      (binding [vs/*current-expr* (impl/impl-case\n                                    :clojure (first mthods)\n                                    ; fn-method is not printable in cljs\n                                    :cljs vs/*current-expr*)\n                vs/*current-env* (or (:env (first mthods)) vs/*current-env*)]\n        (prs/with-unparse-ns (cu/expr-ns (first mthods))\n          (err/tc-delayed-error (str \"No matching arities: \" (prs/unparse-type f))))))\n    ms))", :ns "clojure.core.typed.check.fn-methods", :name "check-Function", :file "clojure/core/typed/check/fn_methods.clj", :column 1, :line 30, :arglists ([mthods {:keys [dom rest drest kws], :as f} {:keys [recur-target-fn]}]), :doc "Check individual Function type against all methods"}
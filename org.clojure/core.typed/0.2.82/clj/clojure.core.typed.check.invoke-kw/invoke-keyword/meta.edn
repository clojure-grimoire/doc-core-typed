{:type :fn, :src "(defn invoke-keyword [expr kw-ret target-ret default-ret expected-ret]\n  {:pre [(r/TCResult? kw-ret)\n         (r/TCResult? target-ret)\n         ((some-fn nil? r/TCResult?) default-ret)\n         ((some-fn nil? r/TCResult?) expected-ret)\n         ((some-fn nil? map?) expr)]\n   :post [(r/TCResult? %)]}\n  (u/p :check/invoke-keyword\n  (let [targett (c/-resolve (r/ret-t target-ret))\n        kwt (r/ret-t kw-ret)\n        defaultt (or (when default-ret\n                       (r/ret-t default-ret))\n                     r/-nil)]\n    (cond\n      ;Keyword must be a singleton with no default\n      (c/keyword-value? kwt)\n      (let [{path-hm :path id-hm :id :as o} (when (obj/Path? (r/ret-o target-ret))\n                                              (r/ret-o target-ret))\n            o (or o (r/ret-o target-ret))\n            _ (assert ((some-fn obj/Path? obj/EmptyObject?) o))\n            this-pelem (pe/-kpe (:val kwt))\n            val-type (c/find-val-type targett kwt defaultt)]\n        (binding [vs/*current-expr* (or expr vs/*current-expr*)]\n          (below/maybe-check-below\n            (if (not= (c/Un) val-type)\n              (r/ret val-type\n                     (fo/-FS (if (and (obj/Path? o)\n                                      (= r/-nil defaultt))\n                               ;; if val-type is falsey, this will simplify to ff\n                               (let [obj (obj/-path (concat path-hm [this-pelem]) id-hm)]\n                                 (fo/-and\n                                   (fo/-filter-at val-type obj)\n                                   (fo/-not-filter-at (c/Un r/-nil r/-false) obj)))\n                               fl/-top)\n                             (if (and (obj/Path? o)\n                                      (= r/-nil defaultt))\n                               (fo/-or (fo/-filter (c/make-HMap :absent-keys #{kwt}) id-hm path-hm) ; this map doesn't have a kwt key or...\n                                       (fo/-filter (c/Un r/-nil r/-false) id-hm (concat path-hm [this-pelem]))) ; this map has a false kwt key\n                               fl/-top))\n                     (if (and (obj/Path? o) (= r/-nil defaultt))\n                       (update-in o [:path] #(seq (concat % [this-pelem])))\n                       obj/-empty))\n              (do (u/tc-warning (str \"Keyword lookup gave bottom type: \"\n                                     (:val kwt) \" \" (prs/unparse-type targett)))\n                  (r/ret r/-any)))\n            expected-ret)))\n\n      :else (err/int-error (str \"keyword-invoke only supports keyword lookup, no default. Found \" \n                              (prs/unparse-type kwt)))))))", :ns "clojure.core.typed.check.invoke-kw", :name "invoke-keyword", :file "clojure/core/typed/check/invoke_kw.clj", :column 1, :line 17, :arglists ([expr kw-ret target-ret default-ret expected-ret])}
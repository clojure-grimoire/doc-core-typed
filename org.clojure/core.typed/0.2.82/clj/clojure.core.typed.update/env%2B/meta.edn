{:type :fn, :src "(defn env+ [env fs flag]\n  {:pre [(lex/PropEnv? env)\n         (every? fl/Filter? fs)\n         (con/boolean? @flag)]\n   :post [(lex/PropEnv? %)\n          ; flag should be updated by the time this function exits\n          (con/boolean? @flag)]}\n  (let [[props atoms] (combine-props fs (:props env) flag)]\n    (reduce (fn [env f]\n              ;post-condition checked in env+\n              {:pre [(lex/PropEnv? env)\n                     (fl/Filter? f)]}\n              (cond\n                (fl/BotFilter? f) (do (reset! flag false)\n                                      (update-in env [:l] (fn [l] \n                                                            (zipmap (keys l)\n                                                                    (repeat r/-nothing)))))\n                ((some-fn fl/TypeFilter? fl/NotTypeFilter?) f)\n                (let [new-env (update-in env [:l (:id f)]\n                                         (fn [t]\n                                           (when-not t\n                                             (err/int-error (str \"Updating local not in scope: \" (:id f))))\n                                           (update t f)))]\n                  ; update flag if a variable is now bottom\n                  (when-let [bs (some #{(c/Un)} (vals (:l new-env)))]\n                    (reset! flag false))\n                  new-env)\n\n                (and (fl/OrFilter? f)\n                     (every? (some-fn fl/TypeFilter? fl/NotTypeFilter?) (:fs f))\n                     (apply = (map fl/filter-id (:fs f))))\n                (let [id (-> f :fs first fl/filter-id)\n                      _ (assert (symbol? id))\n                      new-env (update-in env [:l id]\n                                         (fn [t]\n                                           (when-not t\n                                             (err/int-error (str \"Updating local not in scope: \" (:id f))))\n                                           (apply c/Un\n                                                  (map (fn [f] (update t f)) \n                                                       (:fs f)))))]\n                  ; update flag if a variable is now bottom\n                  (when-let [bs (some #{(c/Un)} (vals (:l new-env)))]\n                    (reset! flag false))\n                  new-env)\n                :else env))\n            (assoc env :props (set (concat atoms props)))\n            (concat atoms props))))", :ns "clojure.core.typed.update", :name "env+", :file "clojure/core/typed/update.clj", :column 1, :line 363, :arglists ([env fs flag])}
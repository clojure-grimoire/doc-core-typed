{:type :fn, :src "(deftest destructuring-special-ops\n  ;FIXME for destructuring rest args\n;  (is-clj (= (tc-t (let [a '(a b)]\n;                 (seq? a)))\n;         (ret -true (-true-filter) -empty)))\n  (is-clj (= (-> \n           (tc-t (let [a {:a 1}]\n                   (if (seq? a)\n                     (apply hash-map a)\n                     a)))\n           ret-t)\n         (-complete-hmap {(-val :a) (-val 1)})))\n  (is-clj (= (tc-t (fn [{a :a} :- (HMap :mandatory {:a (Value 1)})]\n                     a))\n             (ret (make-FnIntersection \n                    (Function-maker [(make-HMap :mandatory {(-val :a) (-val 1)})]\n                                    (make-Result (-val 1) \n                                                 (-true-filter)\n                                                 (-path [(-kpe :a)] 0))\n                                    nil nil nil))\n                  (-FS -top -bot)\n                  -empty)))\n  ;FIXME inferred filters are bit messy, but should be (-FS -bot (! Seq 0))\n  #_(is-with-aliases (= (-> (tc-t (clojure.core.typed/fn> [a :- clojure.core.typed.test.util-aliases/UnionName]\n                                   (seq? a)))\n           ret-t)\n         (make-FnIntersection\n           (Function-maker [(Name-maker 'clojure.core.typed.test.util-aliases/UnionName)]\n                         (make-Result -false \n                                      ;FIXME why isn't this (-FS -bot (-not-filter (RClass-of ISeq [-any]) 0)) ?\n                                      (-FS -bot -top)\n                                      -empty)\n                         nil nil nil))))\n  (is-clj (= (tc-t (let [{a :a} {:a 1}]\n                 a))\n         (ret (-val 1) \n              (-true-filter)\n              -empty)))\n  ;FIXME should be (-FS -bot (! ISeq 0))\n  #_(is-clj (= (tc-t (clojure.core.typed/fn> [a :- (HMap :mandatory {:a (Value 1)})]\n                               (seq? a)))\n         (ret (make-FnIntersection\n                (Function-maker [(make-HMap :mandatory {(-val :a) (-val 1)})]\n                              (make-Result -false (-false-filter) -empty)\n                              nil nil nil))\n              (-FS -top -bot)\n              -empty)))\n  ;roughly the macroexpansion of map destructuring\n  ;FIXME\n  #_(is-clj (= (tc-t (clojure.core.typed/fn> \n                 [map-param :- clojure.core.typed.test.rbt-types/badRight]\n                 (when (and (= :Black (-> map-param :tree))\n                            (= :Red (-> map-param :left :tree))\n                            (= :Red (-> map-param :left :right :tree)))\n                   (let [map1 map-param\n                         map1\n                         (if (clojure.core/seq? map1)\n                           (clojure.core/apply clojure.core/hash-map map1)\n                           map1)\n\n                         mapr (clojure.core/get map1 :right)\n                         mapr\n                         (if (clojure.core/seq? mapr)\n                           (clojure.core/apply clojure.core/hash-map mapr)\n                           mapr)\n\n                         maprl (clojure.core/get mapr :left)\n                         ;_ (print-env \"maprl\")\n                         maprl\n                         (if (clojure.core/seq? maprl)\n                           (clojure.core/apply clojure.core/hash-map maprl)\n                           maprl)]\n                     maprl))))))\n  ;destructuring a variable of union type\n  (is-clj (= (ety (fn [{a :a} :- (U (HMap :mandatory {:a (Value 1)})\n                                    (HMap :mandatory {:b (Value 2)}))]\n                    a))\n             (make-FnIntersection \n               (make-Function [(Un (make-HMap :mandatory {(-val :a) (-val 1)})\n                                   (make-HMap :mandatory {(-val :b) (-val 2)}))]\n                              -any\n                              nil nil\n                              :filter (-FS (-and (-not-filter (Un -nil -false) 0 [(-kpe :a)])\n                                                  (-filter \n                                                    (parse-clj\n                                                      `(U (HMap :mandatory {:a (Val 1)}) \n                                                          (HMap :mandatory {:a Any, :b (Val 2)})))\n                                                    0))\n                                            (-filter (Un -nil -false) 0 [(-kpe :a)]))\n                              :object (-path [(-kpe :a)] 0))))))", :ns "clojure.core.typed.test.core", :name "destructuring-special-ops", :file "clojure/core/typed/test/core.clj", :column 1, :line 548, :test #<core$fn__25482 clojure.core.typed.test.core$fn__25482@5b7d2f36>}
{:type :fn, :src "(defn check-special-fn \n  [check {[_ _ fn-ann-expr :as statements] :statements fexpr :ret :as expr} expected]\n  {:pre [((some-fn nil? r/TCResult?) expected)\n         (#{3} (count statements))\n         (#{:fn} (:op fexpr))]}\n  ;(prn \"check-special-fn\")\n  (binding [prs/*parse-type-in-ns* (cu/expr-ns expr)]\n    (let [fn-anns (ast-u/map-expr-at fn-ann-expr :ann)\n          poly    (ast-u/map-expr-at fn-ann-expr :poly)\n          ;_ (prn \"poly\" poly)\n          _ (assert (vector? fn-anns))\n          self-name (cu/fn-self-name fexpr)\n          _ (assert ((some-fn nil? symbol?) self-name))\n          ;_ (prn \"self-name\" self-name)\n          [frees-with-bnds dvar] (parse-poly poly)\n          new-bnded-frees (into {} (map (fn [[n bnd]] [(r/make-F n) bnd]) frees-with-bnds))\n          new-dotted (when dvar [(r/make-F (first dvar))])\n          flat-expecteds \n          (free-ops/with-bounded-frees new-bnded-frees\n            (dvar/with-dotted new-dotted\n              (prepare-expecteds expr fn-anns)))\n          ;_ (prn \"flat-expecteds\" flat-expecteds)\n          _ (assert ((some-fn nil? vector?) poly))\n\n          good-expected? (fn [expected]\n                           {:pre [((some-fn nil? r/TCResult?) expected)]\n                            :post [(con/boolean? %)]}\n                           (boolean\n                             (when expected\n                               (seq (fn-methods/function-types (r/ret-t expected))))))\n\n          ;; If we have an unannotated fn macro and a good expected type, use the expected\n          ;; type via check-fn, otherwise check against the expected type after a call to check-anon.\n          cfexpr \n          (if (and (all-defaults? fn-anns poly) \n                   (good-expected? expected))\n            (do ;(prn \"using check-fn\")\n                (fn/check-fn fexpr expected))\n            (let [;_ (prn \"using anon-fn\")\n                  cfexpr (lex/with-locals (when self-name\n                                            (let [this-type (self-type flat-expecteds)\n                                                  ;_ (prn \"this-type\" this-type)\n                                                  ]\n                                              {self-name this-type}))\n                           (free-ops/with-bounded-frees new-bnded-frees\n                             (dvar/with-dotted new-dotted\n                               (check-anon\n                                 fexpr\n                                 flat-expecteds\n                                 {:frees-with-bnds frees-with-bnds\n                                  :dvar dvar}))))]\n              (update-in cfexpr [u/expr-type] below/maybe-check-below expected)))]\n      (assoc expr\n             :ret cfexpr\n             u/expr-type (u/expr-type cfexpr)))))", :ns "clojure.core.typed.check.special.fn", :name "check-special-fn", :file "clojure/core/typed/check/special/fn.clj", :column 1, :line 160, :arglists ([check {[_ _ fn-ann-expr :as statements] :statements, fexpr :ret, :as expr} expected])}
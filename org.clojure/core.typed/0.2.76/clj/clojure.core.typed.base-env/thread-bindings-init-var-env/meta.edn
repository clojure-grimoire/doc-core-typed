{:type :var, :src "(delay-and-cache-env ^:private init-var-env\n  (reset-alias-env!)\n  (merge\n   (common/parse-clj-ann-map common/common-var-annotations)\n   (h/var-mappings\n\nclojure.core.typed/check-ns (IFn [Symbol -> Any]\n                                [-> Any])\n;; Internal annotations\n\nclojure.core.typed.current-impl/*current-impl* Any\nclojure.core.typed.current-impl/clojure Any\nclojure.core.typed.current-impl/clojurescript Any\nclojure.core.typed/ann* [Any Any Any -> Any]\nclojure.core.typed/def-alias* [Any Any -> Any]\nclojure.core.typed/declare-names* [Any -> Any]\nclojure.core.typed/typed-deps* [Any -> Any]\nclojure.core.typed/warn-on-unannotated-vars* [-> Any]\nclojure.core.typed/ann-datatype* [Any Any Any Any -> Any]\nclojure.core.typed/ann-protocol* [Any Any Any -> Any]\n      ; REMOVED\nclojure.core.typed/ann-pprotocol* [Any Any Any -> Any]\nclojure.core.typed/ann-record* [Any Any Any Any -> Any]\nclojure.core.typed/ann-pdatatype* [Any Any Any Any -> Any]\nclojure.core.typed/ann-precord* [Any Any Any Any -> Any]\nclojure.core.typed/declare-datatypes* [Any -> Any]\nclojure.core.typed/declare-protocols* [Any -> Any]\nclojure.core.typed/non-nil-return* [Any Any -> Any]\nclojure.core.typed/nilable-param* [Any Any -> Any]\nclojure.core.typed/override-constructor* [Any Any -> Any]\nclojure.core.typed/override-method* [Any Any -> Any]\nclojure.core.typed/typed-deps* [Any -> Any]\nclojure.core.typed/load-if-needed [-> Any]\nclojure.core.typed/*collect-on-eval* Any\n; should always be special cased\n;clojure.core.typed/var>* [Any -> (Var2 Nothing Any)]\n\n;; core annotations\n\nclojure.core/*ns* Namespace\nclojure.core/pop-thread-bindings [-> Any]\nclojure.core/load [String * -> Any]\nclojure.core/read-string [String -> Any]\nclojure.core/read (IFn [-> Any]\n                      [java.io.Reader -> Any]\n                      [java.io.Reader Boolean Any -> Any]\n                      [java.io.Reader Boolean Any Boolean -> Any])\nclojure.core/read-line [-> (U nil String)]\n\nclojure.core/add-classpath [(U String java.net.URL) -> nil]\n\nclojure.core/*1 Any\nclojure.core/*2 Any\nclojure.core/*3 Any\nclojure.core/*e Throwable\nclojure.core/*agent* (U nil (Agent2 Nothing Any))\nclojure.core/*allow-unresolved-vars* Any\nclojure.core/*assert* Any\nclojure.core/*data-readers* (Map Symbol (Var2 Nothing Any))\nclojure.core/*default-data-reader-fn* (U nil [Any Any -> Any])\nclojure.core/*fn-loader* Any\nclojure.core/*math-context* Any\nclojure.core/*source-path* String\nclojure.core/*use-context-classloader* Any\n\nclojure.core/alength [(ReadOnlyArray Any) -> AnyInteger]\nclojure.core/aclone (All [x] [(ReadOnlyArray x) -> (Array x)])\nclojure.core/aget (All [x] (IFn [(ReadOnlyArray x) \n                                AnyInteger -> x]\n                               [(ReadOnlyArray (ReadOnlyArray x)) \n                                AnyInteger AnyInteger -> x]\n                               [(ReadOnlyArray (ReadOnlyArray (ReadOnlyArray x))) \n                                AnyInteger AnyInteger AnyInteger -> x]\n                               [(ReadOnlyArray (ReadOnlyArray (ReadOnlyArray (ReadOnlyArray x)))) \n                                AnyInteger AnyInteger AnyInteger AnyInteger -> x]\n                               ; don't support unsound cases\n                               [(ReadOnlyArray (ReadOnlyArray (ReadOnlyArray (ReadOnlyArray (ReadOnlyArray x)))))\n                                AnyInteger AnyInteger AnyInteger AnyInteger AnyInteger -> x]))\n\nclojure.core/aset\n(All [x]\n  (IFn\n    [(Array x) AnyInteger x -> x]\n    [(Array x) AnyInteger AnyInteger x -> x]\n    [(Array x) AnyInteger AnyInteger AnyInteger x -> x]\n    [(Array x) AnyInteger AnyInteger AnyInteger AnyInteger x -> x]\n    [(Array x) AnyInteger AnyInteger AnyInteger AnyInteger AnyInteger x -> x]\n    [(Array x) AnyInteger AnyInteger AnyInteger AnyInteger AnyInteger AnyInteger x -> x]\n    [(Array x) AnyInteger AnyInteger AnyInteger AnyInteger AnyInteger AnyInteger AnyInteger x -> x]\n    [(Array x) AnyInteger AnyInteger AnyInteger AnyInteger AnyInteger AnyInteger AnyInteger AnyInteger x -> x]\n    [(Array x) AnyInteger AnyInteger AnyInteger AnyInteger AnyInteger AnyInteger AnyInteger AnyInteger AnyInteger x -> x]\n    [(Array x) AnyInteger AnyInteger AnyInteger AnyInteger AnyInteger AnyInteger AnyInteger AnyInteger AnyInteger AnyInteger x -> x]))\n\nclojure.core/macroexpand-1 [Any -> Any]\nclojure.core/macroexpand [Any -> Any]\n\nclojure.core/create-struct [Any * -> (Map Any Any)]\n\nclojure.core/find-ns [Symbol -> Namespace]\nclojure.core/create-ns [Symbol -> Namespace]\nclojure.core/remove-ns [Symbol -> Namespace]\n\nclojure.core/namespace [(U Symbol String Keyword) -> (Option String)]\nclojure.core/ns-name [(U Symbol Namespace) -> Symbol]\nclojure.core/ns-map [(U Symbol Namespace) -> Symbol]\nclojure.core/ns-aliases [(U Symbol Namespace) -> (Map Symbol Namespace)]\nclojure.core/name [(U String Named) -> String]\nclojure.core/the-ns [(U Symbol Namespace) -> Namespace]\nclojure.core/in-ns [Symbol -> nil]\nclojure.core/import [Any * -> nil]\nclojure.core/identity (All [x] [x -> x\n                                :filters {:then (! (U nil false) 0)\n                                          :else (is (U nil false) 0)}\n                                :object {:id 0}])\nclojure.core/gensym (IFn [-> Symbol]\n                        [(U Symbol String) -> Symbol])\nclojure.core/intern (IFn [(U Symbol Namespace) Symbol -> (Var2 Nothing Any)]\n                        [(U Symbol Namespace) Symbol Any -> (Var2 Nothing Any)])\n\n\nclojure.core/doall (All [[c :< (U nil (Seqable Any))]]\n                     (IFn [c -> c]\n                         [AnyInteger c -> c]))\nclojure.core/dorun (IFn [(U nil (Seqable Any)) -> nil]\n                       [AnyInteger (U nil (Seqable Any)) -> nil])\nclojure.core/iterate (All [x]\n                       [[x -> x] x -> (ASeq x)])\nclojure.core/memoize (All [x y ...]\n                            [[y ... y -> x] -> [y ... y -> x]])\n\nclojure.core/key (All [x]\n                           [(IMapEntry x Any) -> x])\nclojure.core/val (All [x]\n                           [(IMapEntry Any x) -> x])\n\n;clojure.core/juxt\n;(All [b1 ...]\n;(All [x r b2 ...]\n;     (Fn [[b1 ... b1 -> b2] ... b2 -> [b1 ... b1 -> '[b2 ... b2]]]\n;         [[b1 ... b1 -> r] * -> [b1 ... b1 -> (Vec r)]]\n;         [[x * -> b2] ... b2 -> [x * -> '[b2 ... b2]]]\n;         [[x * -> r] * -> [x * -> (Vec r)]])))\n\n\n;TODO flip filters\nclojure.core/complement (All [x] [[x -> Any] -> [x -> Boolean]])\n; should preserve filters\nclojure.core/boolean [Any -> Boolean]\n\nclojure.core/filter (All [x y]\n                           (IFn\n                             [[x -> Any :filters {:then (is y 0)}] (Option (Seqable x)) -> (ASeq y)]\n                             [[x -> Any :filters {:then (! y 0)}] (Option (Seqable x)) -> (ASeq (I x (Not y)))]\n                             [[x -> Any] (Option (Seqable x)) -> (ASeq x)]))\nclojure.core/filterv (All [x y]\n                          (IFn\n                            [[x -> Any :filters {:then (is y 0)}] (Option (Seqable x)) -> (AVec y)]\n                            [[x -> Any] (Option (Seqable x)) -> (AVec x)]))\nclojure.core/remove (All [x y]\n                           (IFn\n                             [[x -> Any :filters {:else (is y 0)}] (Option (Seqable x)) -> (ASeq y)]\n                             [[x -> Any :filters {:else (! y 0)}] (Option (Seqable x)) -> (ASeq (I x (Not y)))]\n                             [[x -> Any] (Option (Seqable x)) -> (ASeq x)]\n                             ))\n\n\nclojure.core/take-while (All [x y]\n                               (IFn \n                                 [[x -> Any :filters {:then (is y 0)}] (Option (Seqable x)) -> (ASeq y)]\n                                 [[x -> Any] (Option (Seqable x)) -> (ASeq x)]))\nclojure.core/drop-while (All [x]\n                               [[x -> Any] (Option (Seqable x)) -> (ASeq x)])\n\nclojure.core/split-with\n     (All [x y z] \n       (IFn\n         [[x -> Any :filters {:then (is y 0), :else (is z 0)}] (Option (Seqable x)) -> '[(ASeq y) (ASeq z)]]\n         [[x -> Any] (Option (Seqable x)) -> '[(ASeq x) (ASeq x)]]))\n\nclojure.core/split-at\n     (All [x y z] \n          [AnyInteger (Option (Seqable x)) -> '[(ASeq x) (ASeq x)]])\n\nclojure.core/partition-all (All [x] \n                             (IFn [Int (Nilable (Seqable x)) -> (ASeq (ASeq x))] \n                                 [Int Int (Nilable (Seqable x)) -> (ASeq (ASeq x))]))\n\nclojure.core/repeatedly\n     (All [x]\n          (IFn [[-> x] -> (ASeq x)]\n              [AnyInteger [-> x] -> (ASeq x)]))\n\n\nclojure.core/some (All [x y] [[x -> y] (Option (Seqable x)) -> (Option y)])\n\n; Unions need to support dots for this to work:\n;\n; (All [t0 b ...]\n;    (IFn [[Any -> Any :filters {:then (is t0 0) :else (! t0 0)}] \n;         [Any -> Any :filters {:then (is b 0) :else (! b 0)}] ... b\n;         -> (IFn [Any -> Any :filters {:then (is (U t0 b ... b) 0) :else (! (U t0 b ... b) 0)}]\n;                [Any * -> Any])]))\nclojure.core/some-fn \n  (All [t0 t1 t2 t3 t4 t5]\n    (IFn [[Any -> Boolean :filters {:then (is t0 0) :else (! t0 0)}] \n         -> (IFn [Any -> Boolean :filters {:then (is t0 0) :else (! t0 0)}]\n                [Any * -> Any])]\n        [[Any -> Boolean :filters {:then (is t0 0) :else (! t0 0)}] \n         [Any -> Boolean :filters {:then (is t1 0) :else (! t1 0)}]\n         -> (IFn [Any -> Boolean :filters {:then (is (U t0 t1) 0) :else (! (U t0 t1) 0)}]\n                [Any * -> Any])]\n        [[Any -> Boolean :filters {:then (is t0 0) :else (! t0 0)}] \n         [Any -> Boolean :filters {:then (is t1 0) :else (! t1 0)}]\n         [Any -> Boolean :filters {:then (is t2 0) :else (! t2 0)}]\n         -> (IFn [Any -> Boolean :filters {:then (is (U t0 t1 t2) 0) :else (! (U t0 t1 t2) 0)}]\n                [Any * -> Any])]\n        [[Any -> Boolean :filters {:then (is t0 0) :else (! t0 0)}] \n         [Any -> Boolean :filters {:then (is t1 0) :else (! t1 0)}]\n         [Any -> Boolean :filters {:then (is t2 0) :else (! t2 0)}]\n         [Any -> Boolean :filters {:then (is t3 0) :else (! t3 0)}]\n         -> (IFn [Any -> Boolean :filters {:then (is (U t0 t1 t2 t3) 0) :else (! (U t0 t1 t2 t3) 0)}]\n                [Any * -> Any])]\n        [[Any -> Boolean :filters {:then (is t0 0) :else (! t0 0)}] \n         [Any -> Boolean :filters {:then (is t1 0) :else (! t1 0)}]\n         [Any -> Boolean :filters {:then (is t2 0) :else (! t2 0)}]\n         [Any -> Boolean :filters {:then (is t3 0) :else (! t3 0)}]\n         [Any -> Boolean :filters {:then (is t4 0) :else (! t4 0)}]\n         -> (IFn [Any -> Boolean :filters {:then (is (U t0 t1 t2 t3 t4) 0) :else (! (U t0 t1 t2 t3 t4) 0)}]\n                [Any * -> Any])]\n        [[Any -> Boolean :filters {:then (is t0 0) :else (! t0 0)}] \n         [Any -> Boolean :filters {:then (is t1 0) :else (! t1 0)}]\n         [Any -> Boolean :filters {:then (is t2 0) :else (! t2 0)}]\n         [Any -> Boolean :filters {:then (is t3 0) :else (! t3 0)}]\n         [Any -> Boolean :filters {:then (is t4 0) :else (! t4 0)}]\n         [Any -> Boolean :filters {:then (is t5 0) :else (! t5 0)}]\n         -> (IFn [Any -> Boolean :filters {:then (is (U t0 t1 t2 t3 t4 t5) 0) :else (! (U t0 t1 t2 t3 t4 t5) 0)}]\n                [Any * -> Any])]\n        [[Any -> Any] [Any -> Any] * -> [Any * -> Any]]))\nclojure.core/every-pred\n  (All [t0 t1 t2 t3 t4 t5]\n    (IFn [[Any -> Boolean :filters {:then (is t0 0) :else (! t0 0)}] \n         -> (IFn [Any -> Boolean :filters {:then (is t0 0) :else (! t0 0)}]\n                [Any * -> Any])]\n        [[Any -> Boolean :filters {:then (is t0 0) :else (! t0 0)}] \n         [Any -> Boolean :filters {:then (is t1 0) :else (! t1 0)}]\n         -> (IFn [Any -> Boolean :filters {:then (is (I t0 t1) 0) :else (! (I t0 t1) 0)}]\n                [Any * -> Any])]\n        [[Any -> Boolean :filters {:then (is t0 0) :else (! t0 0)}] \n         [Any -> Boolean :filters {:then (is t1 0) :else (! t1 0)}]\n         [Any -> Boolean :filters {:then (is t2 0) :else (! t2 0)}]\n         -> (IFn [Any -> Boolean :filters {:then (is (I t0 t1 t2) 0) :else (! (I t0 t1 t2) 0)}]\n                [Any * -> Any])]\n        [[Any -> Boolean :filters {:then (is t0 0) :else (! t0 0)}] \n         [Any -> Boolean :filters {:then (is t1 0) :else (! t1 0)}]\n         [Any -> Boolean :filters {:then (is t2 0) :else (! t2 0)}]\n         [Any -> Boolean :filters {:then (is t3 0) :else (! t3 0)}]\n         -> (IFn [Any -> Boolean :filters {:then (is (I t0 t1 t2 t3) 0) :else (! (I t0 t1 t2 t3) 0)}]\n                [Any * -> Any])]\n        [[Any -> Boolean :filters {:then (is t0 0) :else (! t0 0)}] \n         [Any -> Boolean :filters {:then (is t1 0) :else (! t1 0)}]\n         [Any -> Boolean :filters {:then (is t2 0) :else (! t2 0)}]\n         [Any -> Boolean :filters {:then (is t3 0) :else (! t3 0)}]\n         [Any -> Boolean :filters {:then (is t4 0) :else (! t4 0)}]\n         -> (IFn [Any -> Boolean :filters {:then (is (I t0 t1 t2 t3 t4) 0) :else (! (I t0 t1 t2 t3 t4) 0)}]\n                [Any * -> Any])]\n        [[Any -> Any :filters {:then (is t0 0) :else (! t0 0)}] \n         [Any -> Any :filters {:then (is t1 0) :else (! t1 0)}]\n         [Any -> Any :filters {:then (is t2 0) :else (! t2 0)}]\n         [Any -> Any :filters {:then (is t3 0) :else (! t3 0)}]\n         [Any -> Any :filters {:then (is t4 0) :else (! t4 0)}]\n         [Any -> Any :filters {:then (is t5 0) :else (! t5 0)}]\n         -> (IFn [Any -> Boolean :filters {:then (is (I t0 t1 t2 t3 t4 t5) 0) :else (! (I t0 t1 t2 t3 t4 t5) 0)}]\n                [Any * -> Any])]\n        [[Any -> Any] [Any -> Any] * -> [Any * -> Any]]))\n\nclojure.core/concat (All [x] [(Option (Seqable x)) * -> (ASeq x)])\n\nclojure.core/set (All [x] [(Option (Seqable x)) -> (PersistentHashSet x)])\nclojure.core/hash-set (All [x] [x * -> (PersistentHashSet x)])\nclojure.core/sorted-set (All [x] [x * -> (PersistentTreeSet x)])\nclojure.core/sorted-set-by (All [x] [[x x -> AnyInteger] x * -> (PersistentTreeSet x)])\nclojure.core/list (All [x] [x * -> (PersistentList x)])\nclojure.core/list* (All [x] \n                        (IFn [(U nil (Seqable x)) -> (NilableNonEmptyASeq x)]\n                            [x (U nil (Seqable x)) -> (NilableNonEmptyASeq x)]\n                            [x x (U nil (Seqable x)) -> (NilableNonEmptyASeq x)]\n                            [x x x (U nil (Seqable x)) -> (NilableNonEmptyASeq x)]\n                            [x x x x (U nil (Seqable x)) -> (NilableNonEmptyASeq x)]\n                            [x x x x x (U nil (Seqable x)) -> (NilableNonEmptyASeq x)]\n                            [x x x x x x (U nil (Seqable x)) -> (NilableNonEmptyASeq x)]\n                            [x x x x x x x (U nil (Seqable x)) -> (NilableNonEmptyASeq x)]\n                            [x x x x x x x x (U nil (Seqable x)) -> (NilableNonEmptyASeq x)]\n                            [x x x x x x x x x (U nil (Seqable x)) -> (NilableNonEmptyASeq x)]\n                            [x x x x x x x x x x (U nil (Seqable x)) -> (NilableNonEmptyASeq x)]))\n\nclojure.core/list? (Pred (List Any))\n\nclojure.core/load-reader [java.io.Reader -> Any]\n\nclojure.core/methods [Multi -> (Map Any Any)]\n\nclojure.core/munge (IFn [Symbol -> Symbol]\n                       [Any -> Any])\n\nclojure.core/pos? (IFn [Number -> Boolean])\nclojure.core/neg? (IFn [Number -> Boolean])\n\nclojure.core/nthrest (All [x] [(U nil (Seqable x)) AnyInteger \n                               -> (ASeq x)])\n\nclojure.core/vector (All [r b ...]\n                         (IFn [b ... b -> '[b ... b]]\n                             [r * -> (AVec r)]))\nclojure.core/vec (All [x] [(Option (Seqable x)) -> (AVec x)])\n\nclojure.core/not [Any -> Boolean]\nclojure.core/constantly (All [x] [x -> [Any * -> x]])\n\nclojure.core/bound? [(Var2 Nothing Any) * -> Boolean]\nclojure.core/thread-bound? [(Var2 Nothing Any) * -> Boolean]\nclojure.core/bases [(Nilable Class) -> (NilableNonEmptyASeq Class)]\n\nclojure.core/make-hierarchy [-> Hierarchy]\nclojure.core/isa? (IFn [Any Any -> Boolean]\n                      [Hierarchy Any Any -> Boolean])\n\nclojure.core/disj\n     (All [x]\n          (IFn [(SortedSet x) Any Any * -> (SortedSet x)]\n              [(Set x) Any Any * -> (Set x)]))\n\nclojure.core/assoc\n     (All [b c d]\n       (IFn [(Map b c) b c -> (Map b c)]\n           [(Vec d) AnyInteger d -> (Vec d)]))\n\nclojure.core/dissoc\n     (All [k v]\n       (IFn [(Map k v) Any * -> (Map k v)]))\n)\n    (h/var-mappings\n\nclojure.core/zipmap\n     (All [k v]\n       [(U nil (Seqable k)) (U nil (Seqable v)) -> (APersistentMap k v)])\n\nclojure.core/keys\n(All [k]\n     [(Map k Any) -> (ASeq k) :object {:id 0 :path [Keys]}])\n\nclojure.core/vals\n(All [v]\n     [(Map Any v) -> (ASeq v) :object {:id 0 :path [Vals]}])\n\n;most useful case\nclojure.core/comp\n     (All [x y b ...]\n          [[x -> y] [b ... b -> x] -> [b ... b -> y]])\n\n\n;apply: wishful thinking\n;     (All [b1 ...]\n;     (All [y b2 ...]\n;          (IFn [[b1 ... b1 b2 ... b2 -> y] b1 ... b1 (HSequential [b2 ... b2]) -> y]\n;              [[b1 ... b1 r * -> y] b1 ... b1 (U nil (Seqable r)) -> y])))\n\nclojure.core/apply\n     (All [y a b c d r z ...]\n          (IFn [[z ... z -> y] (HSequential [z ... z]) -> y]\n              [[a z ... z -> y] a (HSequential [z ... z]) -> y]\n              [[a b z ... z -> y] a b (HSequential [z ... z]) -> y]\n              [[a b c z ... z -> y] a b c (HSequential [z ... z]) -> y]\n              [[a b c d z ... z -> y] a b c d (HSequential [z ... z]) -> y]\n              [[r * -> y] (U nil (Seqable r)) -> y]\n              [[a r * -> y] a (U nil (Seqable r)) -> y]\n              [[a b r * -> y] a b (U nil (Seqable r)) -> y]\n              [[a b c r * -> y] a b c (U nil (Seqable r)) -> y]\n              [[a b c d r * -> y] a b c d (U nil (Seqable r)) -> y]))\n\n;partial: wishful thinking (replaces the first 4 arities)\n; (All [b1 ...]\n; (All [r b2 ...]\n;    [[b1 ... b1 b2 ... b2 -> r] b1 ... b1 -> [b2 ... b2 -> r]]))\n\nclojure.core/partial\n     (All [y a b c d z ...]\n          (IFn [[z ... z -> y] -> [z ... z -> y]]\n              [[a z ... z -> y] a -> [z ... z -> y]]\n              [[a b z ... z -> y] a b -> [z ... z -> y]]\n              [[a b c z ... z -> y] a b c -> [z ... z -> y]]\n              [[a b c d z ... z -> y] a b c d -> [z ... z -> y]]\n              [[a * -> y] a * -> [a * -> y]]))\n\nclojure.core/str [Any * -> String]\nclojure.core/prn-str [Any * -> String]\nclojure.core/pr-str [Any * -> String]\nclojure.core/newline [-> nil]\n\nclojure.core/print [Any * -> nil]\nclojure.core/println [Any * -> nil]\nclojure.core/print-str [Any * -> String]\nclojure.core/println-str [Any * -> String]\nclojure.core/printf [String Any * -> nil]\nclojure.core/format [String Any  * -> String]\nclojure.core/pr [Any * -> nil]\nclojure.core/prn [Any * -> nil]\nclojure.core/flush [-> nil]\nclojure.core/*print-length* (U nil false AnyInteger)\nclojure.core/*print-level* (U nil false AnyInteger)\nclojure.core/*verbose-defrecords* Boolean\nclojure.core/print-ctor [Object [Object java.io.Writer -> Any] java.io.Writer -> nil]\n\nclojure.core/prefer-method [Multi Any Any -> Any]\nclojure.core/print-simple [Any java.io.Writer -> nil]\nclojure.core/char-escape-string (Map Character String)\nclojure.core/char-name-string (Map Character String)\nclojure.core/primitives-classnames (Map Class String)\n\nclojure.core/namespace-munge [(U Symbol Namespace) -> String]\n\n;clojure.core/find-protocol-impl ['{:on-interface Class\n;                                   :impls ?}]\n\n\nclojure.core/re-matcher [java.util.regex.Pattern String -> java.util.regex.Matcher]\nclojure.core/re-groups [java.util.regex.Matcher -> (U nil String (Vec (Option String)))]\nclojure.core/re-find (IFn [java.util.regex.Matcher -> (U nil String (Vec (Option String)))]\n                              [java.util.regex.Pattern String -> (U nil String (Vec (Option String)))])\nclojure.core/re-seq [java.util.regex.Pattern String -> (ASeq (U nil String (Vec (Option String))))]\n\nclojure.core/subs (IFn [String AnyInteger -> String]\n                           [String AnyInteger AnyInteger -> String])\n\n;TODO\n;clojure.core/spit [java.io.Writer Any]\n\nclojure.core/future-call (All [x] [[-> x] -> (Future x)])\n\nclojure.core/atom (All [x]\n                       [x & :optional {:validator (U nil [x -> Any]) :meta Any} -> (Atom2 x x)])\n\nclojure.core/set-validator! (All [x]\n                                 [(clojure.lang.IRef Any x) [x -> Any] -> nil])\n\nclojure.core/deref (All [x y]\n                     (IFn \n                         [(Deref x) -> x]\n                         [(U (Deref Any) java.util.concurrent.Future) -> Any]\n                         [(BlockingDeref x) AnyInteger y -> (U x y)]\n                         [(U java.util.concurrent.Future (BlockingDeref Any)) AnyInteger Any -> Any]))\n\nclojure.core/delay? (Pred (Delay Any))\n\nclojure.core/future-cancelled? [java.util.concurrent.Future -> Boolean]\n\nclojure.core/future-cancel [java.util.concurrent.Future -> Any]\n\nclojure.core/future? (Pred java.util.concurrent.Future)\n\nclojure.core/future-done? [java.util.concurrent.Future -> Boolean]\n\nclojure.core/force (All [x]\n                        (IFn [(Delay x) -> x]\n                            [Any -> Any]))\n\nclojure.core/realized? [clojure.lang.IPending -> Boolean]\n\nclojure.core/select-keys (All [k v] [(Map k v) (U nil (Seqable Any))\n                                     -> (Map k v)])\n\n; could possibly return nil in some insane mutable situtation\nclojure.core/sort (All [x] \n                       (IFn [(U nil (Seqable x)) -> (U nil (ASeq x))]\n                           [(I Comparator [x x -> AnyInteger]) \n                            (U nil (Seqable x)) -> (U nil (ASeq x))]))\n\n; this is insane\n;clojure.core/test\n\nclojure.core/reset! (All [w r]\n                              [(Atom2 w r) w -> w])\n\nclojure.core/swap! (All [w r b ...] \n                             [(Atom2 w r) [r b ... b -> w] b ... b -> w])\n\nclojure.core/compare-and-set!\n                   (All [w]\n                     [(Atom2 w Any) Any w -> Boolean])\n\nclojure.core/set-validator!\n                   (All [w]\n                     [(clojure.lang.IRef w Any) (U nil [w -> Any]) -> Any])\n\nclojure.core/get-validator\n                   (All [w]\n                     [(clojure.lang.IRef w Any) -> (U nil [w -> Any])])\n\nclojure.core/alter-var-root (All [w r b ...] \n                              [(Var2 w r) [r b ... b -> w] b ... b -> w])\n\nclojure.core/method-sig [java.lang.reflect.Method -> '[Any (U nil (NonEmptySeqable Any)) Any]]\nclojure.core/proxy-name [Class (U nil (Seqable Class)) -> String]\nclojure.core/get-proxy-class [Class * -> Class]\nclojure.core/construct-proxy [Class Any * -> Any]\nclojure.core/init-proxy [Proxy (Map String Any) -> Proxy]\nclojure.core/update-proxy [Proxy (Map String Any) -> Proxy]\nclojure.core/proxy-mappings [Proxy -> (Map String Any)]\nclojure.core/proxy-call-with-super (All [x] [[-> x] Proxy String -> x])\nclojure.core/bean [Object -> (Map Any Any)]\n\nclojure.core/fnil (All [x y z a b ...]\n                    (IFn [[x b ... b -> a] x -> [(U nil x) b ... b -> a]]\n                        [[x y b ... b -> a] x y -> [(U nil x) (U nil y) b ... b -> a]]\n                        [[x y z b ... b -> a] x y z -> [(U nil x) (U nil y) (U nil z) b ... b -> a]]))\n\nclojure.core/symbol\n     (IFn [(U Symbol String) -> Symbol]\n         [(U nil String) String -> Symbol])\n\nclojure.core/keyword\n     (IFn [(U Keyword Symbol String) -> Keyword]\n         [String String -> Keyword])\n\nclojure.core/find-keyword\n     (IFn [(U Keyword Symbol String) -> (Option Keyword)]\n         [String String -> (Option Keyword)])\n\nclojure.core/derive (IFn [(U Symbol Keyword Class) (U Symbol Keyword) -> nil]\n                        [Hierarchy (U Symbol Keyword Class) (U Symbol Keyword) -> Hierarchy])\n\nclojure.core/compare [Any Any -> Number]\n\nclojure.core/require [Any * -> nil]\nclojure.core/use [Any * -> nil]\nclojure.core/refer [Symbol & :optional {:exclude (Seqable Symbol)\n                                        :only (Seqable Symbol)\n                                        :rename (Map Symbol Symbol)}\n                    -> nil]\n\nclojure.core/*loaded-libs* (Ref1 (Set Symbol))\n\nclojure.core/seq? (Pred (Seq Any))\nclojure.core/set? (Pred (Set Any))\nclojure.core/vector? (Pred (Vec Any))\nclojure.core/nil? (Pred nil)\nclojure.core/false? (Pred false)\nclojure.core/true? (Pred true)\nclojure.core/zero? (Pred (Value 0))\nclojure.core/symbol? (Pred Symbol)\nclojure.core/keyword? (Pred Keyword)\nclojure.core/map? (Pred (Map Any Any))\n)\n    (h/var-mappings\n\nclojure.core/cast (All [x] [Class x -> x])\n\nclojure.core/associative? (Pred (clojure.lang.Associative Any Any))\nclojure.core/coll? (Pred (Coll Any))\n      ;TODO should these be parameterised?\nclojure.core/sequential? (Pred Sequential)\n;clojure.core/sorted? (Pred Sorted)\nclojure.core/meta [Any -> (U nil (Map Any Any))]\nclojure.core/with-meta (All [[x :< clojure.lang.IObj]]\n                            [x (U nil (Map Any Any)) -> x])\nclojure.core/vary-meta (All [[x :< clojure.lang.IObj] b ...]\n                            [x [(U nil (Map Any Any)) b ... b -> (U nil (Map Any Any))] b ... b -> x])\n\nclojure.core/reset-meta! [clojure.lang.IReference (U nil (Map Any Any)) -> (U nil (Map Any Any))]\nclojure.core/alter-meta! \n      (All [b ...]\n      [clojure.lang.IReference [(U nil (Map Any Any)) b ... b -> (U nil (Map Any Any))] b ... b -> (U nil (Map Any Any))])\n\nclojure.core/commute\n      (All [w r b ...] \n           [(Ref2 w r) [r b ... b -> w] b ... b -> w])\n\nclojure.core/alter\n      (All [w r b ...] \n           [(Ref2 w r) [r b ... b -> w] b ... b -> w])\n\nclojure.core/cycle\n      (All [x]\n           [(U nil (Seqable x)) -> (ASeq x)])\n\nclojure.core/compile [Symbol -> Symbol]\n\nclojure.core/comparator\n      (All [x y]\n           [[x y -> Any] -> (I Comparator [x y -> AnyInteger])])\n\nclojure.core/destructure [Any -> Any]\n\nclojure.core/distinct (All [x] [(U nil (Seqable x)) -> (ASeq x)])\n\nclojure.core/string? (Pred String)\nclojure.core/char? (Pred Character)\n\nclojure.string/split\n     (IFn [String java.util.regex.Pattern -> (AVec String)]\n         [String java.util.regex.Pattern AnyInteger -> (AVec String)])\n\nclojure.string/join\n     (IFn [(Option (Seqable Any)) -> String]\n         [Any (Option (Seqable Any)) -> String])\n\nclojure.string/upper-case\n      [CharSequence -> String]\n\nclojure.string/blank? [(U nil String) -> Boolean]\nclojure.string/capitalize [String -> String]\nclojure.string/lower-case [String -> String]\nclojure.string/replace (IFn [String String String -> String]  [String Character Character -> String]  [String java.util.regex.Pattern (U String [String -> String]) -> String] )\nclojure.string/replace-first (IFn [String String String -> String]  [String Character Character -> String]  [String java.util.regex.Pattern (U String [String -> String]) -> String] )\nclojure.string/reverse [String -> String]\nclojure.string/trim [String -> String]\nclojure.string/trimr [String -> String]\nclojure.string/triml [String -> String]\n\n\n\nclojure.core/interpose (All [x] (IFn [x (Option (Seqable x)) -> (ASeq x)]))\nclojure.core/interleave (All [x] [(Option (Seqable x)) (Option (Seqable x)) (Option (Seqable x)) * -> (ASeq x)])\n\nclojure.core/repeat (All [x] \n                         (IFn [x -> (ASeq x)]\n                             [AnyInteger x -> (ASeq x)]))\n\n;clojure.core/every? (All [x y] \n;                         (IFn [[x -> Any :filters {:then (is y 0)}] (Coll x) -> Boolean\n;                              :filters {:then (is (Coll (I x y)) 1)}]\n;                             ; argument could be nil\n;                             [[x -> Any :filters {:then (is y 0)}] (U nil (Coll x)) -> Boolean\n;                              :filters {:then (is (U nil (Coll (I x y))) 1)}]\n;                             [[x -> Any] (U nil (Seqable x)) -> Boolean]))\nclojure.core/every? (All [x y]\n                         (IFn [[x -> Any :filters {:then (is y 0)}] (Coll x) -> Boolean\n                              :filters {:then (is (Coll y) 1)}]\n                             ; argument could be nil\n                             [[x -> Any :filters {:then (is y 0)}] (U nil (Coll x)) -> Boolean\n                              :filters {:then (is (U nil (Coll y)) 1)}]\n                             [[x -> Any] (U nil (Seqable x)) -> Boolean]))\n\nclojure.core/range\n(IFn [-> (ASeq AnyInteger)]\n    [Number -> (ASeq AnyInteger)]\n    [AnyInteger Number -> (ASeq AnyInteger)]\n    [Number Number -> (ASeq Number)]\n    [AnyInteger Number AnyInteger -> (ASeq AnyInteger)]\n    [Number Number Number -> (ASeq Number)])\n\nclojure.core/class (IFn [nil -> nil :object {:id 0 :path [Class]}]\n                            [Object -> Class :object {:id 0 :path [Class]}]\n                            [Any -> (Option Class) :object {:id 0 :path [Class]}])\n\n; need better metadata support if this even has a chance of working\n; like class\nclojure.core/type [Any -> Any]\n\nclojure.core/seq (All [x]\n                        (IFn \n                          [(NonEmptyColl x) -> (NonEmptyASeq x)]\n                          [(Option (Coll x)) -> (Option (NonEmptyASeq x))\n                           :filters {:then (& (is NonEmptyCount 0)\n                                              (! nil 0))\n                                     :else (| (is nil 0)\n                                              (is EmptyCount 0))}]\n                          [(Option (Seqable x)) -> (Option (NonEmptyASeq x))]))\n\n; Seqable [[x :variance :covariant]\n;          :count [l :variance :covariant :< AnyCountRange]\n;          :to-seq [sfn :kind (TFn [[x :variance :covariant]]\n;                               (I IWithMeta (IMeta nil) (ISeq x) (ICollection x) \n;                                  IEmptyableCollection ISequential))]]\n\n; clojure.core/seq (All [x\n;                        [sfn :kind [* -> *]]\n;                    (IFn\n;                      [(Seqable x :count (CountRange 1) :to-seq sfn) -> (sfn x)]\n;                      [(Seqable x :count AnyCountRange :to-seq sfn) -> (U nil (sfn x))]))\n\nclojure.core/empty? (IFn [(Option (HSequential [Any *])) -> Boolean\n                          :filters {:then (| (is EmptyCount 0)\n                                             (is nil 0))\n                                    :else (is NonEmptyCount 0)}]\n                        [(Option (Coll Any)) -> Boolean\n                          :filters {:then (| (is EmptyCount 0)\n                                             (is nil 0))\n                                    :else (is NonEmptyCount 0)}]\n                        [(Option (Seqable Any)) -> Boolean])\n\nclojure.core/map\n     (All [c a b ...]\n          (IFn [[a b ... b -> c] (NonEmptySeqable a) (NonEmptySeqable b) ... b -> (NonEmptyASeq c)]\n              [[a b ... b -> c] (U nil (Seqable a)) (U nil (Seqable b)) ... b -> (ASeq c)]))\n\nclojure.core/mapv\n     (All [c a b ...]\n          (IFn [[a b ... b -> c] (NonEmptySeqable a) (NonEmptySeqable b) ... b -> (NonEmptyAVec c)]\n               [[a b ... b -> c] (U nil (Seqable a)) (U nil (Seqable b)) ... b -> (AVec c)]))\n\nclojure.core/mapcat\n     (All [c b ...]\n          [[b ... b -> (Option (Seqable c))] (Option (Seqable b)) ... b -> (ASeq c)])\n\nclojure.core/pmap\n     (All [c a b ...]\n          (IFn [[a b ... b -> c] (NonEmptySeqable a) (NonEmptySeqable b) ... b -> (NonEmptyASeq c)]\n              [[a b ... b -> c] (U nil (Seqable a)) (U nil (Seqable b)) ... b -> (ASeq c)]))\n\nclojure.core/pcalls\n      (All [r]\n           [[-> r] * -> (ASeq r)])\n\nclojure.core/*clojure-version* '{:major Any\n                                 :minor Any\n                                 :incremental Any\n                                 :qualifier Any}\n\nclojure.core/clojure-version [-> String]\n\nclojure.core/promise\n        (All [x]\n           [-> (Promise x)])\n\nclojure.core/deliver (All [x] [(Promise x) x -> (U nil (Promise x))])\n\nclojure.core/flatten [(U nil (Seqable Any)) -> (Seq Any)]\n\n;TODO review\n;clojure.core/group-by (All [x y] [[x -> y] (U nil (Seqable x)) -> (Map y (Vec x))])\n\nclojure.core/map-indexed\n     (All [x y] [[AnyInteger x -> y] (Option (Seqable x)) -> (Seqable y)])\n\nclojure.core/merge-with\n     (All [k v]\n          (IFn [[v v -> v] nil * -> nil]\n              [[v v -> v] (Map k v) * -> (Map k v)]\n              [[v v -> v] (Option (Map k v)) * -> (Option (Map k v))]))\n\nclojure.core/reduce\n     (All [a c]\n          (IFn \n            ;Without accumulator\n            ; default\n            ; (reduce + my-coll)\n            [[a c -> (U (Reduced a) a)] (NonEmptySeqable c) -> a]\n            [(IFn [a c -> (U (Reduced a) a)] [-> (U (Reduced a) a)]) (Option (Seqable c)) -> a]\n            ; default\n            ; (reduce + 3 my-coll)\n            [[a c -> (U (Reduced a) a)] a (Option (Seqable c)) -> a]))\n\nclojure.core/reduce-kv\n    (All [a c k v]\n      [[a k v -> (U (Reduced a) a)] a (Option (Associative k v)) -> a])\n\nclojure.core/reduced (All [x] [x -> (Reduced x)])\nclojure.core/reduced? (Pred (Reduced Any))\n\n#_(comment\n  clojure.core/reduce\n       (All [a c d]\n            (IFn \n              ;Without accumulator\n              ; empty coll, f takes no args\n              ; (reduce + []) => 0, (reduce + nil) => 0\n              [[-> c] (U nil (I (ExactCount 0) (Seqable c))) -> c]\n              ; coll count = 1, f is not called\n              ; (reduce + [1]) => 1\n              [Any (I (ExactCount 1) (Seqable c)) -> c]\n              ; coll count >= 2\n              ; (reduce + [1 2]) => 3\n              [[c c -> c] (I (CountRange 2) (Seqable c)) -> c]\n              ; default\n              ; (reduce + my-coll)\n              [(IFn [c c -> c] [-> c]) (U nil (Seqable c)) -> c]\n              ;With accumulator\n              ; empty coll, f not called, returns accumulator\n              ; (reduce + 3 []) => 3\n              [Any a (U nil (I (ExactCount 0) (Seqable Any))) -> a]\n              ; default\n              ; (reduce + 3 my-coll)\n              [[a c -> a] a (U nil (Seqable c)) -> a]))\n  )\n\n;should be special cased\nclojure.core/not= [Any Any * -> Boolean]\n\nclojure.core/first\n     (All [x]\n          (IFn [(HSequential [x Any *]) -> x\n                :object {:id 0 :path [(Nth 0)]}]\n               [(Option (EmptySeqable x)) -> nil]\n               [(NonEmptySeqable x) -> x]\n               [(Option (Seqable x)) -> (Option x)]))\n\nclojure.core/second\n     (All [x]\n          (IFn [(HSequential [Any x Any *]) -> x\n                :object {:id 0 :path [(Nth 1)]}]\n               [(Option (I (Seqable x) (CountRange 0 1))) -> nil]\n               [(I (Seqable x) (CountRange 2)) -> x]\n               [(Option (Seqable x)) -> (Option x)]))\n\nclojure.core/ffirst\n     (All [x]\n          [(Option (Seqable (U nil (Seqable x)))) -> (Option x)])\n\nclojure.core/nfirst\n(All [x]\n     [(Option (Seqable (Option (Seqable x)))) -> (Option (NonEmptyASeq x))])\n\nclojure.core/fnext\n(All [x]\n     [(Option (Seqable (Option (Seqable x)))) -> (Option x)])\n\nclojure.core/nnext\n(All [x]\n     [(Option (Seqable x)) -> (Option (NonEmptyASeq x))])\n\nclojure.core/nthnext\n(All [x]\n     (IFn [nil AnyInteger -> nil]\n          [(Option (Seqable x)) AnyInteger -> (Option (NonEmptyASeq x))]))\n\nclojure.core/rest\n     (All [x]\n          [(Option (Seqable x)) -> (ASeq x)])\n\nclojure.core/last\n     (All [x]\n          (IFn [(NonEmptySeqable x) -> x]\n               [(Option (Seqable x)) -> (U nil x)]))\n\nclojure.core/butlast\n     (All [x]\n          [(Option (Seqable x)) -> (ASeq x)])\n\nclojure.core/next\n     (All [x]\n          (IFn [(Option (Coll x)) -> (Option (NonEmptyASeq x))\n               :filters {:then (& (is (CountRange 2) 0)\n                                  (! nil 0))\n                         :else (| (is (CountRange 0 1) 0)\n                                  (is nil 0))}]\n              [(Option (Seqable x)) -> (Option (NonEmptyASeq x))]))\n\nclojure.core/into\n      (All [x y]\n           (IFn [(Map x y) (U nil (Seqable (U nil (Seqable (IMapEntry x y)) (IMapEntry x y) '[x y]))) -> (Map x y)]\n               [(Vec x) (U nil (Seqable x)) -> (Vec x)]\n               [(Set x) (U nil (Seqable x)) -> (Set x)]\n               [(Coll Any) (U nil (Seqable Any)) -> (Coll Any)]))\n\nclojure.core/conj\n;     (All [e\n;           [Arg :< (TFn [[x :variance :covariant]] Any)]\n;           [Res :< (TFn [[x :variance :covariant]]\n;                     (Coll Any))]]\n;          (IFn [(clojure.lang.IPersistentCollection e Arg Res) (Arg e) (Arg e) * -> (Res e)]\n;              [nil e e * -> (clojure.lang.PersistentList e)]))\n\n\n     (All [x y]\n          (IFn [(IPersistentVector x) x x * -> (IPersistentVector x)]\n              [(APersistentMap x y)\n               (U nil (Seqable (IMapEntry x y)) (IMapEntry x y) '[x y])\n               (U nil (Seqable (IMapEntry x y)) (IMapEntry x y) '[x y]) *\n               -> (APersistentMap x y)]\n              [(IPersistentMap x y)\n               (U nil (Seqable (IMapEntry x y)) (IMapEntry x y) '[x y])\n               (U nil (Seqable (IMapEntry x y)) (IMapEntry x y) '[x y]) * -> (IPersistentMap x y)]\n              [(IPersistentSet x) x x * -> (IPersistentSet x)]\n              [(ASeq x) x x * -> (ASeq x)]\n              [nil x x * -> (clojure.lang.PersistentList x)]\n              [(Coll Any) Any Any * -> (Coll Any)]\n              ))\n\n; IPersistentCollection [[x :variance :covariant]\n;                        :conj-fn [conj-fn :kind (TFn [[x :variance :covariant]] (IPersistentCollection x))]\n;                        :empty-fn [empty-fn :kind (TFn [] (IPersistentCollection Nothing :count (ExactCount 0)))]]\n\n; clojure.core/conj\n;   (All [x conj-fn]\n;     [(IPersistentCollection x :conj-fn conj-fn) x -> (conj-fn x)]\n;     [nil x -> (PersistentList x)]\n;     [(U nil (IPersistentCollection x :conj-fn conj-fn)) x -> (U nil (conj-fn x))])\n\n; clojure.core/empty\n;   (All [x empty-fn]\n;      [(IPersistentCollection Any :empty-fn empty-fn) -> (empty-fn)]\n;      [nil -> nil]\n;      [(U nil (IPersistentCollection Any :empty-fn empty-fn)) -> (U nil (empty-fn))])\n\nclojure.core/find\n     (All [x y]\n          [(U nil (clojure.lang.Associative x y)) Any -> (U nil (HVec [x y]))])\n\n; same as clojure.lang.RT/get\nclojure.core/get\n     (All [x y]\n          (IFn \n            ;no default\n            [(U nil (Set x) (ILookup Any x)) Any -> (Option x)]\n            [(Option java.util.Map) Any -> Any]\n            [(Option String) Any -> (Option Character)]\n            ;default\n            [(U nil (Set x) (ILookup Any x)) Any y -> (U y x)]\n            [(Option java.util.Map) Any y -> (U y Any)]\n            [(Option String) Any y -> (U y Character)]\n            ))\n)\n    (h/var-mappings\n\nclojure.core/get-in\n    (IFn [Any (U nil (Seqable Any)) -> Any]\n        [Any (U nil (Seqable Any)) Any -> Any])\n\nclojure.core/assoc-in\n    [(U nil (Associative Any Any)) (Seqable Any) Any -> Any]\n\n;FIXME maps after the first can always be nil\nclojure.core/merge \n     (All [k v]\n          (IFn [nil * -> nil]\n              [(IPersistentMap k v) (IPersistentMap k v) * -> (IPersistentMap k v)]\n              [(Option (IPersistentMap k v)) * -> (Option (IPersistentMap k v))]))\n\n;more to be said here?\nclojure.core/contains? [(Option (Seqable Any)) Any -> Boolean]\n\nclojure.core/= [Any Any * -> (U true false)]\nclojure.core/identical? [Any Any -> Boolean]\nclojure.core/distinct? [Any Any * -> Boolean]\n\nclojure.core/decimal? (Pred BigDecimal)\n\nclojure.core/denominator [clojure.lang.Ratio -> Number]\n\nclojure.core/mod (IFn [AnyInteger AnyInteger -> AnyInteger]\n                      [Number Number -> Number])\n\nclojure.core/var-get (All [r] [(Var2 Nothing r) -> r])\nclojure.core/var-set (All [w] [(Var2 w Any) w -> w])\n\nclojure.core/supers [Class -> (U nil (I NonEmptyCount (Set Class)))]\n\nclojure.core/take-nth (All [x] [AnyInteger (U nil (Seqable x)) -> (ASeq x)])\n\nclojure.core/shuffle (All [x] \n                          (IFn [(I (Collection x) (Seqable x)) -> (Vec x)]\n                               [(Collection x) -> (Vec x)]))\n\nclojure.core/special-symbol? [Any -> Boolean]\n\nclojure.core/integer? (Pred AnyInteger)\nclojure.core/number? (Pred Number)\nclojure.core/var? (Pred (Var2 Nothing Any))\nclojure.core/class? (Pred Class)\n\nclojure.core/resolve (IFn [Symbol -> (U (Var2 Nothing Any) Class nil)]\n                         ; should &env arg be more accurate?\n                         [Any Symbol -> (U (Var2 Nothing Any) Class nil)])\n\nclojure.core/ns-resolve (IFn [(U Symbol Namespace) Symbol -> (U (Var2 Nothing Any) Class nil)]\n                            ; should &env arg be more accurate?\n                            [(U Symbol Namespace) Any Symbol -> (U (Var2 Nothing Any) Class nil)])\n\nclojure.core/extenders [Any -> (U nil (Seqable (U Class nil)))]\n\nclojure.core/+ (IFn [Long * -> Long]\n                    [(U Long Double) * -> Double]\n                    [AnyInteger * -> AnyInteger]\n                    [Number * -> Number])\nclojure.core/- (IFn [Long Long * -> Long]\n                    [(U Long Double) (U Long Double) * -> Double]\n                    [AnyInteger AnyInteger * -> AnyInteger]\n                    [Number Number * -> Number])\nclojure.core/* (IFn [Long * -> Long]\n                    [(U Long Double) * -> Double]\n                    [AnyInteger * -> AnyInteger]\n                    [Number * -> Number])\nclojure.core// (IFn [Double Double * -> Double]\n                    [Number Number * -> Number])\n\nclojure.core/+' (IFn [AnyInteger * -> AnyInteger]\n                     [Number * -> Number])\nclojure.core/-' (IFn [AnyInteger AnyInteger * -> AnyInteger]\n                     [Number Number * -> Number])\nclojure.core/*' (IFn [AnyInteger * -> AnyInteger]\n                    [Number * -> Number])\nclojure.core/quot (IFn [Long Long -> Long]\n                       [(U Long Double) (U Long Double) -> Double]\n                       [AnyInteger AnyInteger -> AnyInteger] \n                       [Number Number -> Number])\n\nclojure.core/unchecked-inc (IFn [AnyInteger -> AnyInteger]\n                                [Number -> Number])\nclojure.core/unchecked-inc-int [Number -> AnyInteger]\nclojure.core/unchecked-dec (IFn [AnyInteger -> AnyInteger]\n                                [Number -> Number])\nclojure.core/unchecked-dec-int [Number -> AnyInteger]\nclojure.core/unchecked-subtract (IFn [AnyInteger AnyInteger -> AnyInteger]\n                                     [Number Number -> Number])\nclojure.core/unchecked-subtract-int [Number Number -> AnyInteger]\nclojure.core/unchecked-negate (IFn [AnyInteger -> AnyInteger]\n                                   [Number -> Number])\nclojure.core/unchecked-negate-int [Number -> AnyInteger]\nclojure.core/unchecked-add (IFn [AnyInteger AnyInteger -> AnyInteger]\n                                [Number Number -> Number])\nclojure.core/unchecked-add-int [Number Number -> AnyInteger]\nclojure.core/unchecked-multiply (IFn [AnyInteger AnyInteger -> AnyInteger]\n                                     [Number Number -> Number])\nclojure.core/unchecked-multiply-int [Number Number -> AnyInteger]\nclojure.core/unchecked-divide-int [Number Number -> AnyInteger]\nclojure.core/unchecked-remainder-int [Number Number -> AnyInteger]\nclojure.core/inc (IFn [Long -> Long]\n                      [Double -> Double]\n                      [AnyInteger -> AnyInteger]\n                      [Number -> Number])\nclojure.core/dec (IFn [Long -> Long]\n                      [Double -> Double]\n                      [AnyInteger -> AnyInteger]\n                      [Number -> Number])\n\nclojure.core/inc' (IFn [AnyInteger -> AnyInteger]\n                       [Number -> Number])\nclojure.core/dec' (IFn [AnyInteger -> AnyInteger]\n                          [Number -> Number])\n\nclojure.core/rationalize [Number -> Number]\n\nclojure.core/bit-not [AnyInteger -> AnyInteger]\nclojure.core/bit-and [AnyInteger AnyInteger AnyInteger * -> AnyInteger]\nclojure.core/bit-or [AnyInteger AnyInteger AnyInteger * -> AnyInteger]\nclojure.core/bit-xor [AnyInteger AnyInteger AnyInteger * -> AnyInteger]\nclojure.core/bit-and-not [AnyInteger AnyInteger AnyInteger * -> AnyInteger]\nclojure.core/bit-clear [AnyInteger AnyInteger -> AnyInteger]\nclojure.core/bit-set [AnyInteger AnyInteger -> AnyInteger]\nclojure.core/bit-flip [AnyInteger AnyInteger -> AnyInteger]\nclojure.core/bit-test [AnyInteger AnyInteger -> AnyInteger]\nclojure.core/bit-shift-left [AnyInteger AnyInteger -> AnyInteger]\nclojure.core/bit-shift-right [AnyInteger AnyInteger -> AnyInteger]\nclojure.core/unsigned-bit-shift-right [AnyInteger AnyInteger -> AnyInteger]\n\nclojure.core/even? [AnyInteger -> Boolean]\nclojure.core/odd? [AnyInteger -> Boolean]\n\nclojure.core/peek (All [x]\n                       (IFn [(I NonEmptyCount (Stack x)) -> x]\n                           [(Stack x) -> x]))\nclojure.core/pop (All [x]\n                      (IFn\n                        [(List x) -> (List x)]\n                        [(Vec x) -> (Vec x)]\n                        [(Stack x) -> (Stack x)]))\n\nclojure.core/get-thread-bindings\n    [-> (Map (Var2 Nothing Any) Any)]\nclojure.core/bound-fn*\n    (All [r b ...]\n         [[b ... b -> r] -> [b ... b -> r]])\n\nclojure.core/find-var\n    [Symbol -> (U nil (Var2 Nothing Any))]\n\nclojure.core/agent\n    (All [x] [x & :optional {:validator (U nil [x -> Any]) :meta Any\n                             :error-handler (U nil [(Agent1 x) Throwable -> Any])\n                             :error-mode (U ':continue ':fail)} \n              -> (Agent1 x)])\n\nclojure.core/set-agent-send-executor!\n    [java.util.concurrent.ExecutorService -> Any]\n\nclojure.core/set-agent-send-off-executor!\n    [java.util.concurrent.ExecutorService -> Any]\n\nclojure.core/send-via (All [w r b ...] \n                           [(Agent2 w r) [r b ... b -> w] b ... b -> (Agent2 w r)])\n\nclojure.core/send (All [w r b ...] \n                           [(Agent2 w r) [r b ... b -> w] b ... b -> (Agent2 w r)])\n\nclojure.core/send-off (All [w r b ...] \n                           [(Agent2 w r) [r b ... b -> w] b ... b -> (Agent2 w r)])\n\nclojure.core/await [(Agent2 Nothing Any) * -> nil]\nclojure.core/await-for [AnyInteger (Agent2 Nothing Any) * -> Boolean]\nclojure.core/await1 (All [w r] [(Agent2 w r) -> (Agent2 w r)])\n\nclojure.core/release-pending-sends [-> AnyInteger]\n\nclojure.core/add-watch\n        (All [x [a :< (IRef Nothing x)]]\n             (IFn \n               ; this arity remembers the type of reference we pass to the function\n               [a Any [Any a x x -> Any] -> Any]\n               ; if the above cannot be inferred, \n               [(IRef Nothing x) Any [Any (IRef Nothing x) x x -> Any] -> Any]))\n\nclojure.core/remove-watch [(IRef Nothing Any) Any -> Any]\n\nclojure.core/agent-error [(Agent2 Nothing Any) -> (U nil Throwable)]\n\nclojure.core/restart-agent\n(All [w]\n     ; w is invariant\n     [(Agent2 w Any) w & :optional {:clear-actions Any} -> Any])\n\nclojure.core/set-error-handler!\n(All [w r]\n    [(Agent2 w r) [(Agent2 w r) Throwable -> Any] -> Any])\n\nclojure.core/error-handler\n(All [w r]\n    [(Agent2 w r) -> (U nil [(Agent2 w r) Throwable -> Any])])\n\nclojure.core/set-error-mode!\n    [(Agent2 Nothing Any) (U ':fail ':continue) -> Any]\n\nclojure.core/error-mode\n    [(Agent2 Nothing Any) -> Any]\n\nclojure.core/agent-errors\n    [(Agent2 Nothing Any) -> (U nil (ASeq Throwable))]\nclojure.core/clear-agent-errors\n    [(Agent2 Nothing Any) -> Any]\n\nclojure.core/shutdown-agents [-> Any]\n\nclojure.core/take\n     (All [x]\n       [AnyInteger (U nil (Seqable x)) -> (ASeq x)])\n\nclojure.core/drop\n     (All [x]\n       [AnyInteger (U nil (Seqable x)) -> (ASeq x)])\n\nclojure.core/take-last\n     (All [x]\n       [AnyInteger (U nil (Seqable x)) -> (NilableNonEmptyASeq x)])\n\nclojure.core/drop-last\n     (All [x]\n       [AnyInteger (U nil (Seqable x)) -> (ASeq x)])\n\nclojure.core/hash [Any -> AnyInteger]\nclojure.core/hash-combine [AnyInteger Any -> AnyInteger]\n\nclojure.core/ifn? (Pred clojure.lang.IFn)\nclojure.core/fn? (Pred t/Fn)\n\nclojure.core/instance? [Class Any -> Boolean]\n\nclojure.core/cons\n     (All [x]\n       [x (Option (Seqable x)) -> (ASeq x)])\n\nclojure.core/reverse\n     (All [x]\n       [(Option (Seqable x)) -> (ASeq x)])\n\nclojure.core/rseq\n     (All [x]\n       [(clojure.core.typed/Reversible x) -> (Option (NonEmptyASeq x))])\n\n;coercions\n;TODO maybe these argument type shouldn't be Any\nclojure.core/bigdec [Number -> BigDecimal]\nclojure.core/bigint [Number -> clojure.lang.BigInt]\nclojure.core/biginteger [Number -> java.math.BigInteger]\nclojure.core/boolean [Any -> Boolean]\nclojure.core/byte [Any -> Byte]\nclojure.core/char [Any -> Character]\nclojure.core/double [Any -> Double]\nclojure.core/float [Any -> Float]\nclojure.core/int [Any -> Integer]\nclojure.core/long [Any -> Long]\nclojure.core/num [Any -> Number]\nclojure.core/short [Any -> Short]\n\n;array ctors\nclojure.core/boolean-array (IFn [(U nil Number (Seqable Boolean)) -> (Array boolean)]\n                                    [Number (U nil Boolean (Seqable Boolean)) -> (Array boolean)])\nclojure.core/byte-array (IFn [(U nil Number (Seqable Byte)) -> (Array byte)]\n                                 [Number (U nil Byte (Seqable Byte)) -> (Array byte)])\nclojure.core/char-array (IFn [(U nil Number (Seqable Character)) -> (Array char)]\n                            [Number (U nil Number (Seqable Character)) -> (Array char)])\nclojure.core/short-array (IFn [(U nil Number (Seqable Short)) -> (Array short)]\n                                  [Number (U nil Short (Seqable Short)) -> (Array short)])\nclojure.core/int-array (IFn [(U nil Number (Seqable Number)) -> (Array int)]\n                                [Number (U nil Number (Seqable Number)) -> (Array int)])\nclojure.core/double-array (IFn [(U nil Number (Seqable Number)) -> (Array double)]\n                                   [Number (U nil Number (Seqable Number)) -> (Array double)])\n\n;cast to java array\nclojure.core/booleans [Any -> (Array boolean)]\nclojure.core/bytes [Any -> (Array byte)]\nclojure.core/chars [Any -> (Array char)]\nclojure.core/shorts [Any -> (Array short)]\nclojure.core/ints [Any -> (Array int)]\nclojure.core/longs [Any -> (Array long)]\nclojure.core/floats [Any -> (Array float)]\nclojure.core/doubles [Any -> (Array double)]\n\nclojure.core/max-key (All [x] \n                          [[x -> Number] x x x * -> x])\nclojure.core/min-key (All [x] \n                          [[x -> Number] x x x * -> x])\n\nclojure.core/< [Number Number * -> Boolean]\n\nclojure.core/<= [Number Number * -> Boolean]\n\nclojure.core/> [Number Number * -> Boolean]\n\nclojure.core/>= [Number Number * -> Boolean]\n\nclojure.core/== [Number Number * -> Boolean]\n\nclojure.core/max [Number Number * -> Number]\nclojure.core/min [Number Number * -> Number]\n\nclojure.core/ref (All [x] [x & :optional {:validator (U nil [x -> Any]) :meta (U nil (Map Any Any))\n                                          :min-history (U nil AnyInteger)\n                                          :max-history (U nil AnyInteger)}\n                           -> (clojure.lang.Ref x x)])\n\nclojure.core/rand (IFn [-> Number]\n                      [Number -> Number])\n\nclojure.core/rand-int [Int -> Int]\n\nclojure.core/ex-info (IFn [(U nil String) (Map Any Any) -> ExInfo]\n                         [(U nil String) (Map Any Any) (U nil Throwable) -> ExInfo])\n\nclojure.core/ex-data (IFn [ExInfo -> (Map Any Any)]\n                         [Any -> (U nil (Map Any Any))])\n\n\n;; START CHUNK HACKS\n;; These are hacks to get around the expansion of doseq>\n;; Basically, inference isn't good enough to narrow a (Seqable x) to \n;; an (IChunk x), because chunked-seq? needs to be (Pred (IChunk Any)).\nclojure.core/chunked-seq? [Any -> Any]\nclojure.core/chunk-first \n     (All [x]\n          ;should be IChunkedSeq -> IChunk\n          [(Seqable x) -> (clojure.lang.IChunk x)])\nclojure.core/chunk-rest\n     (All [x]\n          ;should be IChunkRest -> Seq\n          [(clojure.lang.Seqable x) -> (ASeq x)])\nclojure.core/chunk-buffer\n     (All [x]\n          [(U Integer Long) -> (clojure.lang.ChunkBuffer x)])\nclojure.core/chunk\n     (All [x]\n          [(clojure.lang.ChunkBuffer x) -> (clojure.lang.IChunk x)])\nclojure.core/chunk-cons\n     (All [x]\n          [(clojure.lang.IChunk x) (Option (Seqable x)) -> (Option (Seqable x))])\nclojure.core/chunk-append\n     (All [x]\n          [(clojure.lang.ChunkBuffer x) x -> Any])\n;;END CHUNK HACKS\n\n\nclojure.core/subvec (All [x] \n                     (IFn [(Vec x) AnyInteger -> (Vec x)]\n                         [(Vec x) AnyInteger AnyInteger -> (Vec x)]))\n\nclojure.core/alias [Symbol Symbol -> nil]\nclojure.core/all-ns [-> (Nilable (NonEmptyASeq Namespace))]\n\nclojure.core/*file* String\nclojure.core/*command-line-args* (U nil (NonEmptyASeq String))\nclojure.core/*warn-on-reflection* Boolean\nclojure.core/*compile-path* String\nclojure.core/*compile-files* Boolean\nclojure.core/*unchecked-math* Boolean\nclojure.core/*compiler-options* (Map Any Any)\nclojure.core/*in* java.io.Reader\nclojure.core/*out* java.io.Writer\nclojure.core/*err* java.io.Writer\nclojure.core/*flush-on-newline* Boolean\nclojure.core/*print-meta* Boolean\nclojure.core/*print-dup* Boolean\nclojure.core/*print-readably* Boolean\nclojure.core/*read-eval* (U ':unknown Boolean)\n\nclojure.core/trampoline \n       (All [r b ...]\n         [[b ... b -> (Rec [f] (U r [-> (U f r)]))]\n          b ... b -> r])\n\n\n;; math.numeric-tower\n\nclojure.math.numeric-tower/floor\n(IFn [AnyInteger -> AnyInteger]\n    [Number -> Number])\n\nclojure.math.numeric-tower/abs\n(IFn [AnyInteger -> AnyInteger]\n    [Number -> Number])\n\n;; core.match\n\nclojure.core.match/backtrack Exception\n\nclojure.core/eval [Any -> Any]\nclojure.core/rand-nth (All [x] [(U (Indexed x) (SequentialSeqable x)) -> x])\n\n      )\n(h/var-mappings\nclojure.set/union (All [x] [(Set x) * -> (Set x)])\nclojure.set/intersection (All [x] [(Set x) (Set x) * -> (Set x)])\nclojure.set/difference (All [x] [(Set x) (Set Any) * -> (Set x)])\n\nclojure.repl/pst (IFn [-> nil]\n                      [(U Int Throwable) -> nil]\n                      [Throwable Int -> nil])\n  )\n    {'clojure.core/count (count-type)\n     'clojure.core/aset-boolean (aset-*-type 'boolean)\n     'clojure.core/aset-byte (aset-*-type 'byte)\n     'clojure.core/aset-char (aset-*-type 'char)\n     'clojure.core/aset-short (aset-*-type 'short)\n     'clojure.core/aset-int (aset-*-type 'int)\n     'clojure.core/aset-long (aset-*-type 'long)\n     'clojure.core/aset-float (aset-*-type 'float)\n     'clojure.core/aset-double (aset-*-type 'double)\n     'clojure.core/nth (nth-type)\n     }\n))", :ns "clojure.core.typed.base-env", :name "thread-bindings-init-var-env", :file "clojure/core/typed/base_env.clj", :column 1, :line 118}
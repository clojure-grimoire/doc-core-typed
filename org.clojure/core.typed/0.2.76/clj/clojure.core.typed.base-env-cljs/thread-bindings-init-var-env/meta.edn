{:type :var, :src "(delay-and-cache-env ^:private init-var-env\n  (reset-protocol-env!)\n  (reset-jsnominal-env!)\n  (merge\n   (common/parse-cljs-ann-map common/common-var-annotations)\n   (h/var-mappings\n\n;internal vars\ncljs.core.typed/ann* [Any Any -> Any]\ncljs.core.typed/ann-protocol* [Any Any Any -> Any]\ncljs.core.typed/ann-datatype* [Any Any Any Any -> Any]\ncljs.core.typed/def-alias* [Any Any -> Any]\ncljs.core.typed/typed-deps* [Any -> Any]\ncljs.core.typed/ann-jsnominal* [Any Any -> Any]\n\ncljs.core/+ (IFn [int * -> int]\n                 [number * -> number])\ncljs.core/+ (IFn [int * -> int]\n                 [number * -> number])\ncljs.core/- (IFn [int * -> int]\n                 [number * -> number])\ncljs.core/* (IFn [int * -> int]\n                 [number * -> number])\ncljs.core/nth (All [x y]\n                (IFn [(U nil (cljs.core/ISeqable x)) int -> x]\n                      [(U nil (cljs.core/ISeqable x)) int y -> (U y x)]))\n\ncljs.core/*flush-on-newline* boolean\ncljs.core/*print-newline* boolean\ncljs.core/*print-readably* boolean\ncljs.core/*print-meta* boolean\ncljs.core/*print-dup* boolean\ncljs.core/*print-length* (U nil int)\n\ncljs.core/enable-console-print! [-> Any]\n\ncljs.core/truth_ [Any -> Any]\n\ncljs.core/coercive-= [Any Any -> boolean]\n\ncljs.core/nil? (Pred nil)\n\ncljs.core/array? (ReadOnlyArray Any)\n\ncljs.core/object? [Any -> boolean]\n\ncljs.core/native-satisfies? [Any Any -> Any]\n\ncljs.core/is_proto_ [Any -> Any]\n\ncljs.core/*main-cli-fn* (U nil [Any * -> Any])\n\ncljs.core/missing-protocol [Any Any -> Any]\ncljs.core/type->str [Any -> string]\n\ncljs.core/make-array (All [r] \n                          (IFn [int -> (Array r)]\n                               [Any int -> (Array r)]))\n\ncljs.core/array (All [r]\n                     [r * -> (Array r)])\n\ncljs.core/alength [(ReadOnlyArray Any) -> int]\n\ncljs.core/into-array (All [x] \n                          (IFn [(U nil (cljs.core/ISeqable x)) -> (Array x)]\n                              [Any (U nil (cljs.core/ISeqable x)) -> (Array x)]))\n\ncljs.core/pr-str* [Any -> string]\n\ncljs.core/clone [Any -> Any]\n\ncljs.core/cloneable? (Pred cljs.core/ICloneable)\n\n\ncljs.core/count\n      ; TODO also accepts Counted\n      ; FIXME should return integer\n      [(U nil (cljs.core/ISeqable Any)) -> int :object {:id 0, :path [Count]}]\ncljs.core/prim-seq\n      (All [x]\n           [(cljs.core/ISeqable x) -> (U nil (cljs.core/ISeq x))])\n\ncljs.core/key-test [Keyword Any -> boolean]\n\ncljs.core/fn? [Any -> boolean]\ncljs.core/ifn? [Any -> boolean]\n\n;;pop needs to be defined here because\n;;definition of List differs between clj and cljs\ncljs.core/pop (All [x]\n                      (IFn\n                        [(IList x) -> (IList x)]\n                        [(Vec x) -> (Vec x)]\n                        [(Stack x) -> (Stack x)]))\n\ncljs.core/clj->js [Any -> Any]\ncljs.core/js->clj [Any -> Any]\ncljs.core/js-obj  [Any * -> Any]\n\n;;pseudo-private vars\ncljs.core/-conj [Any Any -> Any]\n;cljs.core.List.Empty (IList Any)\n)))", :ns "clojure.core.typed.base-env-cljs", :name "thread-bindings-init-var-env", :file "clojure/core/typed/base_env_cljs.clj", :column 1, :line 119}
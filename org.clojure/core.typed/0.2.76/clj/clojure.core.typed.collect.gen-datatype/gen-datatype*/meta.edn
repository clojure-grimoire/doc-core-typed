{:type :fn, :src "(defn gen-datatype* [current-env current-ns provided-name fields vbnd opt record?]\n  {:pre [(symbol? current-ns)]}\n  (impl/with-clojure-impl\n    (let [{ancests :unchecked-ancestors} opt\n          ancests (or ancests (:extends opt))\n          parsed-binders (when vbnd\n                           (binding [prs/*parse-type-in-ns* current-ns]\n                             (prs/parse-free-binder-with-variance vbnd)))\n          ;variances\n          vs (seq (map :variance parsed-binders))\n          args (seq (map :fname parsed-binders))\n          bnds (seq (map :bnd parsed-binders))]\n      (let [provided-name-str (str provided-name)\n            ;_ (prn \"provided-name-str\" provided-name-str)\n            munged-ns-str (if (some #(= \\. %) provided-name-str)\n                            (apply str (butlast (apply concat (butlast (partition-by #(= \\. %) provided-name-str)))))\n                            (str (munge current-ns)))\n            ;_ (prn \"munged-ns-str\" munged-ns-str)\n            demunged-ns-str (str (repl/demunge munged-ns-str))\n            ;_ (prn \"demunged-ns-str\" demunged-ns-str)\n            local-name (if (some #(= \\. %) provided-name-str)\n                         (symbol (apply str (last (partition-by #(= \\. %) (str provided-name-str)))))\n                         provided-name-str)\n            ;_ (prn \"local-name\" local-name)\n            s (symbol (str munged-ns-str \\. local-name))\n            fs (apply array-map (apply concat (free-ops/with-frees (mapv r/make-F args)\n                                                (binding [vs/*current-env* current-env\n                                                          prs/*parse-type-in-ns* current-ns]\n                                                  (mapv parse-field (partition 3 fields))))))\n            as (set (free-ops/with-frees (mapv r/make-F args)\n                      (binding [vs/*current-env* current-env\n                                prs/*parse-type-in-ns* current-ns]\n                        (mapv (comp #(c/abstract-many args %) prs/parse-type) ancests))))\n            ;_ (prn \"collected ancestors\" as)\n            _ (ancest/add-datatype-ancestors s as)\n            pos-ctor-name (symbol demunged-ns-str (str \"->\" local-name))\n            map-ctor-name (symbol demunged-ns-str (str \"map->\" local-name))\n            dt (c/DataType* args vs (map r/make-F args) s bnds fs record?)\n            _ (dt-env/add-datatype s dt)\n            pos-ctor (if args\n                       (c/Poly* args bnds\n                                (r/make-FnIntersection\n                                  (r/make-Function (vec (vals fs)) (c/DataType-of s (map r/make-F args)))))\n                       (r/make-FnIntersection\n                         (r/make-Function (vec (vals fs)) (c/DataType-of s))))\n            map-ctor (when record?\n                       (let [hmap-arg ; allow omission of keys if nil is allowed and field is monomorphic\n                             (let [{optional true mandatory false} \n                                   (group-by (fn [[_ t]] (and (empty? (frees/fv t))\n                                                              (empty? (frees/fi t))\n                                                              (sub/subtype? r/-nil t)))\n                                             (zipmap (map (comp r/-val keyword) (keys fs))\n                                                     (vals fs)))]\n                               (c/make-HMap :optional (into {} optional)\n                                            :mandatory (into {} mandatory)))]\n                         (if args\n                           (c/Poly* args bnds\n                                    (r/make-FnIntersection\n                                      (r/make-Function [hmap-arg] (c/DataType-of s (map r/make-F args)))))\n                           (r/make-FnIntersection\n                             (r/make-Function [hmap-arg] (c/DataType-of s))))))]\n        (do \n          ;(when vs\n          ;  (let [f (mapv r/make-F (repeatedly (count vs) gensym))]\n          ;    ;TODO replacements and unchecked-ancestors go here\n          ;    (rcls/alter-class* s (c/RClass* (map :name f) vs f s {} {} bnds))))\n          (var-env/add-var-type pos-ctor-name pos-ctor)\n          (var-env/add-nocheck-var pos-ctor-name)\n          (when record?\n            (override/add-method-override (symbol (str s) \"create\") map-ctor)\n            (var-env/add-var-type map-ctor-name map-ctor)))))))", :ns "clojure.core.typed.collect.gen-datatype", :name "gen-datatype*", :file "clojure/core/typed/collect/gen_datatype.clj", :column 1, :line 19, :arglists ([current-env current-ns provided-name fields vbnd opt record?])}
{:type :fn, :src "(defn Type->array-member-Class \n  ([ty] (Type->array-member-Class ty false))\n  ([ty nilok?]\n   {:pre [(r/Type? ty)]}\n   (cond\n     (c/requires-resolving? ty) (Type->array-member-Class (c/-resolve ty) nilok?)\n     (r/Nil? ty) (if nilok?\n                 nil\n                 Object)\n     (r/Value? ty) (c/Value->Class ty)\n     ;; handles most common case of (U nil Type)\n     (r/Union? ty) (let [clss (map #(Type->array-member-Class % true) (:types ty))\n                         prim-and-nil? (and (some nil? clss)\n                                            (some #(when % (.isPrimitive ^Class %)) clss))\n                         nonil-clss (remove nil? clss)]\n                     (if (and (= 1 (count nonil-clss))\n                              (not prim-and-nil?))\n                       (first nonil-clss)\n                       Object))\n     (r/Intersection? ty) Object\n     (r/RClass? ty) (r/RClass->Class ty)\n     (r/PrimitiveArray? ty) (class (make-array (Type->array-member-Class (:jtype ty) false) 0))\n     :else Object)))", :ns "clojure.core.typed.array-ops", :name "Type->array-member-Class", :file "clojure/core/typed/array_ops.clj", :column 1, :line 14, :arglists ([ty] [ty nilok?])}
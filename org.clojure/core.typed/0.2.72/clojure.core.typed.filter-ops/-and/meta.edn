{:type :fn, :src "(defn -and [& args]\n  {:pre [(every? fr/Filter? args)]\n   :post [(fr/Filter? %)]}\n  (letfn [(mk [& fs]\n            {:pre [(every? fr/Filter? fs)]\n             :post [(fr/Filter? %)]}\n            (cond\n              (empty? fs) fr/-top\n              (= 1 (count fs)) (first fs)\n              :else (apply fr/make-AndFilter fs)))]\n    (loop [fs (set args)\n           result nil]\n      (if (empty? fs)\n        (cond\n          (empty? result) fr/-top\n          (= 1 (count result)) (first result)\n          ;; don't think this is useful here\n          (= 2 (count result)) (let [;_ (prn \"hit special 2 case in -and\")\n                                     [f1 f2] result]\n                                 (if (opposite? f1 f2)\n                                   fr/-bot\n                                   (if (= f1 f2)\n                                     f1\n                                     (apply mk (compact [f1 f2] false)))))\n          :else\n           ;; first, remove anything implied by the atomic propositions\n           ;; We commonly see: (And (Or P Q) (Or P R) (Or P S) ... P), which this fixes\n           (p/p :filter-ops/-and-base-case\n          (let [{atomic true not-atomic false} (group-by atomic-filter? result)\n                ;_ (prn \"not-atomic\" (map clojure.core.typed.parse-unparse/unparse-filter not-atomic))\n                not-atomic* (for [p not-atomic\n                                  :when (not-any? (fn [a] (implied-atomic? p a)) atomic)]\n                              p)]\n            ;(prn \"not-atomic*\" (map clojure.core.typed.parse-unparse/unparse-filter not-atomic*))\n             ;; `compact' takes care of implications between atomic props\n            (apply mk (compact (concat not-atomic* atomic) false)))))\n        (let [ffs (first fs)]\n          (cond\n            (fr/BotFilter? ffs) ffs\n            (fr/AndFilter? ffs) (let [fs* (:fs ffs)]\n                                  (recur (next fs) (concat fs* result)))\n            (fr/TopFilter? ffs) (recur (next fs) result)\n            :else (let [t ffs]\n                    (cond\n                      (some (fn [f] (opposite? f ffs)) (concat (rest fs) result)) \n                      fr/-bot\n                      (some (fn [f] (or (= f t)\n                                        (implied-atomic? t f))) result) \n                      (recur (rest fs) result)\n                      :else\n                      (recur (rest fs) (cons t result))))))))))", :ns "clojure.core.typed.filter-ops", :name "-and", :file "clojure/core/typed/filter_ops.clj", :column 1, :line 355, :arglists ([& args])}
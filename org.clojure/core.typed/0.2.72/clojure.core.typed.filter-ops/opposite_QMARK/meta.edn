{:type :fn, :src "(defn opposite? [f1 f2]\n  {:pre [(fr/Filter? f1)\n         (fr/Filter? f2)]\n   :post [(con/boolean? %)]}\n  (let [subtype? @(subtype?-var)]\n    (cond\n      (and (fr/TypeFilter? f1)\n           (fr/NotTypeFilter? f2))\n      (let [{t1 :type p1 :path i1 :id} f1\n            {t2 :type p2 :path i2 :id} f2]\n        (and (= p1 p2)\n             (= i1 i2)\n             (subtype? t1 t2)))\n\n      (and (fr/NotTypeFilter? f1)\n           (fr/TypeFilter? f2))\n      (let [{t2 :type p2 :path i2 :id} f1\n            {t1 :type p1 :path i1 :id} f2]\n        (and (= p1 p2)\n             (= i1 i2)\n             (subtype? t1 t2)))\n      :else false)))", :ns "clojure.core.typed.filter-ops", :name "opposite?", :file "clojure/core/typed/filter_ops.clj", :column 1, :line 54, :arglists ([f1 f2])}
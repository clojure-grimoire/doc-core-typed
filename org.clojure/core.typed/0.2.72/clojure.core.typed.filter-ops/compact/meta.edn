{:type :fn, :src "(defn compact [props or?]\n  {:pre [(every? fr/Filter? props)\n         (con/boolean? or?)]\n   :post [(every? fr/Filter? %)]}\n;  (prn \"compact\")\n;  (prn \"props\" (map clojure.core.typed.parse-unparse/unparse-filter props))\n;  (prn \"or?\" or?)\n  (let [tf-map (atom {})\n        ntf-map (atom {})]\n    ;; props: the propositions we're processing\n    ;; others: props that are neither TF or NTF\n    (loop [props props\n           others nil]\n      (if (empty? props)\n        (concat others\n                (vals @tf-map)\n                (vals @ntf-map))\n        (cond\n          (and or? (fr/TypeFilter? (first props)))\n          (let [{t1 :type f1 :path x :id :as p} (first props)]\n            (swap! tf-map (fn [m] (update-in m [[f1 x]] #(if %\n                                                           (if (fr/TypeFilter? %)\n                                                             (let [t2 (:type %)]\n                                                               (-filter (c/Un t1 t2) x f1))\n                                                             (throw (Exception. (str \"got something that isn't a type filter\" p))))\n                                                           p))))\n            (recur (rest props) others))\n\n          (and (not or?) (fr/TypeFilter? (first props)))\n          (let [{t1 :type f1 :path x :id} (first props)\n                fl (@tf-map [f1 x])]\n            (cond\n              (and (fr/TypeFilter? fl)\n                   (let [t2 (:type fl)]\n                     (not (c/overlap t1 (:type fl)))))\n              ;; we're in an And, and we got two types for the same path that do not overlap\n              [fr/-bot]\n              (fr/TypeFilter? fl)\n              (let [t2 (:type fl)]\n                (swap! tf-map (fn [m] (assoc m [f1 x] (-filter (c/restrict t1 t2) x f1))))\n                (recur (next props) others))\n              :else\n              (do \n                (swap! tf-map (fn [m] (assoc m [f1 x] (-filter t1 x f1))))\n                (recur (next props) others))))\n\n          (and (not or?) \n               (fr/NotTypeFilter? (first props)))\n          (let [{t1 :type f1 :path x :id :as p} (first props)]\n            (swap! ntf-map (fn [m] (update-in m [[f1 x]]\n                                              (fn [n]\n                                                (if n\n                                                  (if (fr/NotTypeFilter? n)\n                                                    (let [t2 (:type n)]\n                                                      (-not-filter (c/Un t1 t2) x f1))\n                                                    (throw (Exception. (str \"got something that isn't a nottypefilter\" p))))\n                                                  p)))))\n            (recur (next props) others))\n          :else\n          (let [p (first props)]\n            (recur (next props) (cons p others))))))))", :ns "clojure.core.typed.filter-ops", :name "compact", :file "clojure/core/typed/filter_ops.clj", :column 1, :line 81, :arglists ([props or?])}
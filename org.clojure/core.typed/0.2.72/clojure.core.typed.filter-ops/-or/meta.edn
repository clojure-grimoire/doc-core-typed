{:type :fn, :src "(defn -or [& args]\n  {:pre [(every? fr/Filter? args)]\n   :post [(fr/Filter? %)]}\n  (letfn [(mk [& fs]\n            {:pre [(every? fr/Filter? fs)]\n             :post [(fr/Filter? %)]}\n            (p/p :filter-ops/-or-mk\n            (cond\n              (empty? fs) fr/-bot\n              (= 1 (count fs)) (first fs)\n              :else (fr/OrFilter-maker (set fs)))))\n          (distribute [args]\n            (p/p :filter-ops/-or-distribute\n            (let [{ands true others false} (group-by fr/AndFilter? args)]\n              (if (empty? ands)\n                (apply mk others)\n                (let [{elems :fs} (first ands)] ;an AndFilter\n                  (apply -and (for [a elems]\n                                (apply -or a (concat (next ands) others)))))))))]\n    (loop [fs args\n           result nil]\n      (assert (every? fr/Filter? fs))\n      (assert (every? fr/Filter? result))\n      (if (empty? fs)\n        (cond\n          (empty? result) fr/-bot\n          (= 1 (count result)) (first result)\n          :else (distribute (compact result true)))\n        (cond\n          (fr/TopFilter? (first fs)) (first fs)\n          (fr/OrFilter? (first fs)) (let [fs* (:fs (first fs))]\n                                      (recur (concat fs* (next fs)) result))\n          (fr/BotFilter? (first fs)) (recur (next fs) result)\n          :else (let [t (first fs)]\n                  (assert (fr/Filter? t))\n                  (cond \n                    (some (fn [f] (opposite? f t)) (concat (rest fs) result))\n                    fr/-top\n                    (some (fn [f] (or (= f t)\n                                      (implied-atomic? f t)))\n                          result)\n                    (recur (next fs) result)\n                    :else\n                    (recur (next fs) (cons t result)))))))))", :ns "clojure.core.typed.filter-ops", :name "-or", :file "clojure/core/typed/filter_ops.clj", :column 1, :line 278, :arglists ([& args])}
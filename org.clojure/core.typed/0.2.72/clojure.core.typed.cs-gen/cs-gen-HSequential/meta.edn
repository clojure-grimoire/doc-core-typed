{:type :fn, :src "(defn cs-gen-HSequential\n  [V X Y S T]\n  {:pre [(r/HSequential? S)\n         (r/HSequential? T)]\n   :post [(cr/cset? %)]}\n  (cset-meet* (concat\n                (cond\n                  ;simple case\n                  (not-any? (some-fn :rest :drest) [S T])\n                  [(cs-gen-list V X Y (:types S) (:types T))]\n\n                  ;rest on right, optionally on left\n                  (and (:rest T)\n                       (not (:drest S)))\n                  (concat [(cs-gen-list V X Y (:types S) (concat (:types T)\n                                                                 (repeat (- (count (:types S))\n                                                                            (count (:types T)))\n                                                                         (:rest T))))]\n                          (when (:rest S)\n                            [(cs-gen V X Y (:rest S) (:rest T))]))\n\n                  ;; dotted on the left, nothing on the right\n                  (and (:drest S)\n                       (not-any? (some-fn :rest :drest) [T]))\n                  (let [{dty :pre-type dbound :name} (:drest S)]\n                    (when-not (Y dbound)\n                      (fail! S T))\n                    (when-not (<= (count (:types S)) (count (:types T)))\n                      (fail! S T))\n                    (let [vars (var-store-take dbound dty (- (count (:types T))\n                                                             (count (:types S))))\n                          new-tys (doall (t/for\n                                           [var :- t/Sym, vars] :- r/AnyType\n                                           (subst/substitute (r/make-F var) dbound dty)))\n                          new-s-hsequential (r/-hsequential (concat (:types S) new-tys))\n                          new-cset (cs-gen-HSequential V \n                                                    ;move dotted lower/upper bounds to vars\n                                                    (merge X (zipmap vars (repeat (Y dbound)))) Y new-s-hsequential T)]\n                      [(move-vars-to-dmap new-cset dbound vars)]))\n\n                  ;; dotted on the right, nothing on the left\n                  (and (not-any? (some-fn :rest :drest) [S])\n                       (:drest T))\n                  (let [{dty :pre-type dbound :name} (:drest T)]\n                    (when-not (Y dbound)\n                      (fail! S T))\n                    (when-not (<= (count (:types T)) (count (:types S)))\n                      (fail! S T))\n                    (let [vars (var-store-take dbound dty (- (count (:types S)) (count (:types T))))\n                          new-tys (doall\n                                    (t/for\n                                       [var :- t/Sym, vars] :- r/AnyType\n                                       (subst/substitute (r/make-F var) dbound dty)))\n                          new-t-hsequential (r/-hsequential (concat (:types T) new-tys))\n                          new-cset (cs-gen-HSequential V \n                                                       ;move dotted lower/upper bounds to vars\n                                                       (merge X (zipmap vars (repeat (Y dbound)))) Y S new-t-hsequential)]\n                      [(move-vars-to-dmap new-cset dbound vars)]))\n\n                  ;TODO cases\n                  :else (err/nyi-error (pr-str \"NYI HSequential inference \" S T)))\n                (map (fn [fs1 fs2]\n                       (cs-gen-filter-set V X Y fs1 fs2))\n                     (:fs S) (:fs T))\n                (map (fn [o1 o2]\n                       (cs-gen-object V X Y o1 o2))\n                     (:objects S) (:objects T)))))", :ns "clojure.core.typed.cs-gen", :name "cs-gen-HSequential", :file "clojure/core/typed/cs_gen.clj", :column 1, :line 761, :arglists ([V X Y S T])}
{:type :fn, :src "(defn cs-gen-list [V X Y S T & {:keys [expected-cset] :or {expected-cset (cr/empty-cset {} {})}}]\n  {:pre [((con/set-c? symbol?) V)\n         (every? (con/hash-c? symbol? r/Bounds?) [X Y])\n         (every? r/Type? (concat S T))\n         (cr/cset? expected-cset)]\n   :post [(cr/cset? %)]}\n;  (prn \"cs-gen-list\" \n;       V X Y\n;       (map prs/unparse-type S)\n;       (map prs/unparse-type T))\n  (u/p :cs-gen/cs-gen-list\n  (when-not (= (count S) (count T))\n    (fail! S T))\n  (u/p :cs-gen/cs-gen-list-meet-csets\n  (cset-meet*\n    ;; We meet early to prune the csets to a reasonable size.\n    ;; This weakens the inference a bit, but sometimes avoids\n    ;; constraint explosion.\n    (cons\n      (cr/empty-cset X Y)\n      (let [vector' (t/inst vector t/Any r/Type r/Type)]\n        (u/p :cs-gen/cs-gen-list-gen-csets\n        (doall \n          (t/for [[s t] :- '[r/Type r/Type], (map vector' S T)] \n            :- cset\n            (let [c (cs-gen V X Y s t)\n                  ;_ (prn \"csgen-list 1\")\n                  ;_ (prn \"V\" V)\n                  ;_ (prn \"X\" X)\n                  ;_ (prn \"Y\" Y)\n                  ;_ (prn \"s\" (prs/unparse-type s))\n                  ;_ (prn \"t\" (prs/unparse-type t))\n                  ;_ (prn \"c\")\n                  ;_ (clojure.pprint/pprint c)\n                  ;_ (flush)\n                  ;_ (prn \"expected cset\" expected-cset)\n                  m (cset-meet c expected-cset)]\n              ;(prn \"meet:\")\n              ;(clojure.pprint/pprint m)\n              ;(flush)\n              m))))))))))", :ns "clojure.core.typed.cs-gen", :name "cs-gen-list", :file "clojure/core/typed/cs_gen.clj", :column 1, :line 1569, :arglists ([V X Y S T & {:keys [expected-cset], :or {expected-cset (cr/empty-cset {} {})}}])}
{:type :fn, :src "(defn cs-gen-filter [V X Y s t]\n  {:pre [((con/set-c? symbol?) V)\n         (every? (con/hash-c? symbol? r/Bounds?) [X Y])\n         (fr/Filter? s)\n         (fr/Filter? t)]\n   :post [(cr/cset? %)]}\n  (u/p :cs-gen/cs-gen-filter\n  (cond\n    (= s t) (cr/empty-cset X Y)\n    (fr/TopFilter? t) (cr/empty-cset X Y)\n\n    (and (fr/TypeFilter? s)\n         (fr/TypeFilter? t)\n         (and (= (:path s) (:path t))\n              (= (:id s) (:id t))))\n    (cset-meet (cs-gen V X Y (:type s) (:type t))\n               (cs-gen V X Y (:type t) (:type s)))\n\n    (and (fr/NotTypeFilter? s)\n         (fr/NotTypeFilter? t)\n         (and (= (:path s) (:path t))\n              (= (:id s) (:id t))))\n    (cset-meet (cs-gen V X Y (:type s) (:type t))\n               (cs-gen V X Y (:type t) (:type s)))\n\n    ; simple case for unifying x and y in (& (is x sym) ...) (is y sym)\n;    (and (fr/AndFilter? s)\n;         (fr/TypeFilter? t)\n;         (every? fo/atomic-filter? (:fs s))\n;         (= 1 (count (filter fr/TypeFilter? (:fs s)))))\n;    (let [tf (first (filter fr/TypeFilter? (:fs s)))]\n;      (cs-gen-filter V X Y tf t))\n    :else (fail! s t))))", :ns "clojure.core.typed.cs-gen", :name "cs-gen-filter", :file "clojure/core/typed/cs_gen.clj", :column 1, :line 832, :arglists ([V X Y s t])}
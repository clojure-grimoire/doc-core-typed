{:type :fn, :src "(defn cs-gen-Function\n  [V X Y S T]\n  {:pre [((con/set-c? symbol?) V)\n         (every? (con/hash-c? symbol? r/Bounds?) [X Y])\n         (r/Function? S)\n         (r/Function? T)]\n   :post [(cr/cset? %)]}\n  ;(prn \"cs-gen-Function\" (prs/unparse-type S) (prs/unparse-type T))\n  (u/p :cs-gen/cs-gen-Function\n  (letfn> [cg :- [r/AnyType r/AnyType -> cset]\n           (cg [S T] (cs-gen V X Y S T))]\n    (cond\n      ;easy case - no rests, drests, kws\n      (not-any? (some-fn :rest :drest :kws) [S T])\n      ; contravariant\n      (u/p :cs-gen/cs-gen-Function-easy-case\n      (let [;_ (prn \"easy case\")\n            ]\n        (cset-meet* [(cs-gen-list V X Y (:dom T) (:dom S))\n                     ; covariant\n                     (cg (:rng S) (:rng T))])))\n\n      ;just a rest arg, no drest, no keywords\n      (and (some-fn :rest [S T])\n           (not-any? (some-fn :drest :kws) [S T]))\n      (u/p :cs-gen/cs-gen-Function-just-rests\n      (let [arg-mapping (cond\n                          ;both rest args are present, so make them the same length\n                          (and (:rest S) (:rest T))\n                          (cs-gen-list V X Y \n                                       (cons (:rest T) (u/pad-right (count (:dom S)) (:dom T) (:rest T)))\n                                       (cons (:rest S) (u/pad-right (count (:dom T)) (:dom S) (:rest S))))\n                          ;no rest arg on the right, so just pad left and forget the rest arg\n                          (and (:rest S) (not (:rest T)))\n                          (let [new-S (u/pad-right (count (:dom T)) (:dom S) (:rest S))]\n                            ;                            (prn \"infer rest arg on left\")\n                            ;                            (prn \"left dom\" (map prs/unparse-type (:dom S)))\n                            ;                            (prn \"right dom\" (map prs/unparse-type (:dom T)))\n                            ;                            (prn \"new left dom\" (map prs/unparse-type new-S))\n                            (cs-gen-list V X Y (:dom T) new-S))\n                          ;no rest arg on left, or wrong number = fail\n                          :else (fail! S T))\n            ret-mapping (cs-gen V X Y (:rng S) (:rng T))]\n        (cset-meet* [arg-mapping ret-mapping])))\n\n      ;; dotted on the left, nothing on the right\n      (and (:drest S)\n           (not-any? (some-fn :rest :drest :kws) [T]))\n      (u/p :cs-gen/cs-gen-Function-dotted-left-nothing-right\n      (let [{dty :pre-type dbound :name} (:drest S)]\n        (when-not (Y dbound)\n          (fail! S T))\n        (when-not (<= (count (:dom S)) (count (:dom T)))\n          (fail! S T))\n        (let [vars (var-store-take dbound dty (- (count (:dom T))\n                                                 (count (:dom S))))\n              new-tys (doall (t/for\n                               [var :- t/Sym, vars] :- r/AnyType\n                               (subst/substitute (r/make-F var) dbound dty)))\n              new-s-arr (r/Function-maker (concat (:dom S) new-tys) (:rng S) nil nil nil)\n              new-cset (cs-gen-Function V \n                                        ;move dotted lower/upper bounds to vars\n                                        (merge X (zipmap vars (repeat (Y dbound)))) Y new-s-arr T)]\n          (move-vars-to-dmap new-cset dbound vars))))\n\n      ;; dotted on the right, nothing on the left\n      (and (not-any? (some-fn :rest :drest :kws) [S])\n           (:drest T))\n      (u/p :cs-gen/cs-gen-Function-dotted-right-nothing-left\n      (let [{dty :pre-type dbound :name} (:drest T)]\n        (when-not (Y dbound)\n          (fail! S T))\n        (when-not (<= (count (:dom T)) (count (:dom S)))\n          (fail! S T))\n        (let [vars (var-store-take dbound dty (- (count (:dom S)) (count (:dom T))))\n              new-tys (doall\n                        (t/for\n                          [var :- t/Sym, vars] :- r/AnyType\n                          (subst/substitute (r/make-F var) dbound dty)))\n              ;_ (prn \"dotted on the right, nothing on the left\")\n              ;_ (prn \"vars\" vars)\n              new-t-arr (r/Function-maker (concat (:dom T) new-tys) (:rng T) nil nil nil)\n              ;_ (prn \"S\" (prs/unparse-type S))\n              ;_ (prn \"new-t-arr\" (prs/unparse-type new-t-arr))\n              new-cset (cs-gen-Function V \n                                        ;move dotted lower/upper bounds to vars\n                                        (merge X (zipmap vars (repeat (Y dbound)))) Y S new-t-arr)]\n          (move-vars-to-dmap new-cset dbound vars))))\n\n      ;; * <: ...\n      (and (:rest S)\n           (:drest T))\n      (u/p :cs-gen/cs-gen-Function-*-<-...\n      (let [{t-dty :pre-type dbound :name} (-> T :drest)]\n        (when-not (Y dbound)\n          (fail! S T))\n        (if (<= (count (:dom S)) (count (:dom T)))\n          ;; the simple case\n          (let [arg-mapping (cs-gen-list V X Y (:dom T) (u/pad-right (count (:dom T)) (:dom S) (:rest S)))\n                darg-mapping (move-rest-to-dmap (cs-gen V (merge X {dbound (Y dbound)}) Y t-dty (:rest S)) dbound)\n                ret-mapping (cg (:rng S) (:rng T))]\n            (cset-meet* [arg-mapping darg-mapping ret-mapping]))\n          ;; the hard case\n          (let [vars (var-store-take dbound t-dty (- (count (:dom S)) (count (:dom T))))\n                new-tys (doall (t/for\n                                 [var :- t/Sym, vars] :- r/AnyType\n                                 (subst/substitute (r/make-F var) dbound t-dty)))\n                new-t-arr (r/Function-maker (concat (:dom T) new-tys) (:rng T) nil (r/DottedPretype1-maker t-dty dbound) nil)\n                new-cset (cs-gen-Function V (merge X (zipmap vars (repeat (Y dbound))) X) Y S new-t-arr)]\n            (move-vars+rest-to-dmap new-cset dbound vars)))))\n\n      ;; ... <: *\n      ; Typed Racket notes that this might not be a correct subtyping case?\n      (and (:drest S)\n           (:rest T))\n      (let [{s-dty :pre-type dbound :name} (-> S :drest)]\n        (when-not (Y dbound)\n          (fail! S T))\n        (cond \n          (< (count (:dom S)) (count (:dom T)))\n          ;; the hard case\n          (let [vars (var-store-take dbound s-dty (- (count (:dom T)) (count (:dom S))))\n                new-tys (doall (t/for\n                                 [var :- t/Sym, vars] :- r/AnyType\n                                 (subst/substitute (r/make-F var) dbound s-dty)))\n                new-s-arr (r/Function-maker (concat (:dom S) new-tys) (:rng S) nil (r/DottedPretype1-maker s-dty dbound) nil)\n                new-cset (cs-gen-Function V (merge X (zipmap vars (repeat (Y dbound))) X) Y new-s-arr T)]\n            (move-vars+rest-to-dmap new-cset dbound vars :exact true))\n\n          (== (count (:dom S)) (count (:dom T)))\n          ;the simple case\n          (let [arg-mapping (cs-gen-list V X Y (u/pad-right (count (:dom S)) (:dom T) (:rest T)) (:dom S))\n                darg-mapping (move-rest-to-dmap (cs-gen V (merge X {dbound (Y dbound)}) Y (:rest T) s-dty) dbound :exact true)\n                ret-mapping (cg (:rng S) (:rng T))]\n            (cset-meet* [arg-mapping darg-mapping ret-mapping]))\n\n          :else (fail! S T)))\n\n:else \n(err/nyi-error (pr-str \"NYI Function inference \" (prs/unparse-type S) (prs/unparse-type T)))))))", :ns "clojure.core.typed.cs-gen", :name "cs-gen-Function", :file "clojure/core/typed/cs_gen.clj", :column 1, :line 1252, :arglists ([V X Y S T])}
{:type :fn, :src "(defn cs-gen [V X Y S T]\n  {:pre [((con/set-c? symbol?) V)\n         (every? (con/hash-c? symbol? r/Bounds?) [X Y])\n         (r/AnyType? S)\n         (r/AnyType? T)]\n   :post [(cr/cset? %)]}\n  ;(prn \"cs-gen\" (prs/unparse-type S) (prs/unparse-type T))\n  (u/p :cs-gen/cs-gen\n  (if (or (u/p :cs-gen/cs-gen-current-seen-lookup (*cs-current-seen* [S T]) )\n          (subtype? S T))\n    ;already been around this loop, is a subtype\n    (cr/empty-cset X Y)\n    (binding [*cs-current-seen* (conj *cs-current-seen* [S T])]\n      (cond\n        (r/Top? T)\n        (cr/empty-cset X Y)\n\n        ;IMPORTANT: handle frees first\n        (and (r/F? S)\n             (contains? X (.name ^F S)))\n        (cs-gen-left-F V X Y S T)\n\n        (and (r/F? T)\n             (contains? X (.name ^F T)))\n        (cs-gen-right-F V X Y S T)\n        \n        ;values are subtypes of their classes\n        (and (r/Value? S)\n             (impl/checking-clojure?))\n        (let [^Value S S]\n          (u/p :cs-gen/Value-on-left\n          (impl/impl-case\n            :clojure (if (nil? (.val S))\n                       (fail! S T)\n                       (cs-gen V X Y\n                               (apply c/In (c/RClass-of (class (.val S)))\n                                      (cond \n                                        ;keyword values are functions\n                                        (keyword? (.val S)) [(c/keyword->Fn (.val S))]\n                                        ;strings have a known length as a seqable\n                                        (string? (.val S)) [(r/make-ExactCountRange (count (.val S)))]))\n                               T))\n            :cljs (cond\n                    (integer? (.val S)) (cs-gen V X Y (r/IntegerCLJS-maker) T)\n                    (number? (.val S)) (cs-gen V X Y (r/NumberCLJS-maker) T)\n                    (string? (.val S)) (cs-gen V X Y (r/StringCLJS-maker) T)\n                    (con/boolean? (.val S)) (cs-gen V X Y (r/BooleanCLJS-maker) T)\n                    (symbol? (.val S)) (cs-gen V X Y (c/DataType-of 'cljs.core/Symbol) T)\n                    (keyword? (.val S)) (cs-gen V X Y (c/DataType-of 'cljs.core/Keyword) T)\n                    :else (fail! S T)))))\n\n        ;; constrain body to be below T, but don't mention the new vars\n        (r/Poly? S)\n        (let [nms (c/Poly-fresh-symbols* S)\n              body (c/Poly-body* nms S)]\n          (cs-gen (set/union (set nms) V) X Y body T))\n\n        (r/Name? S)\n        (cs-gen V X Y (c/resolve-Name S) T)\n\n        (r/Name? T)\n        (cs-gen V X Y S (c/resolve-Name T))\n\n        ; copied from TR's infer-unit\n        ;; if we have two mu's, we rename them to have the same variable\n        ;; and then compare the bodies\n        ;; This relies on (B 0) only unifying with itself, and thus only hitting the first case of this `match'\n        (and (r/Mu? S)\n             (r/Mu? T))\n        (cs-gen V X Y (r/Mu-body-unsafe S) (r/Mu-body-unsafe T))\n\n        ;; other mu's just get unfolded\n        (r/Mu? S) (cs-gen V X Y (c/unfold S) T)\n        (r/Mu? T) (cs-gen V X Y S (c/unfold T))\n\n        (and (r/TApp? S)\n             (not (r/F? (:rator S))))\n        (cs-gen V X Y (c/resolve-TApp S) T)\n\n        (and (r/TApp? T)\n             (not (r/F? (:rator T))))\n        (cs-gen V X Y S (c/resolve-TApp T))\n\n        ;constrain *each* element of S to be below T, and then combine the constraints\n        (r/Union? S)\n        (cset-meet*\n          (cons (cr/empty-cset X Y)\n                (mapv #(cs-gen V X Y % T) (.types ^Union S))))\n\n        ;; find *an* element of T which can be made a supertype of S\n        (r/Union? T)\n        (if-let [cs (seq (filter identity (mapv #(handle-failure (cs-gen V X Y S %))\n                                                (.types ^Union T))))]\n          (cset-combine cs)\n          (fail! S T))\n\n        ; Does it matter which order the Intersection cases go?\n\n        ;constrain *every* element of T to be above S, and then meet the constraints\n        ; we meet instead of cset-combine because we want all elements of T to be under\n        ; S simultaneously.\n        (r/Intersection? T)\n        (let [ts (sub/simplify-In T)]\n          (cset-meet*\n            (cons (cr/empty-cset X Y)\n                  (mapv #(cs-gen V X Y S %) ts))))\n\n        ;; find *an* element of S which can be made a subtype of T\n        (r/Intersection? S)\n        (let [ss (sub/simplify-In S)]\n          (if-let [cs (some #(handle-failure (cs-gen V X Y % T))\n                            ss)]\n            (do ;(prn \"intersection S normal case\" (map prs/unparse-type [S T]))\n                cs)\n            (fail! S T)))\n\n        (and (r/Extends? S)\n             (r/Extends? T))\n        (let [;_ (prn \"Extends\" (prs/unparse-type S) (prs/unparse-type T)\n              ;       V X Y)\n              ; FIXME handle negative information\n              cs (cset-meet*\n                   (doall\n                     ; for each element of T, we need at least one element of S that works\n                     (for [t* (:extends T)]\n                       (if-let [results (doall\n                                          (seq (filter identity\n                                                       (map #(handle-failure\n                                                               (cs-gen V X Y % t*))\n                                                            (:extends S)))))]\n                         (cset-meet* results)\n                         (fail! S T)))))]\n          cs)\n\n        ;; find *an* element of S which can be made a subtype of T\n        ;; we don't care about what S does *not* implement, so we don't\n        ;; use the \"without\" field of Extends\n        (r/Extends? S)\n        (if-let [cs (some #(handle-failure (cs-gen V X Y % T))\n                          (:extends S))]\n          cs\n          (fail! S T))\n\n        ;constrain *every* element of T to be above S, and then meet the constraints\n        ; also ensure T's negative information is reflected in S\n        (r/Extends? T)\n        (let [cs (cset-meet*\n                   (cons (cr/empty-cset X Y)\n                         (mapv #(cs-gen V X Y S %) (:extends T))))\n              satisfies-without? (not-any? identity \n                                           (doall\n                                             (map #(handle-failure (cs-gen V X Y % T))\n                                                  (:without T))))]\n          (if satisfies-without?\n            cs\n            (fail! S T)))\n\n\n        (r/App? S)\n        (cs-gen V X Y (c/resolve-App S) T)\n\n        (r/App? T)\n        (cs-gen V X Y S (c/resolve-App T))\n\n        (and (r/DataType? S)\n             (r/DataType? T)) (cs-gen-datatypes-or-records V X Y S T)\n\n        ; handle Record as HMap\n        (r/Record? S) (cs-gen V X Y (c/Record->HMap S) T)\n\n        (and (r/HeterogeneousVector? S)\n             (r/HeterogeneousVector? T))\n        (cs-gen-HSequential V X Y (c/HVec->HSequential S) (c/HVec->HSequential T))\n\n        (and (r/HeterogeneousSeq? S)\n             (r/HeterogeneousSeq? T))\n        (cs-gen-HSequential V X Y (c/HSeq->HSequential S) (c/HSeq->HSequential T))\n\n        (and (r/HeterogeneousList? S)\n             (r/HeterogeneousList? T))\n        (cs-gen-HSequential V X Y (c/HList->HSequential S) (c/HList->HSequential T))\n\n        ; HList/HSeq/HVector are HSequential\n        (and ((some-fn r/HeterogeneousList?\n                       r/HeterogeneousSeq?\n                       r/HeterogeneousVector?)\n              S)\n             (r/HSequential? T))\n        (cs-gen-HSequential V X Y \n                (cond\n                  (r/HeterogeneousList? S) (c/HList->HSequential S) \n                  (r/HeterogeneousVector? S) (c/HVec->HSequential S) \n                  :else (c/HSeq->HSequential S))\n                T)\n\n        ; HList is a HSeq\n        (and (r/HeterogeneousList? S)\n             (r/HeterogeneousSeq? T))\n        (cs-gen-HSequential V X Y (c/HList->HSequential S) (c/HSeq->HSequential T))\n\n        (and (r/HSequential? S)\n             (r/HSequential? T))\n        (cs-gen-HSequential V X Y S T)\n\n        (and (r/HeterogeneousMap? S)\n             (r/HeterogeneousMap? T))\n    ; assumes optional/mandatory/absent keys are disjoint\n        (let [Skeys (set (keys (:types S)))\n              Tkeys (set (keys (:types T)))\n              Soptk (set (keys (:optional S)))\n              Toptk (set (keys (:optional T)))\n              Sabsk (:absent-keys S)\n              Tabsk (:absent-keys T)]\n          ; All keys must be values\n          (when-not (every? r/Value? \n                            (concat\n                              Skeys Tkeys\n                              Soptk Toptk\n                              Sabsk Tabsk))\n            (fail! S T))\n          ; If the right is complete, the left must also be complete\n          (when (c/complete-hmap? T)\n            (when-not (c/complete-hmap? S)\n              (fail! S T)))\n          ; check mandatory keys\n          (if (c/complete-hmap? T)\n            ; If right is complete, mandatory keys must be identical\n            (when-not (= Tkeys Skeys)\n              (fail! S T))\n            ; If right is partial, all mandatory keys on the right must also appear mandatory on the left\n            (when-not (empty? (set/difference Tkeys \n                                Skeys))\n              (fail! S T)))\n          ; All optional keys on the right must appear either absent, mandatory or optional\n          ; on the left\n          (when-not (empty? (set/difference Toptk \n                              (set/union Skeys \n                                         Soptk \n                                         Sabsk)))\n            (fail! S T))\n          ; All absent keys on the right must appear absent on the left\n          (when-not (empty? (set/difference Tabsk\n                              Sabsk))\n            (fail! S T))\n          ; now check the values with cs-gen\n          (let [;only check mandatory entries that appear on the right\n                check-mandatory-keys Tkeys\n                Svals (map (:types S) check-mandatory-keys)\n                Tvals (map (:types T) check-mandatory-keys)\n                _ (assert (every? r/Type? Svals))\n                _ (assert (every? r/Type? Tvals))\n                ;only check optional entries that appear on the right\n                ; and also appear as mandatory or optional on the left\n                check-optional-keys (set/intersection\n                                      Toptk (set/union Skeys Soptk))\n                Sopts (map (some-fn (:types S) (:optional S)) check-optional-keys)\n                Topts (map (:optional T) check-optional-keys)\n                _ (assert (every? r/Type? Sopts))\n                _ (assert (every? r/Type? Topts))]\n            (cset-meet* [(cs-gen-list V X Y Svals Tvals)\n                         (cs-gen-list V X Y Sopts Topts)])))\n\n        (and (r/GetType? S)\n             (not (r/F? (:target S))))\n        (cs-gen V X Y (c/-resolve S) T)\n\n        (and (r/GetType? T)\n             (not (r/F? (:target T))))\n        (cs-gen V X Y S (c/-resolve T))\n\n; Completeness matters:\n;\n; (Assoc x ':a Number ':b Long) <: (HMap {:a Number :b Long} :complete? true)\n; (Assoc x ':a Number ':b Long ':c Foo) <!: (HMap {:a Number :b Long} :complete? true)\n        (and (r/AssocType? S)\n             (r/HeterogeneousMap? T))\n        (let [;_ (prn \"cs-gen Assoc HMap\")\n              {:keys [target entries]} S\n              {:keys [types absent-keys]} T\n              Assoc-keys (map first entries)\n              Tkeys (keys types)\n              ; All keys must be keyword values\n              _ (when-not (every? c/keyword-value? (concat Tkeys Assoc-keys absent-keys))\n                  (fail! S T))\n              ; All keys explicitly not in T should not appear in the Assoc operation\n              absents-satisfied?\n              (if (c/complete-hmap? T)\n                ; if T is partial, we just need to ensure the absent keys in T\n                ; don't appear in the entries of the Assoc.\n                (empty?\n                  (set/intersection\n                    (set absent-keys)\n                    (set (map first entries))))\n                ; if T is complete, all entries of the Assoc should *only* have\n                ; keys that are mandatory keys of T.\n                (empty?\n                  (set/difference\n                    (set (map first entries))\n                    (set Tkeys))))\n              _ (when-not absents-satisfied?\n                  (fail! S T))\n              ;; Isolate the entries of Assoc in a new HMap, with a corresponding expected HMap.\n              ; keys on the right overwrite those on the left.\n              assoc-args-hmap (c/make-HMap :mandatory (into {} entries))\n              expected-assoc-args-hmap (c/make-HMap :mandatory (select-keys (:types assoc-args-hmap) (set Assoc-keys)))\n              \n              ;; The target of the Assoc needs all the keys not explicitly Assoc'ed.\n              expected-target-hmap \n              (let [types (select-keys (into {} entries)\n                                       (set/difference (set Assoc-keys) (set Tkeys)))]\n                (if (c/complete-hmap? T) \n                  (c/-complete-hmap types)\n                  (c/-partial-hmap types absent-keys)))\n              \n              ;_ (prn assoc-args-hmap :< expected-assoc-args-hmap)\n              ;_ (prn (:target S) :< expected-target-hmap)\n              ]\n          (cs-gen-list V X Y\n                       [assoc-args-hmap \n                        (:target S)]\n                       [expected-assoc-args-hmap\n                        expected-target-hmap]))\n\n        (and (r/PrimitiveArray? S)\n             (r/PrimitiveArray? T)\n             (impl/checking-clojure?))\n        (let [^PrimitiveArray S S \n              ^PrimitiveArray T T]\n          (cs-gen-list \n            V X Y\n            ;input contravariant\n            ;output covariant\n            [(.input-type T) (.output-type S)]\n            [(.input-type S) (.output-type T)]))\n\n        ; some RClass's have heterogeneous vector ancestors (in \"unchecked ancestors\")\n        ; It's useful to also trigger this case with HSequential, as that's more likely\n        ; to be on the right.\n        (and (r/RClass? S)\n             ((some-fn r/HeterogeneousVector? r/HSequential?) T))\n        (if-let [[Sv] (seq\n                        (filter (some-fn r/HeterogeneousVector? r/HSequential?)\n                                (map c/fully-resolve-type (c/RClass-supers* S))))]\n          (cs-gen V X Y Sv T)\n          (fail! S T))\n        \n        (and (r/TApp? S)\n             (r/TApp? T))\n        (cs-gen-TApp V X Y S T)\n\n        (and (r/FnIntersection? S)\n             (r/FnIntersection? T))\n        (cs-gen-FnIntersection V X Y S T)\n\n        (and (r/Function? S)\n             (r/Function? T))\n        (cs-gen-Function V X Y S T)\n\n        (and (r/Result? S)\n             (r/Result? T))\n        (cs-gen-Result V X Y S T)\n\n        (and (r/Value? S)\n             (r/AnyValue? T))\n        (cr/empty-cset X Y)\n\n; must remember to update these if HeterogeneousList gets rest/drest\n        (and (r/HeterogeneousSeq? S)\n             (r/RClass? T))\n        (cs-gen V X Y\n                (let [ss (apply c/Un\n                                (concat\n                                  (:types S)\n                                  (when-let [rest (:rest S)]\n                                    [rest])\n                                  (when (:drest S)\n                                    [r/-any])))]\n                  (c/In (impl/impl-case\n                          :clojure (c/RClass-of ISeq [ss])\n                          :cljs (c/Protocol-of 'cljs.core/ISeq [ss]))\n                        ((if (or (:rest S) (:drest S)) r/make-CountRange r/make-ExactCountRange)\n                           (count (:types S)))))\n                T)\n\n; must remember to update these if HeterogeneousList gets rest/drest\n        (and (r/HeterogeneousList? S)\n             (r/RClass? T))\n        (cs-gen V X Y \n                (c/In (impl/impl-case\n                        :clojure (c/RClass-of IPersistentList [(apply c/Un (:types S))])\n                        :cljs (c/Protocol-of 'cljs.core/IList [(apply c/Un (:types S))]))\n                      (r/make-ExactCountRange (count (:types S))))\n                T)\n\n        (and (r/HSequential? S)\n             (r/RClass? T))\n        (cs-gen V X Y\n                (let [ss (apply c/Un\n                                (concat\n                                  (:types S)\n                                  (when-let [rest (:rest S)]\n                                    [rest])\n                                  (when (:drest S)\n                                    [r/-any])))]\n                  (c/In (impl/impl-case\n                          :clojure (c/In (c/RClass-of clojure.lang.IPersistentCollection [ss])\n                                         (c/RClass-of clojure.lang.Sequential))\n                          :cljs (throw (Exception. \"TODO CLJS HSequential cs-gen\")))\n                        ((if (or (:rest S) (:drest S)) r/make-CountRange r/make-ExactCountRange)\n                         (count (:types S)))))\n                T)\n\n        (and (r/HeterogeneousVector? S)\n             (r/RClass? T))\n        (cs-gen V X Y\n                (let [ss (apply c/Un \n                                (concat\n                                  (:types S)\n                                  (when-let [rest (:rest S)]\n                                    [rest])\n                                  (when (:drest S)\n                                    [r/-any])))]\n                  (c/In (impl/impl-case\n                          :clojure (c/RClass-of APersistentVector [ss])\n                          :cljs (c/Protocol-of 'cljs.core/IVector [ss]))\n                        ((if (or (:rest S) (:drest S)) r/make-CountRange r/make-ExactCountRange)\n                         (count (:types S)))))\n                T)\n\n        (and (r/RClass? S)\n             (r/RClass? T))\n        (cs-gen-RClass V X Y S T)\n\n        (and (r/Protocol? S)\n             (r/Protocol? T))\n        (cs-gen-Protocol V X Y S T)\n\n        (r/HeterogeneousMap? S)\n        (let [new-S (c/upcast-hmap S)]\n          (cs-gen V X Y new-S T))\n\n        (r/HSet? S)\n        (let [new-S (c/upcast-hset S)]\n          (cs-gen V X Y new-S T))\n\n        (r/HeterogeneousVector? S)\n        (cs-gen V X Y (c/upcast-hvec S) T)\n\n        :else\n        (do (when-not (subtype? S T) \n              (fail! S T))\n            (cr/empty-cset X Y)))))))", :ns "clojure.core.typed.cs-gen", :name "cs-gen", :file "clojure/core/typed/cs_gen.clj", :column 1, :line 304, :arglists ([V X Y S T])}
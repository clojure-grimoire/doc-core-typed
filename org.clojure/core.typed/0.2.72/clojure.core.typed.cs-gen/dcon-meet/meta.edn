{:type :fn, :src "(defn dcon-meet [dc1 dc2]\n  {:pre [(cr/dcon-c? dc1)\n         (cr/dcon-c? dc2)]\n   :post [(cr/dcon-c? %)]}\n  (u/p :cs-gen/dcon-meet\n  (cond\n    (and (cr/dcon-exact? dc1)\n         (or (cr/dcon? dc2) \n             (cr/dcon-exact? dc2)))\n    (let [{fixed1 :fixed rest1 :rest} dc1\n          {fixed2 :fixed rest2 :rest} dc2]\n      (when-not (and rest2 (= (count fixed1) (count fixed2)))\n        (fail! fixed1 fixed2))\n      (cr/->dcon-exact\n        (doall\n          (let [vector' (t/ann-form vector [c c -> '[c c]])]\n            (t/for\n              [[c1 c2] :- '[c c], (map vector' fixed1 fixed2)]\n              :- c\n              (c-meet c1 c2 (:X c1)))))\n        (c-meet rest1 rest2 (:X rest1))))\n    ;; redo in the other order to call the first case\n    (and (cr/dcon? dc1)\n         (cr/dcon-exact? dc2))\n    (dcon-meet dc2 dc1)\n\n    (and (cr/dcon? dc1)\n         (not (:rest dc1))\n         (cr/dcon? dc2)\n         (not (:rest dc2)))\n    (let [{fixed1 :fixed} dc1\n          {fixed2 :fixed} dc2]\n      (when-not (= (count fixed1) (count fixed2))\n        (fail! fixed1 fixed2))\n      (cr/->dcon\n        (doall\n          (for [[c1 c2] (map vector fixed1 fixed2)]\n            (c-meet c1 c2 (:X c1))))\n        nil))\n\n    (and (cr/dcon? dc1)\n         (not (:rest dc1))\n         (cr/dcon? dc2))\n    (let [{fixed1 :fixed} dc1\n          {fixed2 :fixed rest :rest} dc2]\n      (assert rest)\n      (when-not (>= (count fixed1) (count fixed2))\n        (fail! fixed1 fixed2))\n      (cr/->dcon\n        (let [vector' (t/inst vector c c t/Any t/Any t/Any t/Any)]\n          (doall\n            (t/for\n              [[c1 c2] :- '[c c], (map vector' fixed1 (concat fixed2 (repeat rest)))]\n              :- c\n              (c-meet c1 c2 (:X c1)))))\n        nil))\n\n    (and (cr/dcon? dc1)\n         (cr/dcon? dc2)\n         (not (:rest dc2)))\n    (dcon-meet dc2 dc1)\n\n    (and (cr/dcon? dc1)\n         (cr/dcon? dc2))\n    (let [{fixed1 :fixed rest1 :rest} dc1\n          {fixed2 :fixed rest2 :rest} dc2\n          [shorter longer srest lrest]\n          (if (< (count fixed1) (count fixed2))\n            [fixed1 fixed2 rest1 rest2]\n            [fixed2 fixed1 rest2 rest1])]\n      (cr/->dcon\n        (let [vector' (t/inst vector c c t/Any t/Any t/Any t/Any)]\n          (doall\n            (t/for\n              [[c1 c2] :- '[c c], (map vector' longer (concat shorter (repeat srest)))]\n              :- c\n              (c-meet c1 c2 (:X c1)))))\n        (c-meet lrest srest (:X lrest))))\n\n    (and (cr/dcon-dotted? dc1)\n         (cr/dcon-dotted? dc2))\n    (let [{fixed1 :fixed c1 :dc {bound1 :name} :dbound} dc1\n          {fixed2 :fixed c2 :dc {bound2 :name} :dbound} dc2]\n      (when-not (and (= (count fixed1) (count fixed2))\n                     (= bound1 bound2))\n        (fail! bound1 bound2))\n      (cr/->dcon-dotted (let [vector' (t/inst vector c c t/Any t/Any t/Any t/Any)]\n                          (doall \n                            (t/for\n                              [[c1 c2] :- '[c c], (map vector' fixed1 fixed2)]\n                              :- c\n                              (c-meet c1 c2 (:X c1)))))\n                        (c-meet c1 c2 bound1) bound1))\n\n    (and (cr/dcon? dc1)\n         (cr/dcon-dotted? dc2))\n    (fail! dc1 dc2)\n\n    (and (cr/dcon-dotted? dc1)\n         (cr/dcon? dc2))\n    (fail! dc1 dc2)\n\n    :else (err/int-error (str \"Got non-dcons\" dc1 dc2)))))", :ns "clojure.core.typed.cs-gen", :name "dcon-meet", :file "clojure/core/typed/cs_gen.clj", :column 1, :line 158, :arglists ([dc1 dc2])}
{:type :fn, :src "(defn subst-gen [C Y R]\n  {:pre [(cr/cset? C)\n         ((con/set-c? symbol?) Y)\n         (r/AnyType? R)]\n   :post [((some-fn nil? cr/substitution-c?) %)]}\n  (u/p :cs-gen/subst-gen\n  (let [var-hash (frees/fv-variances R)\n        idx-hash (frees/idx-variances R)]\n    (letfn> \n           [\n            ;; v : Symbol - variable for which to check variance\n            ;; h : (Hash F Variance) - hash to check variance in (either var or idx hash)\n            ;; variable: Symbol - variable to use instead, if v was a temp var for idx extension\n            constraint->type :- [c frees/VarianceMap & :optional {:variable (t/U nil t/Sym)} -> r/Variance]\n            (constraint->type [{{:keys [upper-bound lower-bound]} :bnds :keys [S X T] :as v} h & {:keys [variable]}]\n              {:pre [(cr/c? v)\n                     (frees/variance-map? h)\n                     ((some-fn nil? symbol?) variable)]}\n              (when-not (subtype? S T) (fail! S T))\n              (when (some r/TypeFn? [upper-bound lower-bound]) (err/nyi-error \"Higher kinds\"))\n              (let [var (h (or variable X) :constant)\n                    inferred (case var\n                               (:constant :covariant) S\n                               :contravariant T\n                               :invariant S)]\n                inferred))\n            ;TODO implement generalize\n            ;                  (let [gS (generalize S)]\n            ;                    (if (subtype? gS T)\n            ;                      gS\n            ;                      S))\n\n            ;; Since we don't add entries to the empty cset for index variables (since there is no\n            ;; widest constraint, due to dcon-exacts), we must add substitutions here if no constraint\n            ;; was found.  If we're at this point and had no other constraints, then adding the\n            ;; equivalent of the constraint (dcon null (c Bot X Top)) is okay.\n            extend-idxs :- [cr/SubstMap -> (t/U nil cr/SubstMap)]\n            (extend-idxs [S]\n              {:pre [(cr/substitution-c? S)]}\n              (let [fi-R (frees/fi R)] ;free indices in R\n                ;; If the index variable v is not used in the type, then\n                ;; we allow it to be replaced with the empty list of types;\n                ;; otherwise we error, as we do not yet know what an appropriate\n                ;; lower bound is.\n                (letfn> [demote-check-free :- [t/Sym -> cr/SubstRHS]\n                         (demote-check-free [v]\n                           {:pre [(symbol? v)]}\n                           (if (fi-R v)\n                             (err/int-error \"attempted to demote dotted variable\")\n                             (cr/->i-subst nil)))]\n                  ;; absent-entries is false if there's an error in the substitution, otherwise\n                  ;; it's a list of variables that don't appear in the substitution\n                  (let [absent-entries\n                        (reduce (t/fn [no-entry :- t/Any\n                                       v :- t/Sym]\n                                  {:pre [(symbol? v)]}\n                                  (let [entry (S v)]\n                                    ;; Make sure we got a subst entry for an index var\n                                    ;; (i.e. a list of types for the fixed portion\n                                    ;;  and a type for the starred portion)\n                                    (cond\n                                      (false? no-entry) no-entry\n                                      (not entry) (cons v no-entry)\n                                      (or (cr/i-subst? entry) \n                                          (cr/i-subst-starred? entry)\n                                          (cr/i-subst-dotted? entry)) no-entry\n                                      :else false)))\n                                [] Y)]\n                    (and absent-entries\n                         (merge (into {}\n                                      (t/for\n                                        [missing :- t/Sym, absent-entries] :- '[t/Sym r/Variance]\n                                        (let [var (idx-hash missing :constant)]\n                                          [missing\n                                           (case var\n                                             (:constant :covariant :invariant) (demote-check-free missing)\n                                             :contravariant (cr/->i-subst-starred nil r/-any))])))\n                                S))))))]\n\n      (let [{cmap :fixed dmap* :dmap :keys [delayed-checks]} (if-let [c (-> C :maps first)]\n                                                               c\n                                                               (err/int-error \"No constraints found\"))\n            ; Typed Racket arbitrarily picks the first constraint here, we follow.\n            ;\n            ;_ (when-not (= 1 (count (:maps C))) \n            ;    (err/int-error \"More than one constraint set found\"))\n            dm (:map dmap*)\n            subst (merge \n                    (into {}\n                      (t/for\n                        [[k dc] :- '[t/Sym cr/DCon], dm] :- '[t/Sym cr/SubstRHS]\n                        (cond\n                          (and (cr/dcon? dc) (not (:rest dc)))\n                          [k (cr/->i-subst (doall\n                                          (for [f (:fixed dc)]\n                                            (constraint->type f idx-hash :variable k))))]\n                          (and (cr/dcon? dc) (:rest dc))\n                          [k (cr/->i-subst-starred (doall\n                                                  (for [f (:fixed dc)]\n                                                    (constraint->type f idx-hash :variable k)))\n                                                (constraint->type (:rest dc) idx-hash))]\n                          (cr/dcon-exact? dc)\n                          [k (cr/->i-subst-starred (doall\n                                                  (for [f (:fixed dc)]\n                                                    (constraint->type f idx-hash :variable k)))\n                                                (constraint->type (:rest dc) idx-hash))]\n                          (cr/dcon-dotted? dc)\n                          [k (cr/->i-subst-dotted (doall\n                                                 (for [f (:fixed dc)]\n                                                   (constraint->type f idx-hash :variable k)))\n                                               (constraint->type (:dc dc) idx-hash :variable k)\n                                               (:dbound dc))]\n                          :else (err/int-error (prn-str \"What is this? \" dc)))))\n\n                    (into {}\n                      (t/for\n                        [[k v] :- '[t/Sym c], cmap] :- '[t/Sym cr/SubstRHS]\n                        [k (cr/->t-subst (constraint->type v var-hash)\n                                         (:bnds v))])))\n            ;check delayed constraints and type variable bounds\n            _ (let [t-substs (into {} (filter (t/fn [[_ v] :- '[t/Sym cr/SubstRHS]]\n                                                (cr/t-subst? v)) \n                                              subst))\n                    [names images] (let [s (seq t-substs)]\n                                     [(map first s)\n                                      (map (comp :type second) s)])]\n                ;(prn delayed-checks)\n                (t/doseq [[S T] :- '[r/AnyType r/AnyType], delayed-checks]\n                  (let [S* (subst/substitute-many S images names)\n                        T* (subst/substitute-many T images names)]\n                    ;(prn \"delayed\" (map prs/unparse-type [S* T*]))\n                    (when-not (subtype? S* T*)\n                      (fail! S T))\n                            #_(str \"Delayed check failed\"\n                                 (mapv prs/unparse-type [S T]))))\n                (t/doseq [[nme {inferred :type :keys [bnds]}] :- '[t/Sym t-subst], t-substs]\n                  (when (some r/TypeFn? [(:upper-bound bnds) (:lower-bound bnds)]) (err/nyi-error \"Higher kinds\"))\n                  (let [lower-bound (subst/substitute-many (:lower-bound bnds) images names)\n                        upper-bound (subst/substitute-many (:upper-bound bnds) images names)]\n                    (cond\n                      (not (subtype? lower-bound upper-bound))\n                      (fail! lower-bound upper-bound)\n\n\n                      (not (subtype? inferred upper-bound))\n                      (fail! inferred upper-bound)\n\n                      (not (subtype? lower-bound inferred))\n                      (fail! lower-bound inferred)))))]\n        ;; verify that we got all the important variables\n        (when-let [r (and (every? identity\n                                  (t/for\n                                    [v :- t/Sym, (frees/fv R)] :- t/Any\n                                    (let [entry (subst v)]\n                                      (and entry (cr/t-subst? entry)))))\n                          (extend-idxs subst))]\n          r))))))", :ns "clojure.core.typed.cs-gen", :name "subst-gen", :file "clojure/core/typed/cs_gen.clj", :column 1, :line 1398, :arglists ([C Y R])}
{:type :fn, :src "(defn macroexpand-1\n  \"If form represents a macro form or an inlineable function,\n   returns its expansion, else returns form.\"\n  [form env]\n  ;(prn \"macroexpand-1\" form (meta form))\n    (ta-env/ensure (taj/global-env)\n    (if (seq? form)\n      (let [[op & args] form]\n        (if (taj/specials op)\n          form\n          (let [v (taj-utils/resolve-var op env)\n                m (meta v)\n                ;_ (prn \"op\" (meta op)  m)\n                local? (-> env :locals (get op))\n                macro? (and (not local?) (:macro m)) ;; locals shadow macros\n                inline-arities-f (:inline-arities m)\n                inline? (and (not local?)\n                             (or (not inline-arities-f)\n                                 (inline-arities-f (count args)))\n                             (:inline m))\n                t (:tag m)]\n            (cond\n\n             macro?\n             (let [res (apply (typed-macros v v) form (:locals env) (rest form))] ; (m &form &env & args)\n               (taj/update-ns-map!)\n               (if (taj-utils/obj? res)\n                 (vary-meta res merge (meta form))\n                 res))\n\n             inline?\n             (let [res (apply inline? args)]\n               (taj/update-ns-map!)\n               (if (taj-utils/obj? res)\n                 (vary-meta res merge\n                            (and t {:tag t})\n                            ; we want the top-most inlining op\n                            {::inline-op op\n                             ::inline-var v}\n                            (meta form))\n                 res))\n\n             :else\n             (taj/desugar-host-expr form env)))))\n      (taj/desugar-host-expr form env))))", :ns "clojure.core.typed.analyze-clj", :name "macroexpand-1", :file "clojure/core/typed/analyze_clj.clj", :column 1, :line 61, :arglists ([form env]), :doc "If form represents a macro form or an inlineable function,\n   returns its expansion, else returns form."}
{:type :var, :src "(def typed-macros\n  {#'clojure.core/ns \n   (fn [&form &env name & references]\n     (let [process-reference\n           (fn [[kname & args]]\n             `(~(symbol \"clojure.core\" (clojure.core/name kname))\n                        ~@(map #(list 'quote %) args)))\n           docstring  (when (string? (first references)) (first references))\n           references (if docstring (next references) references)\n           name (if docstring\n                  (vary-meta name assoc :doc docstring)\n                  name)\n           metadata   (when (map? (first references)) (first references))\n           references (if metadata (next references) references)\n           name (if metadata\n                  (vary-meta name merge metadata)\n                  name)\n           gen-class-clause (first (filter #(= :gen-class (first %)) references))\n           gen-class-call\n           (when gen-class-clause\n             (list* `gen-class :name (.replace (str name) \\- \\_) :impl-ns name :main true (next gen-class-clause)))\n           references (remove #(= :gen-class (first %)) references)\n           ;ns-effect (clojure.core/in-ns name)\n           ]\n       `(do\n          ::T/special-collect\n          ::core/ns\n          {:form '~&form}\n          (clojure.core/in-ns '~name)\n          (with-loading-context\n            ~@(when gen-class-call (list gen-class-call))\n            ~@(when (and (not= name 'clojure.core) (not-any? #(= :refer-clojure (first %)) references))\n                `((clojure.core/refer '~'clojure.core)))\n            ~@(map process-reference references))\n          (if (.equals '~name 'clojure.core) \n            nil\n            (do (dosync (commute @#'clojure.core/*loaded-libs* (T/inst conj T/Symbol T/Any) '~name)) nil)))))\n   })", :ns "clojure.core.typed.analyze-clj", :name "typed-macros", :file "clojure/core/typed/analyze_clj.clj", :column 1, :line 22}
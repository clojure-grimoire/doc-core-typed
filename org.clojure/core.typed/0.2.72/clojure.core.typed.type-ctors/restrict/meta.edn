{:type :fn, :src "(defn restrict [t1 t2]\n  (let [t1 (fully-resolve-type t1)\n        t2 (fully-resolve-type t2)\n        subtype? @(subtype?-var)\n        subst-all @(subst-all-var)\n        infer @(infer-var)]\n    (cond\n      (subtype? t1 t2) t1 ;; already a subtype\n\n      (not (overlap t1 t2)) (Un) ;there's no overlap, so the restriction is empty\n\n      (r/Union? t1) (apply Un (map (fn [e] (restrict e t2)) (:types t1)))\n      (r/Union? t2) (apply Un (map (fn [e] (restrict t1 e)) (:types t2)))\n\n      (r/Poly? t2)\n      (let [names (Poly-fresh-symbols* t2)\n            t (Poly-body* names t2)\n            bbnds (Poly-bbnds* names t2)\n            subst (u/handle-cs-gen-failure\n                    (infer (zipmap names bbnds) {} (list t1) (list t) t1))]\n        (and subst (restrict t1 (subst-all subst t1))))\n\n      ;TODO other cases\n      :else (In t2 t1))))", :ns "clojure.core.typed.type-ctors", :name "restrict", :file "clojure/core/typed/type_ctors.clj", :column 1, :line 1699, :arglists ([t1 t2])}
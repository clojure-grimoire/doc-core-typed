{:type :fn, :src "(defn In [& types]\n  {:pre [(every? r/Type? types)]\n   :post [(r/Type? %)]}\n  ;(prn \"In\" types)\n;  (if-let [hit (@In-cache (set types))]\n;    (do #_(prn \"In hit\" hit)\n;        hit)\n  (p :type-ctors/In-ctor\n    (let [res (let [ts (set (flatten-intersections types))]\n                (cond\n                  ; empty intersection is bottom\n                  (or (empty? ts)\n                      (contains? ts bottom)) bottom\n\n                  (= 1 (count ts)) (first ts)\n\n                  ; normalise (I t1 t2 (t/U t3 t4))\n                  ; to (t/U (I t1 t2) (I t1 t2 t3) (t/U t1 t2 t4))\n                  :else (let [{unions true non-unions false} (group-by r/Union? ts)\n                              ;_ (prn \"unions\" (map ind/unparse-type unions))\n                              ;_ (prn \"non-unions\" (map ind/unparse-type non-unions))\n                              ;intersect all the non-unions to get a possibly-nil type\n                              intersect-non-unions \n                              (p :intersect-in-In (when (seq non-unions)\n                                                    (reduce intersect non-unions)))\n                              ;if we have an intersection above, use it to update each\n                              ;member of the unions we're intersecting\n                              flat-unions (set (flatten-unions unions))\n                              intersect-union-ts (cond \n                                                   intersect-non-unions\n                                                   (if (seq flat-unions)\n                                                     (reduce (fn [acc union-m]\n                                                               (conj acc (intersect intersect-non-unions union-m)))\n                                                             #{} flat-unions)\n                                                     #{intersect-non-unions})\n\n                                                   :else flat-unions)\n                              _ (assert (every? r/Type? intersect-union-ts)\n                                        intersect-union-ts)\n                              ;_ (prn \"intersect-union-ts\" (map ind/unparse-type intersect-union-ts))\n                              ]\n                          (apply Un intersect-union-ts))))]\n      ;(swap! In-cache assoc (set types) res)\n      #_(prn 'IN res (class res))\n      res))\n  )", :ns "clojure.core.typed.type-ctors", :name "In", :file "clojure/core/typed/type_ctors.clj", :column 1, :line 497, :arglists ([& types])}
{:type :fn, :src "(defn Un [& types]\n  {:pre [(every? r/Type? types)]\n   :post [(r/Type? %)]}\n  ;(prn \"Un\" (map ind/unparse-type types))\n  (if-let [hit (p :Union-cache-lookup (get @Un-cache (p :Union-calc-hash (set types))))]\n    (do (p :Un-cache-hit)\n        hit)\n  (p :type-ctors/Un-ctor\n  (let [_ (p :Un-cache-miss)\n        res (let [subtype? @(subtype?-var)]\n              (letfn [;; a is a Type (not a union type)\n                      ;; b is a Set[Type] (non overlapping, non Union-types)\n                      ;; The output is a non overlapping list of non Union types.\n                      (merge-type [a b]\n                        {:pre [(set? b)\n                               (do (assert (r/Type? a) a)\n                                   true)\n                               (not (r/Union? a))]\n                         :post [(set? %)]}\n                        #_(prn \"merge-type\" a b)\n                        (let [b* (make-Union b)\n                              ;_ (prn \"merge-type\" a b*)\n                              res (cond\n                                    ; don't resolve type applications in case types aren't\n                                    ; fully defined yet\n                                    ; TODO basic error checking, eg. number of params\n                                    (some (some-fn r/Name? r/TApp?) (conj b a)) (conj b a)\n                                    (subtype? a b*) b\n                                    (subtype? b* a) #{a}\n                                    :else (set (cons a \n                                                     (remove #(subtype? % a) b))))]\n                          ;(prn \"res\" res)\n                          res))]\n                (let [types (set types)]\n                  (cond\n                    (empty? types) r/empty-union\n                    (= 1 (count types)) (first types)\n                    :else \n                    (p :Un-merge-type \n                       (make-Union\n                         (reduce (fn [acc t] (p :Un-merge-type-inner (merge-type t acc)))\n                                 #{}\n                                 (p :Un-flatten-unions \n                                    (set (flatten-unions types))))))))))]\n    (swap! Un-cache assoc (set types) res)\n    res))))", :ns "clojure.core.typed.type-ctors", :name "Un", :file "clojure/core/typed/type_ctors.clj", :column 1, :line 324, :arglists ([& types])}
{:type :fn, :src "(defn reduce-type-transform\n  \"Given a function f, left hand type t, and arguments, reduce the function\n  over the left hand types with each argument in turn.\n  \n  Arguments will not be touched, it is up to f to resolve TCResults as needed.\n  However, unions returned by f will be expanded, so the left hand type argument\n  will not be a (raw) Union.\n  \n  Reduction is skipped once nil is returned, or optional predicate :when\n  returns false.\"\n  [func t args & {pred :when}]\n  {:post [((some-fn nil? r/Type?) %)]}\n  (let [ok? #(and % (if pred (pred %) true))]\n    (union-or-nil\n     (reduce\n      (fn [left-types arg]\n        (if (every? ok? left-types)\n          (for [left left-types\n                res (type-into-vector (func left arg))]\n            res)\n          [nil]))\n      (resolved-type-vector t)\n      args))))", :ns "clojure.core.typed.type-ctors", :name "reduce-type-transform", :file "clojure/core/typed/type_ctors.clj", :column 1, :line 2163, :arglists ([func t args & {pred :when}]), :doc "Given a function f, left hand type t, and arguments, reduce the function\n  over the left hand types with each argument in turn.\n  \n  Arguments will not be touched, it is up to f to resolve TCResults as needed.\n  However, unions returned by f will be expanded, so the left hand type argument\n  will not be a (raw) Union.\n  \n  Reduction is skipped once nil is returned, or optional predicate :when\n  returns false."}
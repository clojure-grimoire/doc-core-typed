{:type :fn, :src "(defn RClass-supers* \n  \"Return a set of ancestors to the RClass\"\n  [{:keys [the-class] :as rcls}]\n  {:pre [(r/RClass? rcls)]\n   :post [((con/sorted-set-c? r/Type?) %)]}\n  (u/p :ctors/RClass-supers*\n  ;(prn \"RClass-supers*\" the-class (ind/unparse-type rcls))\n  (let [cache-key rcls\n        cache-hit (@supers-cache cache-key)]\n    (if cache-hit\n      (u/p :ctors/RClass-supers-cache-hit\n       cache-hit)\n      (u/p :ctors/RClass-supers-cache-miss\n        (let [unchecked-ancestors (RClass-unchecked-ancestors* rcls)\n              ;_ (prn \"unchecked-ancestors\" unchecked-ancestors)\n              replacements (RClass-replacements* rcls)\n              ;_ (prn \"replacements\" (map ind/unparse-type (vals replacements)))\n              ;set of symbols of Classes we haven't explicitly replaced\n              java-supers (set (map coerce/Class->symbol (-> the-class coerce/symbol->Class supers)))\n              replace-keys (set (keys replacements))\n              not-replaced (set/difference java-supers\n                                           replace-keys)\n              ;(prn \"not-replaced\" not-replaced)\n              bad-replacements (set/difference replace-keys\n                                               java-supers)\n              _ (when (seq bad-replacements)\n                  (err/int-error (str \"Bad RClass replacements for \" the-class \": \" bad-replacements)))\n              res (r/sorted-type-set\n                    (set/union (binding [*current-RClass-super* the-class]\n                                 (let [rs (t/for [csym :- t/Sym, not-replaced] :- r/Type\n                                            (RClass-of-with-unknown-params\n                                              csym\n                                              :warn-msg (when (.contains (str the-class) \"clojure.lang\")\n                                                          (str \"RClass ancestor for \" the-class \" defaulting \"\n                                                               \"to most general parameters\"))))]\n                                   (apply set/union (set rs) (map (t/fn [r :- r/Type]\n                                                                    {:pre [(r/RClass? r)]}\n                                                                    (RClass-supers* r))\n                                                                  rs))))\n                               (set (vals replacements))\n                               #{(RClass-of Object)}\n                               unchecked-ancestors))]\n          ;(prn \"supers\" the-class res)\n          (when-not (<= (count (filter (some-fn r/FnIntersection? r/Poly? r/PolyDots?) res))\n                        1)\n            (err/int-error \n              (str \"Found more than one function supertype for RClass \" (ind/unparse-type rcls) \": \\n\"\n                   (mapv ind/unparse-type (filter (some-fn r/FnIntersection? r/Poly? r/PolyDots?) res))\n                   \"\\nReplacements:\" (into {} (map (t/fn [[k v] :- '[t/Any r/Type]] [k (ind/unparse-type v)])\n                                                   replacements))\n                   \"\\nNot replaced:\" not-replaced\n                   (try (throw (Exception. \"\"))\n                        (catch Exception e\n                          (with-out-str (clojure.repl/pst e 40)))))))\n          (t/tc-ignore\n            (swap! supers-cache assoc cache-key res))\n          res))))))", :ns "clojure.core.typed.type-ctors", :name "RClass-supers*", :file "clojure/core/typed/type_ctors.clj", :column 1, :line 968, :arglists ([{:keys [the-class], :as rcls}]), :doc "Return a set of ancestors to the RClass"}
{:type :fn, :src "(defn make-HMap \n  \"Make a heterogeneous map type for the given options.\n  Handles duplicate keys between map properties.\n  \n  Options:\n  - :mandatory    a map of mandatory entries\n                  Default: {}\n  - :optional     a map of optional entries\n                  Default: {}\n  - :absent-keys  a set of types that are not keys this/these maps\n                  Default: #{}\n  - :complete?    creates a complete map if true, or a partial map if false\n                  Default: false\"\n  [& {:keys [mandatory optional complete? absent-keys]\n      :or {mandatory {} optional {} complete? false absent-keys #{}}\n      :as opt}]\n  {:post [(r/Type? %)]}\n  (assert (set/subset? (set (keys opt))\n                       #{:mandatory :optional :complete? :absent-keys})\n          (set (keys opt)))\n  (assert ((con/hash-c? r/Type? r/Type?) mandatory)\n          (pr-str mandatory))\n  (assert ((con/hash-c? r/Type? r/Type?) optional)\n          (pr-str optional))\n  (assert ((con/set-c? r/Type?) absent-keys)\n          (pr-str absent-keys))\n  (assert (con/boolean? complete?)\n          (pr-str complete?))\n  ; simplifies to bottom with contradictory keys\n  (cond \n    (or (seq (set/intersection (set (keys mandatory))\n                               (set absent-keys)))\n        (some #{bottom} (concat (vals mandatory)\n                                (vals optional))))\n      bottom\n\n    (not\n      (every? allowed-hmap-key?\n              (concat (keys mandatory)\n                      (keys optional)\n                      absent-keys)))\n      (upcast-hmap* mandatory optional absent-keys complete?)\n\n    :else\n      (let [optional-now-mandatory (set/intersection\n                                     (set (keys optional))\n                                     (set (keys mandatory)))\n            optional-now-absent (set/intersection\n                                  (set (keys optional))\n                                  absent-keys)\n            _ (assert (empty? \n                        (set/intersection optional-now-mandatory\n                                          optional-now-absent)))]\n        (r/HeterogeneousMap-maker \n          (merge-with In mandatory (select-keys optional optional-now-mandatory))\n          (apply dissoc optional (set/union optional-now-absent\n                                            optional-now-mandatory))\n          ; throw away absents if complete\n          (if complete?\n            #{}\n            (set/union absent-keys optional-now-absent))\n          (not complete?)))))", :ns "clojure.core.typed.type-ctors", :name "make-HMap", :file "clojure/core/typed/type_ctors.clj", :column 1, :line 179, :arglists ([& {:keys [mandatory optional complete? absent-keys], :or {mandatory {}, optional {}, complete? false, absent-keys #{}}, :as opt}]), :doc "Make a heterogeneous map type for the given options.\n  Handles duplicate keys between map properties.\n  \n  Options:\n  - :mandatory    a map of mandatory entries\n                  Default: {}\n  - :optional     a map of optional entries\n                  Default: {}\n  - :absent-keys  a set of types that are not keys this/these maps\n                  Default: #{}\n  - :complete?    creates a complete map if true, or a partial map if false\n                  Default: false"}
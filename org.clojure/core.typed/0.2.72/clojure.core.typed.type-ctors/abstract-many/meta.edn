{:type :fn, :src "(defn abstract-many \n  \"Names Type -> Scope^n  where n is (count names)\"\n  [names ty]\n  {:pre [(every? symbol? names)\n         ((some-fn r/Type? r/TypeFn?) ty)]}\n  (letfn [(name-to \n            ([name count type] (name-to name count type 0 type))\n            ([name count type outer ty]\n             (letfn [(sb [t] (name-to name count type outer t))]\n               (f/fold-rhs ::abstract-many\n                 {:type-rec sb\n                  :filter-rec (f/sub-f sb ::abstract-many)\n                  :object-rec (f/sub-o sb ::abstract-many)\n                  :locals {:name name\n                           :count count\n                           :outer outer\n                           :sb sb\n                           :name-to name-to}}\n                 ty))))]\n    (if (empty? names)\n      ty\n      (let [n (count names)]\n        (loop [ty ty\n               names names\n               count (dec n)]\n          (if (zero? count)\n            (add-scopes n (name-to (first names) 0 ty))\n            (recur (name-to (first names) count ty)\n                   (next names)\n                   (dec count))))))))", :ns "clojure.core.typed.type-ctors", :name "abstract-many", :file "clojure/core/typed/type_ctors.clj", :column 1, :line 1866, :arglists ([names ty]), :doc "Names Type -> Scope^n  where n is (count names)"}
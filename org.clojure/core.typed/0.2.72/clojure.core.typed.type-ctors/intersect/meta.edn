{:type :fn, :src "(defn intersect [t1 t2]\n  {:pre [(r/Type? t1)\n         (r/Type? t2)\n         #_(not (r/Union? t1))\n         #_(not (r/Union? t2))]\n   :post [(r/Type? %)]}\n  (let [subtype? @(subtype?-var)]\n    ;(prn \"intersect\" (map ind/unparse-type [t1 t2]))\n    (if-let [hit (@intersect-cache (set [t1 t2]))]\n      (do\n        ;(prn \"intersect hit\" (ind/unparse-type hit))\n        (p :intersect-cache-hit)\n        hit)\n      (let [_ (p :intersect-cache-miss)\n            t (cond\n                (and (r/HeterogeneousMap? t1)\n                     (r/HeterogeneousMap? t2))\n                  (intersect-HMap t1 t2)\n\n                ;RClass's with the same base, intersect args pairwise\n                (and (r/RClass? t1)\n                     (r/RClass? t2)\n                     (= (:the-class t1) (:the-class t2)))\n                (let [args (doall (map intersect (:poly? t1) (:poly? t2)))]\n                  ; if a new arg is bottom when none of the old args are bottom,\n                  ; reduce type to bottom\n                  (if (some (fn [[new [old1 old2]]]\n                              (and (every? (complement #{(Un)}) [old1 old2])\n                                   (#{(Un)} new)))\n                            (map vector args (map vector (:poly? t1) (:poly? t2))))\n                    (Un)\n                    (RClass-of (:the-class t1) args)))\n\n                (not (overlap t1 t2)) bottom\n\n                (subtype? t1 t2) t1\n                (subtype? t2 t1) t2\n                :else (do\n                        #_(prn \"failed to eliminate intersection\" (make-Intersection [t1 t2]))\n                        (make-Intersection [t1 t2])))]\n        (swap! intersect-cache assoc (set [t1 t2]) t)\n        ;(prn \"intersect miss\" (ind/unparse-type t))\n        t))))", :ns "clojure.core.typed.type-ctors", :name "intersect", :file "clojure/core/typed/type_ctors.clj", :column 1, :line 426, :arglists ([t1 t2])}
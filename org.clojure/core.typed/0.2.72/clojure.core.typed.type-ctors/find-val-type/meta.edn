{:type :fn, :src "(defn find-val-type [t k default]\n  {:pre [(r/Type? t)\n         (r/Type? k)\n         ((some-fn nil? r/Type?) default)]\n   :post [(r/Type? %)]}\n  (let [t (fully-resolve-type t)]\n    (cond\n      ; propagate the error\n      (r/TCError? t) t\n      (r/F? t) (let [bnd (free-ops/free-with-name-bnds (:name t))\n                     _ (when-not bnd\n                         (err/int-error (str \"No bounds for type variable: \" name bnds/*current-tvar-bnds*)))]\n                 (find-val-type (:upper-bound bnd) k default))\n      (r/Nil? t) (or default r/-nil)\n      (r/AssocType? t) (let [t* (apply ind/assoc-pairs-noret (:target t) (:entries t))]\n                         (cond\n                           (:dentries t) (do\n                                           ;(prn \"dentries NYI\")\n                                           r/-any)\n                           (r/HeterogeneousMap? t*) (find-val-type t* k default)\n\n                           (and (not t*)\n                                (r/F? (:target t))\n                                (every? keyword-value? (map first (:entries t))))\n                           (let [hmap (apply ind/assoc-pairs-noret (-partial-hmap {}) (:entries t))]\n                             (if (r/HeterogeneousMap? hmap)\n                               (find-val-type hmap k default)\n                               r/-any))\n                           :else r/-any))\n      (r/HeterogeneousMap? t) (let [^HeterogeneousMap t t]\n                                ; normal case, we have the key declared present\n                                (if-let [v (get (.types t) k)]\n                                  v\n                                  ; if key is known absent, or we have a complete map, we know precisely the result.\n                                  (if (or (contains? (.absent-keys t) k)\n                                          (complete-hmap? t))\n                                    (do\n                                      #_(tc-warning\n                                        \"Looking up key \" (ind/unparse-type k) \n                                        \" in heterogeneous map type \" (ind/unparse-type t)\n                                        \" that declares the key always absent.\")\n                                      (or default r/-nil))\n                                    ; if key is optional the result is the val or the default\n                                    (if-let [opt (get (:optional t) k)]\n                                      (Un opt (or default r/-nil))\n                                      ; otherwise result is t/Any\n                                      (do #_(tc-warning \"Looking up key \" (ind/unparse-type k)\n                                                        \" in heterogeneous map type \" (ind/unparse-type t)\n                                                        \" which does not declare the key absent \")\n                                          r/-any)))))\n\n      (r/Record? t) (find-val-type (Record->HMap t) k default)\n\n      (r/Intersection? t) (apply In \n                               (for [t* (:types t)]\n                                 (find-val-type t* k default)))\n      (r/Union? t) (apply Un\n                        (for [t* (:types t)]\n                          (find-val-type t* k default)))\n      (r/RClass? t)\n      (->\n        (ind/check-funapp nil nil (r/ret (ind/parse-type \n                                     ;same as clojure.core/get\n                                     `(t/All [x# y#]\n                                           (t/IFn \n                                             ;no default\n                                             [(t/Set x#) t/Any ~'-> (t/Option x#)]\n                                             [nil t/Any ~'-> nil]\n                                             [(t/U nil (clojure.lang.ILookup t/Any x#)) t/Any ~'-> (t/U nil x#)]\n                                             [java.util.Map t/Any ~'-> (t/U nil t/Any)]\n                                             [String t/Any ~'-> (t/U nil Character)]\n                                             ;default\n                                             [(t/Set x#) t/Any y# ~'-> (t/U y# x#)]\n                                             [nil t/Any y# ~'-> y#]\n                                             [(t/U nil (clojure.lang.ILookup t/Any x#)) t/Any y# ~'-> (t/U y# x#)]\n                                             [java.util.Map t/Any y# ~'-> (t/U y# t/Any)]\n                                             [String t/Any y# ~'-> (t/U y# Character)]\n                                             ))))\n                      [(r/ret t) (r/ret (or default r/-nil))] nil)\n        r/ret-t)\n      :else r/-any)))", :ns "clojure.core.typed.type-ctors", :name "find-val-type", :file "clojure/core/typed/type_ctors.clj", :column 1, :line 2241, :arglists ([t k default])}
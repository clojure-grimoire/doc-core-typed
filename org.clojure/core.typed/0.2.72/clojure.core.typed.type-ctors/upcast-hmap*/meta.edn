{:type :fn, :src "(defn upcast-hmap* [mandatory optional absent-keys complete?]\n  (if complete?\n    (In (let [ks (apply Un (mapcat keys [mandatory optional]))\n              vs (apply Un (mapcat vals [mandatory optional]))]\n          (impl/impl-case\n            :clojure (RClass-of 'clojure.lang.APersistentMap [ks vs])\n            :cljs (In (Protocol-of 'cljs.core/IMap [ks vs])\n                      (Protocol-of 'cljs.core/ICollection [r/-any])\n                      (Protocol-of 'cljs.core/IAssociative [ks vs])\n                      (Protocol-of 'cljs.core/ISeqable [r/-any]))))\n        (r/make-CountRange \n          ; assume all optional entries are absent\n          #_:lower\n          (count mandatory)\n          ; assume all optional entries are present\n          #_:upper\n          (+ (count mandatory)\n             (count optional))))\n    (In (impl/impl-case\n          :clojure (RClass-of 'clojure.lang.APersistentMap [r/-any r/-any])\n          :cljs (Protocol-of 'cljs.core/IMap [r/-any r/-any]))\n        (r/make-CountRange \n          ; assume all optional entries are absent\n          #_:lower\n          (count mandatory)\n          ; partial hmap can be infinite count\n          #_:upper\n          nil))))", :ns "clojure.core.typed.type-ctors", :name "upcast-hmap*", :file "clojure/core/typed/type_ctors.clj", :column 1, :line 138, :arglists ([mandatory optional absent-keys complete?])}
{:type :fn, :src "(defn TypeFn-body* [names typefn]\n  {:pre [(every? symbol? names)\n         (r/TypeFn? typefn)]}\n  (u/p :ctors/TypeFn-body*\n  (assert (= (:nbound typefn) (count names)) \"Wrong number of names\")\n  (let [bbnds (TypeFn-bbnds* names typefn)\n        body (free-ops/with-bounded-frees\n               (zipmap (map r/make-F names) bbnds)\n               (instantiate-many names (:scope typefn)))\n        ; We don't check variances are consistent at parse-time. Instead\n        ; we check at instantiation time. This avoids some implementation headaches,\n        ; like dealing with partially defined types.\n        fv-variances (impl/v 'clojure.core.typed.frees/fv-variances)\n        vs (free-ops/with-bounded-frees \n             (zipmap (map r/make-F names) bbnds)\n             (fv-variances body))\n        _ (when *TypeFn-variance-check*\n            (doseq [[nme variance] (map vector names (:variances typefn))]\n              (when-let [actual-v (vs nme)]\n                (when-not (= (vs nme) variance)\n                  (binding [vs/*current-env* (or (some-> typefn meta :env)\n                                                 vs/*current-env*)]\n                    (err/int-error (str \"Type variable \" (-> nme r/make-F r/F-original-name) \n                                        \" appears in \" (name actual-v) \" position \"\n                                        \"when declared \" (name variance)\n                                        \", in \" (binding [*TypeFn-variance-check* false]\n                                                  (ind/unparse-type typefn)))))))))]\n    body)))", :ns "clojure.core.typed.type-ctors", :name "TypeFn-body*", :file "clojure/core/typed/type_ctors.clj", :column 1, :line 1068, :arglists ([names typefn])}
{:type :fn, :src "(defn overlap [t1 t2]\n  (let [subtype? @(subtype?-var)\n        t1 (fully-resolve-type t1)\n        t2 (fully-resolve-type t2)\n        eq (= t1 t2)\n        hmap-and-seq? (fn [h s] (and (r/HeterogeneousMap? h)\n                                     (impl/impl-case\n                                       :clojure (and (r/RClass? s)\n                                                     ('#{clojure.lang.ISeq} (:the-class s)))\n                                       :cljs (and (r/Protocol? s)\n                                                  ('#{cljs.core/ISeq} (:the-var s))))))\n        hvec-and-seq? (fn [h s] (and (r/HeterogeneousVector? h)\n                                     (impl/impl-case\n                                       :clojure (and (r/RClass? s)\n                                                     ('#{clojure.lang.ISeq} (:the-class s)))\n                                       :cljs (and (r/Protocol? s)\n                                                  ('#{cljs.core/ISeq} (:the-var s))))))\n        record-and-iseq? (fn [r s]\n                           (and (r/Record? r)\n                                (subtype? s (impl/impl-case\n                                              :clojure (RClass-of clojure.lang.ISeq [r/-any])\n                                              :cljs (Protocol-of 'cljs.core/ISeq [r/-any])))))]\n    (cond \n      eq eq\n\n      (and (r/Value? t1)\n           (r/Value? t2))\n      eq\n\n      (r/Union? t1)\n      (boolean \n        (some #(overlap % t2) (.types ^Union t1)))\n\n      (r/Union? t2)\n      (boolean \n        (some #(overlap t1 %) (.types ^Union t2)))\n\n      (r/Intersection? t1)\n      (every? #(overlap % t2) (.types ^Intersection t1))\n\n      (r/Intersection? t2)\n      (every? #(overlap t1 %) (.types ^Intersection t2))\n\n      (and (r/NotType? t1)\n           (r/NotType? t2))\n      ;FIXME what if both are Not's?\n      true\n\n      ; eg. (overlap (Not Number) Integer) => false\n      ;     (overlap (Not Integer) Number) => true\n      ;     (overlap (Not y) x) => true\n      (r/NotType? t1)\n      (let [neg-type (fully-resolve-type (:type t1))]\n        (or (some (some-fn r/B? r/F?) [neg-type t2])\n            (not (overlap neg-type t2))))\n\n      (r/NotType? t2)\n      ;switch arguments to catch above case\n      (overlap t2 t1)\n\n      ;if both are Classes, and at least one isn't an interface, then they must be subtypes to have overlap\n;      (and (r/RClass? t1)\n;           (r/RClass? t2)\n;           (let [{t1-flags :flags} (reflect/type-reflect (r/RClass->Class t1))\n;                 {t2-flags :flags} (reflect/type-reflect (r/RClass->Class t2))]\n;             (some (complement :interface) [t1-flags t2-flags])))\n;      (or (subtype? t1 t2)\n;          (subtype? t2 t1))\n      (and (r/RClass? t1)\n           (r/RClass? t2))\n      (let [_ (impl/assert-clojure)\n            {t1-flags :flags} (reflect/type-reflect (r/RClass->Class t1))\n            {t2-flags :flags} (reflect/type-reflect (r/RClass->Class t2))]\n        ; there is only an overlap if a class could have both classes as parents\n        (or (subtype? t1 t2)\n            (subtype? t2 t1)\n            ; from here they are disjoint\n\n            (cond\n              ; no potential ancestors\n              (some :final [t1-flags t2-flags]) false\n              ; if we have two things that are not interfaces, ie. abstract, normal\n              ; classes, there is no possibility of overlap\n              (every? (complement :interface) [t1-flags t2-flags]) false\n              :else true)))\n\n      (some r/Extends? [t1 t2])\n      (let [[^Extends the-extends other-type] (if (r/Extends? t1)\n                                                [t1 t2]\n                                                [t2 t1])]\n        ; returns true if at least one +ve type overlaps, and if\n        ; no negative types overlap, else false\n        (boolean\n          (and (some (fn [pos] (overlap pos other-type)) (.extends the-extends))\n               (not-any? (fn [neg] (overlap neg other-type)) (.without the-extends)))))\n\n      (or (r/Value? t1)\n          (r/Value? t2)) \n      (or (subtype? t1 t2)\n          (subtype? t2 t1))\n\n      (and (r/CountRange? t1)\n           (r/CountRange? t2)) \n      (countrange-overlap? t1 t2)\n\n      (and (r/HeterogeneousMap? t1)\n           (r/HeterogeneousMap? t2)) \n        (let [common-mkeys (set/intersection \n                             (set (-> t1 :types keys))\n                             (set (-> t2 :types keys)))]\n          (cond \n            ; if there is an intersection in the mandatory keys\n            ; each entry in common should overlap\n            (not (empty? common-mkeys))\n              (every? identity\n                      (for [[k1 v1] (select-keys (:types t1) common-mkeys)]\n                        (let [v2 ((:types t2) k1)]\n                          (assert v2)\n                          (overlap v1 v2))))\n            ;TODO more cases. incorporate completeness\n            :else true))\n\n      ;for map destructuring mexpansion\n      (or (hmap-and-seq? t1 t2)\n          (hmap-and-seq? t2 t1))\n      false\n\n      ;for vector destructuring mexpansion\n      (or (hvec-and-seq? t1 t2)\n          (hvec-and-seq? t2 t1))\n      false\n\n      ;for map destructuring of records. A record is never an ISeq\n      (or (record-and-iseq? t1 t2)\n          (record-and-iseq? t2 t1))\n      false\n\n      (and (AnyHSequential? t1)\n           (AnyHSequential? t2))\n      (let [rest-sub? (fn [t1 t2]\n                             ; punt on drest\n                        (and (not-any? :drest [t1 t2])\n                             (or (== (count (:types t1))\n                                     (count (:types t2)))\n                                 (and (<= (count (:types t1))\n                                          (count (:types t2)))\n                                      (:rest t1)))\n                             (every? identity\n                                     (map subtype?\n                                          ; rest type is non-nil if needed.\n                                          (u/pad-right (count (:types t2))\n                                                       (:types t1)\n                                                       (:rest t1))\n                                          (:types t2)))\n                             (if (every? :rest [t1 t2])\n                               (subtype? (:rest t1) (:rest t2))\n                               true)))]\n        (or (rest-sub? t1 t2)\n            (rest-sub? t2 t1)))\n\n      :else true)))", :ns "clojure.core.typed.type-ctors", :name "overlap", :file "clojure/core/typed/type_ctors.clj", :column 1, :line 1535, :arglists ([t1 t2])}
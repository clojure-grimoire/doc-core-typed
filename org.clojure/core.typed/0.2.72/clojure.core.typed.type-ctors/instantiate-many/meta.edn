{:type :fn, :src "(defn instantiate-many \n  \"instantiate-many : List[Symbols] Scope^n -> Type\n  Instantiate de Bruijn indices in sc to frees named by\n  images, preserving upper/lower bounds\"\n  [images sc]\n  {:pre [(every? symbol? images)\n         (or (r/Scope? sc)\n             (empty? images))]\n   :post [((some-fn r/Type? r/TypeFn?) %)]}\n  (u/p :ctors/instantiate-many\n  (letfn [(replace \n            ([image count type] (replace image count type 0 type))\n            ([image count type outer ty]\n             (letfn [(sb [t] (replace image count type outer t))]\n               (let [sf (f/sub-f sb ::instantiate-many)]\n                 (f/fold-rhs ::instantiate-many\n                   {:type-rec sb \n                    :filter-rec sf \n                    :object-rec (f/sub-o sb ::instantiate-many)\n                    :locals {:count count\n                             :outer outer\n                             :image image\n                             :sb sb\n                             :type type\n                             :replace replace}}\n                   ty)))))]\n    (if (empty? images)\n      sc\n      (let [n (count images)]\n        (loop [ty (remove-scopes n sc)\n               images images\n               count (dec n)]\n          (if (zero? count)\n            (replace (first images) 0 ty)\n            (recur (replace (first images) count ty)\n                   (next images)\n                   (dec count)))))))))", :ns "clojure.core.typed.type-ctors", :name "instantiate-many", :file "clojure/core/typed/type_ctors.clj", :column 1, :line 2008, :arglists ([images sc]), :doc "instantiate-many : List[Symbols] Scope^n -> Type\n  Instantiate de Bruijn indices in sc to frees named by\n  images, preserving upper/lower bounds"}
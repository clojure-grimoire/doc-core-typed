{:type :fn, :src "(defn expected-vals\n  \"Returns a sequence of (Nilable TCResults) to use as expected types for type\n  checking the values of a literal map expression\"\n  [key-types expected]\n  {:pre [(every? r/Type? key-types)\n         ((some-fn r/TCResult? nil?) expected)]\n   :post [(every? (some-fn nil? r/TCResult?) %)\n          (= (count %)\n             (count key-types))]}\n  (let [expected (when expected \n                   (c/fully-resolve-type (r/ret-t expected)))\n        flat-expecteds (when expected\n                         (mapv c/fully-resolve-type\n                               (if (r/Union? expected)\n                                 (:types expected)\n                                 [expected])))\n        no-expecteds (repeat (count key-types) nil)]\n    (cond \n      ; If every key in this map expression is a Value, let's try and\n      ; make use of our expected type for each individual entry. This is\n      ; most useful for `extend`, where we have HMaps of functions, and\n      ; we want to forward the expected types to each val, a function.\n      ;\n      ; The expected type also needs to be an expected shape:\n      ; - a HMap or union of just HMaps\n      ; - each key must have exactly one possible type if it is\n      ;   present\n      ; - if a key is absent in a HMap type, it must be explicitly\n      ;   absent\n      (and expected \n           (every? r/Value? key-types)\n           (every? r/HeterogeneousMap? flat-expecteds))\n        (let [hmaps flat-expecteds]\n          (reduce (fn [val-expecteds ktype]\n                    ; also includes this contract wrapped in a Reduced\n                    ; The post-condition for `expected-vals` catches this anyway\n                    ;{:post [(every? (some-fn nil? r/TCResult?) %)]}\n\n                    (let [; find the ktype key in each hmap.\n                          ; - If ktype is present in mandatory or optional then we either use the entry's val type \n                          ; - otherwise if ktype is explicitly forbidden via :absent-keys or completeness\n                          ;   we skip the entry.\n                          ; - otherwise we give up and don't check this as a hmap, return nil\n                          ;   that gets propagated up\n                          corresponding-vals \n                          (reduce (fn [corresponding-vals {:keys [types absent-keys optional] :as hmap}]\n                                    (if-let [v (some #(get % ktype) [types optional])]\n                                      (conj corresponding-vals v)\n                                      (cond\n                                        (or (contains? absent-keys ktype)\n                                            (c/complete-hmap? hmap))\n                                          corresponding-vals\n                                        :else \n                                          (reduced nil))))\n                                  #{} hmaps)\n                          val-expect (when (= 1 (count corresponding-vals))\n                                       (r/ret (first corresponding-vals)))]\n                      (if val-expect\n                        (conj val-expecteds val-expect)\n                        (reduced no-expecteds))))\n                  [] key-types))\n\n      ; If we expect an (IPersistentMap k v), just use the v as the expected val types\n      (and (r/RClass? expected)\n           (= (:the-class expected) 'clojure.lang.IPersistentMap))\n        (let [{[_ vt] :poly?} expected]\n          (map r/ret (repeat (count key-types) vt)))\n      ; otherwise we don't give expected types\n      :else no-expecteds)))", :ns "clojure.core.typed.check.map", :name "expected-vals", :file "clojure/core/typed/check/map.clj", :column 1, :line 14, :arglists ([key-types expected]), :doc "Returns a sequence of (Nilable TCResults) to use as expected types for type\n  checking the values of a literal map expression"}
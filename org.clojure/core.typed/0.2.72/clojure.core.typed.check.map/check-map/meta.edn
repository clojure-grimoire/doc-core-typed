{:type :fn, :src "(defn check-map [check {keyexprs :keys valexprs :vals :as expr} expected]\n  (let [ckeyexprs (mapv check keyexprs)\n        key-types (map (comp r/ret-t u/expr-type) ckeyexprs)\n\n        val-rets\n        (expected-vals key-types expected)\n\n        cvalexprs (mapv check valexprs val-rets)\n        val-types (map (comp r/ret-t u/expr-type) cvalexprs)\n\n        ts (zipmap key-types val-types)\n        actual (if (every? c/keyword-value? (keys ts))\n                 (c/-complete-hmap ts)\n                 (impl/impl-case\n                   :clojure (c/RClass-of APersistentMap [(apply c/Un (keys ts))\n                                                         (apply c/Un (vals ts))])\n                   :cljs (c/Protocol-of 'cljs.core/IMap\n                                        [(apply c/Un (keys ts))\n                                         (apply c/Un (vals ts))]) ))\n        _ (when expected\n            (when-not (sub/subtype? actual (r/ret-t expected))\n              (cu/expected-error actual (r/ret-t expected))))]\n    (assoc expr\n           :keys ckeyexprs\n           :vals cvalexprs\n           u/expr-type (r/ret actual (fo/-true-filter)))))", :ns "clojure.core.typed.check.map", :name "check-map", :file "clojure/core/typed/check/map.clj", :column 1, :line 84, :arglists ([check {keyexprs :keys, valexprs :vals, :as expr} expected])}
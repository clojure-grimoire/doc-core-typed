{:type :fn, :src "(defn check-below [tr1 expected]\n  {:pre [((some-fn r/TCResult? r/Type?) tr1)\n         ((some-fn r/TCResult? r/Type?) expected)]\n   :post [((some-fn r/TCResult? r/Type?) %)]}\n  (letfn [(filter-better? [{f1+ :then f1- :else :as f1}\n                           {f2+ :then f2- :else :as f2}]\n            {:pre [(fl/Filter? f1)\n                   (fl/Filter? f2)]\n             :post [(con/boolean? %)]}\n            (cond\n              (= f1 f2) true\n              (and (fo/implied-atomic? f2+ f1+)\n                   (fo/implied-atomic? f2- f1-)) true\n              :else false))\n          (object-better? [o1 o2]\n            {:pre [(obj/RObject? o1)\n                   (obj/RObject? o2)]\n             :post [(con/boolean? %)]}\n            (cond\n              (= o1 o2) true\n              ((some-fn obj/NoObject? obj/EmptyObject?) o2) true\n              :else false))]\n    ;tr1 = arg\n    ;expected = dom\n    ; Omitted some cases dealing with multiple return values\n    (cond\n      (and (r/TCResult? tr1)\n           (r/TCResult? expected)\n           (= (c/Un) (r/ret-t tr1))\n           (fl/NoFilter? (r/ret-f expected))\n           (obj/NoObject? (r/ret-o expected)))\n      (let [ts2 (:t tr1)]\n        (r/ret ts2))\n\n      (and (r/TCResult? tr1)\n           (= (c/Un) (r/ret-t tr1)))\n      expected\n\n      (and (r/TCResult? tr1)\n           (r/TCResult? expected)\n           (= (fo/-FS fl/-top fl/-top)\n              (r/ret-f expected))\n           (obj/EmptyObject? (r/ret-o expected)))\n      (let [{t1 :t f1 :fl o1 :o} tr1\n            {t2 :t} expected]\n        (when-not (sub/subtype? t1 t2)\n          (cu/expected-error t1 t2))\n        expected)\n\n      (and (r/TCResult? tr1)\n           (r/TCResult? expected))\n      (let [{t1 :t f1 :fl o1 :o} tr1\n            {t2 :t f2 :fl o2 :o} expected]\n        (cond\n          (not (sub/subtype? t1 t2)) (cu/expected-error t1 t2)\n\n          (and (not (filter-better? f1 f2))\n               (object-better? o1 o2))\n          (err/tc-delayed-error (str \"Expected result with filter \" f2 \", got filter\"  f1))\n\n          (and (filter-better? f1 f2)\n               (not (object-better? o1 o2)))\n          (err/tc-delayed-error (str \"Expected result with object \" o2 \", got object\"  o1))\n\n          (and (not (filter-better? f1 f2))\n               (not (object-better? o1 o2)))\n          (err/tc-delayed-error (str \"Expected result with object \" o2 \", got object\"  o1 \" and filter \"\n                                   f2 \" got filter \" f1)))\n        expected)\n\n      (and (r/TCResult? tr1)\n           (r/Type? expected))\n      (let [{t1 :t f :fl o :o} tr1\n            t2 expected]\n        (when-not (sub/subtype? t1 t2)\n          (cu/expected-error t1 t2))\n        (r/ret t2 f o))\n\n      ;FIXME\n      ;; erm.. ? What is (FilterSet: (list) (list))\n      ;; TODO this case goes here, but not sure what it means \n      ;\n      ;[((? r/Type? t1) (tc-result1: t2 (FilterSet: (list) (list)) (Empty:)))\n      ; (unless (sub/subtype t1 t2)\n      ;   (tc-error/expr \"Expected ~a, but got ~a\" t2 t1))\n      ; t1]\n\n      (and (r/Type? tr1)\n           (r/TCResult? expected))\n      (let [t1 tr1\n            {t2 :t f :fl o :o} expected]\n        (if (sub/subtype? t1 t2)\n          (err/tc-delayed-error (str \"Expected result with filter \" f \" and \" o \", got \" t1))\n          (cu/expected-error t1 t2))\n        t1)\n\n      (and (r/Type? tr1)\n           (r/Type? expected))\n      (let [t1 tr1\n            t2 expected]\n        (when-not (sub/subtype? t1 t2)\n          (cu/expected-error t1 t2))\n        expected)\n\n      :else (let [a tr1\n                  b expected]\n              (err/int-error (str \"Unexpected input for check-below \" a b))))))", :ns "clojure.core.typed.check-below", :name "check-below", :file "clojure/core/typed/check_below.clj", :column 1, :line 20, :arglists ([tr1 expected])}
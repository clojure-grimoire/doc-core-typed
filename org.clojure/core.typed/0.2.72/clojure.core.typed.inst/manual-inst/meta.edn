{:type :fn, :src "(defn manual-inst \n  \"Poly Type^n -> Type\n  Substitute the type parameters of the polymorphic type\n  with given types\"\n  [ptype argtys]\n  {:pre [((some-fn r/Poly? r/PolyDots?) ptype)\n         (every? r/Type? argtys)]\n   :post [(r/Type? %)]}\n  (cond\n    (r/Poly? ptype)\n    (let [_ (when-not (= (:nbound ptype) (count argtys)) \n              (err/int-error\n                (str \"Wrong number of arguments to instantiate polymorphic type (expected \" (:nbound ptype)\n                     \", actual \" (count argtys)\n                     \"\\n\\nTarget:\\n\" (prs/unparse-type ptype)\n                     \"\\n\\nActual arguments:\\n\" (string/join \" \" (map prs/unparse-type argtys)))))\n          names (c/Poly-fresh-symbols* ptype)\n          body (c/Poly-body* names ptype)\n          bbnds (c/Poly-bbnds* names ptype)]\n      (free-ops/with-bounded-frees (zipmap (map r/make-F names) bbnds)\n        (doseq [[nme ty bnds] (map vector names argtys bbnds)]\n          (assert (not (:higher-kind bnds)))\n          (let [lower-bound (subst/substitute-many (:lower-bound bnds) argtys names)\n                upper-bound (subst/substitute-many (:upper-bound bnds) argtys names)]\n            (when-not (sub/subtype? lower-bound upper-bound)\n              (err/int-error\n                (str \"Lower-bound \" (prs/unparse-type lower-bound)\n                     \" is not below upper-bound \" (prs/unparse-type upper-bound))))\n            (when-not (and (sub/subtype? ty upper-bound)\n                           (sub/subtype? lower-bound ty))\n              (err/int-error\n                (str \"Manually instantiated type \" (prs/unparse-type ty)\n                     \" is not between bounds \" (prs/unparse-type lower-bound)\n                     \" and \" (prs/unparse-type upper-bound))))))\n        (subst/substitute-many body argtys names)))\n\n    (r/PolyDots? ptype)\n    (let [nrequired-types (dec (:nbound ptype))\n          _ (when-not (<= nrequired-types (count argtys)) \n              (err/int-error\n                (str \"Insufficient arguments to instantiate dotted polymorphic type\")))\n          names (c/PolyDots-fresh-symbols* ptype)\n          body (c/PolyDots-body* names ptype)\n          bbnds (c/PolyDots-bbnds* names ptype)]\n      (free-ops/with-bounded-frees (zipmap (-> (map r/make-F names) butlast) (butlast bbnds))\n        (doseq [[nme ty bnds] (map vector names argtys bbnds)]\n          (let [lower-bound (subst/substitute-many (:lower-bound bnds) argtys names)\n                upper-bound (subst/substitute-many (:upper-bound bnds) argtys names)]\n            (when-not (sub/subtype? lower-bound upper-bound)\n              (err/int-error\n                (str \"Lower-bound \" (prs/unparse-type lower-bound)\n                     \" is not below upper-bound \" (prs/unparse-type upper-bound))))\n            (when-not (and (sub/subtype? ty upper-bound)\n                           (sub/subtype? lower-bound ty))\n              (err/int-error\n                (str \"Manually instantiated type \" (prs/unparse-type ty)\n                     \" is not between bounds \" (prs/unparse-type lower-bound)\n                     \" and \" (prs/unparse-type upper-bound))))))\n        (-> body\n          ; expand dotted pre-types in body\n          (trans/trans-dots (last names) ;the bound\n                            (drop (dec (:nbound ptype)) argtys)) ;the types to expand pre-type with\n          ; substitute normal variables\n          (subst/substitute-many (take nrequired-types argtys) (butlast names)))))))", :ns "clojure.core.typed.inst", :name "manual-inst", :file "clojure/core/typed/inst.clj", :column 1, :line 39, :arglists ([ptype argtys]), :doc "Poly Type^n -> Type\n  Substitute the type parameters of the polymorphic type\n  with given types"}
{:type :fn, :src "(defn subtypes*-varargs [A0 argtys dom rst kws]\n  {:pre [((some-fn nil? r/Type?) rst)\n         ((some-fn nil? r/KwArgs?) kws)]}\n  (letfn [(all-mandatory-kws? [found-kws]\n            {:pre [(set? found-kws)]}\n            (empty? (set/difference (set (keys (:mandatory kws)))\n                                    found-kws)))]\n    (loop [dom dom\n           argtys argtys\n           A A0\n           found-kws #{}]\n      (cond\n        (and (empty? dom) (empty? argtys)) \n        (if (all-mandatory-kws? found-kws)\n          A\n          (fail! argtys dom))\n\n        (empty? argtys) (fail! argtys dom)\n\n        (and (empty? dom) rst)\n        (if-let [A (subtypeA* A (first argtys) rst)]\n          (recur dom (next argtys) A found-kws)\n          (fail! (first argtys) rst))\n\n        (and (empty? dom) (<= 2 (count argtys)) kws)\n        (let [kw (c/fully-resolve-type (first argtys))\n              val (second argtys)\n              expected-val ((some-fn (:mandatory kws) (:optional kws))\n                            kw)]\n          (if (and expected-val (subtype? val expected-val))\n            (recur dom (drop 2 argtys) A (conj found-kws kw))\n            (fail! (take 2 argtys) kws)))\n\n        (empty? dom) (fail! argtys dom)\n        :else\n        (if-let [A (subtypeA* A0 (first argtys) (first dom))]\n          (recur (next dom) (next argtys) A found-kws)\n          (fail! (first argtys) (first dom)))))))", :ns "clojure.core.typed.subtype", :name "subtypes*-varargs", :file "clojure/core/typed/subtype.clj", :column 1, :line 918, :arglists ([A0 argtys dom rst kws])}
{:type :fn, :src "(defn subtypeA* [A s t]\n  {:pre [(r/AnyType? s)\n         (r/AnyType? t)]\n   :post [(set? %)]}\n  ;(prn \"subtypeA*\" s t)\n  (if (or (u/p :subtype/query-current-seen\n            (contains? A [s t]))\n          (= s t)\n          ; FIXME TypeFn's probably are not between Top/Bottom\n          (r/Top? t)\n          (r/Bottom? s)\n          ;TCError is top and bottom\n          (some r/TCError? [s t]))\n    A\n    (binding [*sub-current-seen* (u/p :subtype/extend-current-seen (conj A [s t]))]\n      (cond\n        (or (r/TCResult? s)\n            (r/TCResult? t))\n        (assert nil \"Cannot give TCResult to subtype\")\n\n        ; use bounds to determine subtyping between frees and types\n        ; 2 frees of the same name are handled in the (= s t) case.\n        (and (r/F? s)\n             (let [{:keys [upper-bound lower-bound] :as bnd} (free-ops/free-with-name-bnds (:name s))]\n               (if-not bnd \n                 (do #_(err/int-error (str \"No bounds for \" (:name s)))\n                     nil)\n                 (and (subtype? upper-bound t)\n                      (subtype? lower-bound t)))))\n        *sub-current-seen*\n\n        (and (r/F? t)\n             (let [{:keys [upper-bound lower-bound] :as bnd} (free-ops/free-with-name-bnds (:name t))]\n               (if-not bnd \n                 (do #_(err/int-error (str \"No bounds for \" (:name t)))\n                     nil)\n                 (and (subtype? s upper-bound)\n                      (subtype? s lower-bound)))))\n        *sub-current-seen*\n\n        (and (r/Value? s)\n             (r/Value? t))\n        ;already (not= s t)\n        (fail! s t)\n\n        (and (r/Poly? s)\n             (r/Poly? t)\n             (= (:nbound s) (:nbound t)))\n        (let [;instantiate both sides with the same fresh variables\n              names (repeatedly (:nbound s) gensym)\n              bbnds1 (c/Poly-bbnds* names s)\n              bbnds2 (c/Poly-bbnds* names t)\n              b1 (c/Poly-body* names s)\n              b2 (c/Poly-body* names t)]\n          (if (and (= bbnds1 bbnds2)\n                   (free-ops/with-bounded-frees (zipmap (map r/F-maker names) bbnds1)\n                     (subtype? b1 b2)))\n            *sub-current-seen*\n            (fail! s t)))\n\n        ;use unification to see if we can use the Poly type here\n        (and (r/Poly? s)\n             (let [names (c/Poly-fresh-symbols* s)\n                   bnds (c/Poly-bbnds* names s)\n                   b1 (c/Poly-body* names s)\n                   ;_ (prn \"try unify on left\")\n                   u (unify (zipmap names bnds) {} [b1] [t] r/-any)]\n               ;(prn \"unified on left\")\n               u))\n        *sub-current-seen*\n\n        (and (r/PolyDots? s)\n             (let [names (c/PolyDots-fresh-symbols* s)\n                   bnds (c/PolyDots-bbnds* names s)\n                   b1 (c/PolyDots-body* names s)\n                   ;_ (prn \"try PolyDots unify on left\")\n                   u (unify (zipmap (butlast names) (butlast bnds)) {(last names) (last bnds)} \n                            [b1] [t] r/-any)]\n               ;(prn \"unified on left\" u)\n               u))\n        *sub-current-seen*\n\n        (and (r/Poly? t)\n             (let [names (c/Poly-fresh-symbols* t)\n                   b (c/Poly-body* names t)]\n               (empty? (frees/fv t))))\n        (let [names (c/Poly-fresh-symbols* t)\n              b (c/Poly-body* names t)]\n          (if (subtype? s b)\n            *sub-current-seen*\n            (fail! s t)))\n\n        (r/Name? s)\n        (subtypeA* *sub-current-seen* (c/resolve-Name s) t)\n\n        (r/Name? t)\n        (subtypeA* *sub-current-seen* s (c/resolve-Name t))\n\n        (r/Mu? s)\n        (subtype (c/unfold s) t)\n\n        (r/Mu? t)\n        (subtype s (c/unfold t))\n\n        (r/App? s)\n        (subtypeA* *sub-current-seen* (c/resolve-App s) t)\n\n        (r/App? t)\n        (subtypeA* *sub-current-seen* s (c/resolve-App t))\n\n        (r/Bottom? t)\n        (fail! s t)\n\n        (and (r/TApp? s)\n             (r/TypeFn? (c/fully-resolve-type (:rator s))))\n        (let [{:keys [rands]} s\n              rator (c/fully-resolve-type (:rator s))]\n          (cond\n            (r/F? rator) (fail! s t)\n\n            (r/TypeFn? rator)\n            (let [names (c/TypeFn-fresh-symbols* rator)\n                  bbnds (c/TypeFn-bbnds* names rator)\n                  res (c/instantiate-typefn rator rands :names names)]\n              (if (subtypeA*? (conj *sub-current-seen* [s t]) res t)\n                *sub-current-seen*\n                (fail! s t)))\n\n            :else (err/int-error (str \"First argument to TApp must be TFn, actual: \" (prs/unparse-type rator)))))\n\n        (and (r/TApp? t)\n             (r/TypeFn? (c/fully-resolve-type (:rator t))))\n        (let [{:keys [rands]} t\n              rator (c/fully-resolve-type (:rator t))]\n          (cond\n            (r/F? rator) (fail! s t)\n\n            (r/TypeFn? rator)\n            (let [names (c/TypeFn-fresh-symbols* rator)\n                  res (c/instantiate-typefn rator rands :names names)]\n              (if (subtypeA*? (conj *sub-current-seen* [s t]) s res)\n                *sub-current-seen*\n                (fail! s t)))\n\n            :else (err/int-error (str \"First argument to TApp must be TFn, actual: \" (prs/unparse-type rator)))))\n\n        (r/Union? s)\n        ;use subtypeA*, throws error\n        (u/p :subtype-union-l\n        (if (every? (fn union-left [s] (subtypeA* *sub-current-seen* s t)) (:types s))\n          *sub-current-seen*\n          (fail! s t))\n           )\n\n        ;use subtypeA*?, boolean result\n        (r/Union? t)\n        (u/p :subtype-union-r\n        (if (some (fn union-right [t] (subtypeA*? *sub-current-seen* s t)) (:types t))\n          *sub-current-seen*\n          (fail! s t))\n           )\n\n        (and (r/FnIntersection? s)\n             (r/FnIntersection? t))\n        (loop [A* *sub-current-seen*\n               arr2 (:types t)]\n          (let [arr1 (:types s)]\n            (if (empty? arr2) \n              A*\n              (if-let [A (supertype-of-one-arr A* (first arr2) arr1)]\n                (recur A (next arr2))\n                (fail! s t)))))\n\n;does it matter what order the Intersection cases are?\n        (r/Intersection? t)\n        (let [ts (simplify-In t)]\n          (if (every? #(subtype? s %) ts)\n            *sub-current-seen*\n            (fail! s t)))\n\n        (r/Intersection? s)\n        (let [ss (simplify-In s)]\n          (if (some #(subtype? % t) ss)\n            *sub-current-seen*\n            (fail! s t)))\n\n        (and (r/Extends? s)\n             (r/Extends? t))\n        (if (and ;all positive information matches.\n                 ; Each t should occur in at least one s.\n                 (every? (fn extends-t [t*]\n                           (some #(subtype? % t*) (:extends s)))\n                         (:extends t))\n                 ;lhs does not explicitly implement any forbidden types.\n                 ; No negative t should be a supertype of a positive s\n                 (not-any? (fn extends-not-t [not-t*]\n                             (some #(subtype? % not-t*) (:extends s)))\n                           (:without t))\n                 ;lhs explicitly disallows same types as rhs\n                 ; Each negative t should be a supertype of some negative s\n                 (every? (fn extends-without-t[not-t*]\n                           (some #(subtype? % not-t*) (:without s)))\n                         (:without t)))\n          *sub-current-seen*\n          (fail! s t))\n\n        (r/Extends? s)\n        (let [^Extends s s]\n          (if (and (some #(subtype? % t) (.extends s))\n                   (not-any? #(subtype? % t) (.without s)))\n            *sub-current-seen*\n            (fail! s t)))\n\n        (r/Extends? t)\n        (let [^Extends t t]\n          (if (and (every? identity \n                           (doall\n                             (for [e (.extends t)]\n                               (subtype? s e))))\n                   (not-any? #(subtype? s %) (.without t)))\n            *sub-current-seen*\n            (fail! s t)))\n\n        (and (r/TApp? s)\n             (r/TApp? t)\n             (r/F? (:rator s))\n             (r/F? (:rator t))\n             (= (:rator s) (:rator t)))\n        (let [{:keys [upper-bound] :as bnd} (free-ops/free-with-name-bnds (-> s :rator :name))]\n          (cond \n            (not bnd) (err/int-error (str \"No bounds for \" (:name s)))\n            :else (let [upper-bound (c/fully-resolve-type upper-bound)]\n                    (if (and (r/TypeFn? upper-bound)\n                             (subtype-TypeFn-rands? upper-bound (:rands s) (:rands t)))\n                      *sub-current-seen*\n                      (fail! s t)))))\n\n        (and (r/TopFunction? t)\n             (r/FnIntersection? s))\n        *sub-current-seen*\n\n        ;       B <: A\n        ;_______________________________\n        ; (Not A) <: (Not B)\n        (every? r/NotType? [s t])\n        (if (subtype? (:type t) (:type s))\n          *sub-current-seen*\n          (fail! s t))\n\n        ;  A <!: B  A is not free  B is not free\n        ;________________________________________\n        ; A <: (Not B)\n;   Should this also require (fv s) U (fv t) to be empty?\n        (r/NotType? t)\n        (if (and (not-any? (some-fn r/B? r/F?) [s (:type t)])\n                 (not (subtype? s (:type t))))\n          *sub-current-seen*\n          (fail! s t))\n\n; delegate to NotType\n        (r/DifferenceType? s)\n        (subtype (apply c/In (:type s) (map r/NotType-maker (:without s)))\n                 t)\n\n        (r/DifferenceType? t)\n        (subtype s\n                 (apply c/In (:type t) (map r/NotType-maker (:without t))))\n\n        (and (r/GetType? s)\n             (not (r/F? (:target s))))\n        (subtype (c/-resolve s) t)\n\n        (and (r/GetType? t)\n             (not (r/F? (:target t))))\n        (subtype s (c/-resolve t))\n\n        (and (r/AssocType? s)\n             (r/AssocType? t)\n             (r/F? (:target s))\n             (r/F? (:target t))\n             (not-any? :dentries [s t]))\n        (if (and (= (:target s) (:target t))\n                 (subtype? (apply assoc-u/assoc-pairs-noret (c/-complete-hmap {}) (:entries s))\n                           (apply assoc-u/assoc-pairs-noret (c/-complete-hmap {}) (:entries t))))\n          *sub-current-seen*\n          (fail! s t))\n\n        (and (r/AssocType? s)\n             (r/F? (:target s))\n             (not (r/AssocType? t)))\n        (let [bnds (free-ops/free-with-name-bnds (-> s :target :name))\n              _ (assert bnds\n                        (str \"Bounds not found for free variable: \" (-> s :target :name)))]\n          (if (and (subtype? (:upper-bound bnds) t)\n                   (subtype? (apply assoc-u/assoc-pairs-noret (c/-complete-hmap {}) (:entries s))\n                             t))\n            *sub-current-seen*\n            (fail! s t)))\n      \n        ; avoids infinite expansion because associng an F is a fixed point\n        (and (r/AssocType? s)\n             (not (r/F? (:target s))))\n        (let [s-or-n (apply assoc-u/assoc-pairs-noret (:target s) (:entries s))]\n          (if (and s-or-n (subtype? s-or-n t))\n            *sub-current-seen*\n            (fail! s t)))\n\n        ; avoids infinite expansion because associng an F is a fixed point\n        (and (r/AssocType? t)\n             (not (r/F? (:target t))))\n        (let [t-or-n (apply assoc-u/assoc-pairs-noret (:target t) (:entries t))]\n          (if (and t-or-n (subtype? s t-or-n))\n            *sub-current-seen*\n            (fail! s t)))\n\n        (and (r/HSequential? s)\n             (r/HSequential? t))\n        (if (and (cond\n                   ; simple case, no rest types\n                   (and (not-any? :rest [s t])\n                        (not-any? :drest [s t]))\n                   (let []\n                     (and (= (count (:types s))\n                             (count (:types t)))\n                          (every? identity (map subtype? (:types s) (:types t)))))\n\n                   ; rest on right\n                   (and (:rest t)\n                        (not (:drest s)))\n                   (and (>= (count (:types s))\n                            (count (:types t)))\n                        (if (:rest s)\n                          (subtype? (:rest s) (:rest t))\n                          true)\n                        ;pad t to the right\n                        (every? identity (map subtype?\n                                              (:types s)\n                                              (concat (:types t)\n                                                      (repeat (- (count (:types s)) (count (:types t)))\n                                                              (:rest t))))))\n\n                   (and (:drest s)\n                        (:rest t))\n                   (and\n                     (every? identity (map subtype?\n                                           (:types s)\n                                           (concat (:types t)\n                                                   (repeat (- (count (:types s)) (count (:types t)))\n                                                           (:rest t)))))\n                     (r/Top? (:rest t)))\n\n                   ;TODO other cases\n                   :else nil\n                   )\n                 ; ignore interesting results\n                 (every? (fn hvec1 [[f1 f2]] (or (= (fops/-FS fr/-top fr/-top) f2)\n                                                 (= f1 f2)))\n                         (map vector (:fs s) (:fs t)))\n                 ; ignore interesting results\n                 (every? (fn hvec2 [[o1 o2]] (or (orep/EmptyObject? o2)\n                                                 (= o1 o2)))\n                         (map vector (:objects s) (:objects t))))\n          *sub-current-seen*\n          (fail! s t))\n\n        (and (r/HeterogeneousVector? s)\n             (r/HeterogeneousVector? t))\n        (subtype (c/HVec->HSequential s) (c/HVec->HSequential t))\n\n        (and (r/HeterogeneousList? s)\n             (r/HeterogeneousList? t))\n        (subtype (c/HList->HSequential s) (c/HList->HSequential t))\n\n        (and (r/HeterogeneousSeq? s)\n             (r/HeterogeneousSeq? t))\n        (subtype (c/HSeq->HSequential s) (c/HSeq->HSequential t))\n\n        ; HList is a HSeq\n        (and (r/HeterogeneousList? s)\n             (r/HeterogeneousSeq? t))\n        (subtype (c/HList->HSequential s) (c/HSeq->HSequential t))\n\n        ; HVec/HList/HSeq are HSequential's\n        (and (or (r/HeterogeneousVector? s)\n                 (r/HeterogeneousList? s)\n                 (r/HeterogeneousSeq? s))\n             (r/HSequential? t))\n        (subtype (cond\n                   (r/HeterogeneousVector? s)\n                   (c/HVec->HSequential s)\n\n                   (r/HeterogeneousList? s)\n                   (c/HList->HSequential s)\n\n                   :else\n                   (c/HSeq->HSequential s))\n                 t)\n\n\n        ;every rtype entry must be in ltypes\n        ;eg. {:a 1, :b 2, :c 3} <: {:a 1, :b 2}\n        (and (r/HeterogeneousMap? s)\n             (r/HeterogeneousMap? t))\n        (let [; convention: prefix things on left with l, right with r\n              {ltypes :types labsent :absent-keys :as s} s\n              {rtypes :types rabsent :absent-keys :as t} t]\n          (if (and ; if t is complete, s must be complete ..\n                   (if (c/complete-hmap? t)\n                     (if (c/complete-hmap? s)\n                       ; mandatory keys on the right must appear as\n                       ; mandatory on the left, but extra keys may appear\n                       ; on the left\n                       (and (let [right-mkeys (set (keys rtypes))\n                                  left-mkeys (set (keys ltypes))]\n                              (set/subset? right-mkeys\n                                           left-mkeys))\n                            ; extra mandatory keys on the left must appear\n                            ; as optional on the right\n                            (let [left-extra-mkeys (set/difference (set (keys ltypes))\n                                                                       (set (keys rtypes)))\n                                  right-optional-keys (set (keys (:optional t)))]\n                              (set/subset? left-extra-mkeys\n                                           right-optional-keys)))\n                            ;Note:\n                            ; optional key keys on t must be optional or mandatory or absent in s,\n                            ; which is always the case so we don't need to check.\n                       false)\n                     true)\n                   ; all absent keys in t should be absent in s\n                   (every? identity\n                           (for [rabsent-key rabsent]\n                             ; Subtyping is good if rabsent-key is:\n                             ; 1. Absent in s\n                             ; 2. Not present in s, but s is complete\n                             (or ((set labsent) rabsent-key)\n                                 (when (c/complete-hmap? s)\n                                   (not ((set (keys ltypes)) rabsent-key))))))\n                   ; all present keys in t should be present in s\n                   (every? identity\n                           (map (fn [[k v]]\n                                  (when-let [t (get ltypes k)]\n                                    (subtype? t v)))\n                                rtypes))\n                   ; all optional keys in t should match optional/mandatory entries in s\n                   (every? identity\n                           (map (fn [[k v]]\n                                  (let [matches-entry?\n                                        (if-let [actual-v \n                                                 ((merge-with c/In\n                                                    (:types s)\n                                                    (:optional s))\n                                                  k)]\n                                          (subtype? actual-v v)\n                                          (c/complete-hmap? s))]\n                                  (cond\n                                    (c/partial-hmap? s)\n                                      (or (contains? (:absent-keys s) k)\n                                          matches-entry?)\n                                    :else matches-entry?)))\n                                (:optional t)))\n                   )\n            *sub-current-seen*\n            (fail! s t)))\n\n        (r/HeterogeneousMap? s)\n        (subtype (c/upcast-hmap s) t)\n\n        (and (r/HSet? s)\n             (r/HSet? t))\n        (subtype-HSet s t)\n\n        (r/HSet? s)\n        (subtype (c/upcast-hset s) t)\n\n        (r/KwArgsSeq? s)\n        (let [ss (if (:complete? s)\n                   (apply c/Un\n                          (concat\n                            (apply concat (:mandatory s))\n                            (apply concat (:optional s))))\n                   r/-any)\n              min-count (* 2 (count (:mandatory s)))\n              max-count (when (:complete? s)\n                          (+ min-count\n                             (* 2 (count (:optional s)))))]\n          (subtype (apply c/Un \n                          (concat\n                            (when (and (:nilable-non-empty? s)\n                                       (not (zero? min-count)))\n                              [r/-nil])\n                            [(c/In (r/make-CountRange \n                                     (max (if (:nilable-non-empty? s) \n                                            2 \n                                            0)\n                                          min-count) \n                                     max-count)\n                                   (impl/impl-case\n                                     :clojure (c/RClass-of ASeq [ss])\n                                     :cljs (c/Protocol-of 'cljs.core/ISeq [ss])))]))\n                   t))\n\n        (r/HSequential? s)\n        (let [ss (apply c/Un\n                        (concat\n                          (:types s)\n                          (when-let [rest (:rest s)]\n                            [rest])\n                          (when (:drest s)\n                            [r/-any])))]\n          (subtype (c/In (impl/impl-case\n                           :clojure (c/In (c/RClass-of clojure.lang.IPersistentCollection [ss])\n                                          (c/RClass-of clojure.lang.Sequential))\n                           :cljs (c/In (c/Protocol-of 'cljs.core/ICollection [ss])\n                                       (c/Protocol-of 'cljs.core/ISequential))\n                           #_(throw (Exception. \"TODO cljs HSequential\")))\n                         ((if (or (:rest s)\n                                  (:drest s))\n                            r/make-CountRange\n                            r/make-ExactCountRange)\n                          (count (:types s))))\n                   t))\n\n        (r/HeterogeneousVector? s)\n        (subtype (c/upcast-hvec s) t)\n\n        (r/HeterogeneousList? s)\n        (let [ss (apply c/Un\n                        (concat\n                          (:types s)\n                          #_(when-let [rest (:rest s)]\n                            [rest])\n                          #_(when (:drest s)\n                            [r/-any])))]\n          (subtype (c/In (impl/impl-case\n                           :clojure (c/RClass-of PersistentList [ss])\n                           :cljs (c/Protocol-of 'cljs.core/IList [ss]))\n                         (r/make-ExactCountRange (count (:types s))))\n                   t))\n\n        (r/HeterogeneousSeq? s)\n        (let [ss (apply c/Un\n                        (concat\n                          (:types s)\n                          (when-let [rest (:rest s)]\n                            [rest])\n                          (when (:drest s)\n                            [r/-any])))]\n          (subtype (c/In (impl/impl-case\n                           :clojure (c/RClass-of ASeq [ss])\n                           :cljs (c/Protocol-of 'cljs.core/ISeq [ss]))\n                         ((if (or (:rest s)\n                                  (:drest s))\n                            r/make-CountRange\n                            r/make-ExactCountRange)\n                          (count (:types s))))\n                   t))\n\n; The order of checking protocols and datatypes is subtle.\n; It is easier to calculate the ancestors of a datatype than\n; the descendants of a protocol, so Datatype <: Any comes \n; before Protocol <: Any.\n        (and (r/Protocol? s)\n             (r/Protocol? t))\n        (let [{var1 :the-var variances* :variances poly1 :poly?} s\n              {var2 :the-var poly2 :poly?} t]\n          ;(prn \"protocols subtype\" s t)\n          (if (and (= var1 var2)\n                   (every? (fn prcol-variance [[v l r]]\n                             (case v\n                               :covariant (subtypeA* *sub-current-seen* l r)\n                               :contravariant (subtypeA* *sub-current-seen* r l)\n                               :invariant (and (subtypeA* *sub-current-seen* l r)\n                                               (subtypeA* *sub-current-seen* r l))))\n                           (map vector variances* poly1 poly2)))\n            *sub-current-seen*\n            (fail! s t)))\n\n        (and (r/DataType? s)\n             (r/DataType? t))\n        (subtype-datatypes-or-records s t)\n\n        (and (r/DataType? s)\n             (r/Protocol? t))\n        (if (subtype-datatype-and-protocol s t)\n          *sub-current-seen*\n          (fail! s t))\n\n        (and (r/RClass? s)\n             (r/Protocol? t))\n        (subtype-rclass-protocol s t)\n\n        (and (r/Nil? s)\n             (r/Protocol? t)\n             (impl/checking-clojure?))\n        (if (contains? (c/Protocol-normal-extenders t) nil)\n          *sub-current-seen*\n          (fail! s t))\n\n        ;values are subtypes of their classes\n        (r/Value? s)\n        (let [^Value s s\n              sval (.val s)]\n          (impl/impl-case\n            :clojure (cond \n                       ; this is after the nil <: Protocol case, so we fail\n                       (nil? sval) (fail! s t)\n                       ; this is a faster path than the final case\n                       (r/RClass? t) (let [cls (let [cls (coerce/symbol->Class (:the-class t))]\n                                                 (or (boxed-primitives cls)\n                                                     cls))]\n                                       (cond\n                                         (#{Integer Long} cls) (if (or (instance? Integer sval)\n                                                                       (instance? Long sval))\n                                                                 *sub-current-seen*\n                                                                 (fail! s t))\n                                         ;handle string-as-seqable\n                                         (string? sval) (if (subtype? (c/RClass-of String) t)\n                                                          *sub-current-seen*\n                                                          (fail! s t))\n                                         :else (if (instance? cls sval) \n                                                 *sub-current-seen*\n                                                 (fail! s t))))\n                       :else (subtype (apply c/In (c/RClass-of (class sval))\n                                             (cond\n                                               ;keyword values are functions\n                                               (keyword? sval) [(c/keyword->Fn sval)]\n                                               ;strings have a known length as a seqable\n                                               (string? sval) [(r/make-ExactCountRange (count sval))]))\n                                      t))\n            :cljs (cond\n                    (integer? (.val s)) (subtype (r/IntegerCLJS-maker) t)\n                    (number? (.val s)) (subtype (r/NumberCLJS-maker) t)\n                    (string? (.val s)) (subtype (r/StringCLJS-maker) t)\n                    (con/boolean? (.val s)) (subtype (r/BooleanCLJS-maker) t)\n                    (symbol? (.val s)) (subtype (c/DataType-of 'cljs.core/Symbol) t)\n                    (keyword? (.val s)) (subtype (c/DataType-of 'cljs.core/Keyword) t)\n                    :else (fail! s t))))\n\n        (and (r/Result? s)\n             (r/Result? t))\n        (subtype-Result s t)\n\n        (and (r/PrimitiveArray? s)\n             (r/PrimitiveArray? t))\n        (subtype-PrimitiveArray s t)\n\n        (r/PrimitiveArray? s)\n        (subtype (r/PrimitiveArray-maker Object r/-any r/-any) t)\n      \n        (and (r/TypeFn? s)\n             (r/TypeFn? t))\n        (subtype-TypeFn s t)\n\n        (and (r/RClass? s)\n             (r/RClass? t))\n        (u/p :subtype/RClass (subtype-RClass s t))\n\n        (and (r/DataType? s)\n             (r/RClass? t))\n        (subtype-datatype-rclass s t)\n\n        ; handles classes with FnIntersection ancestors\n        (and (r/RClass? s)\n             (r/FnIntersection? t))\n        (cond\n          ; Var doesn't actually have an FnIntersection ancestor,\n          ; but this case simulates it.\n          (#{'clojure.lang.Var}\n             (:the-class s))\n            (let [[_ read-type :as poly] (:poly? s)\n                  _ (when-not (#{2} (count (:poly? s)))\n                      (err/int-error\n                        (str \"Assuming Var takes 2 arguments, \"\n                             \"given \" (count (:poly? s)))))]\n              (if (subtype? read-type t)\n                *sub-current-seen*\n                (fail! s t)))\n          :else\n            (if (some #(when (r/FnIntersection? %)\n                         (subtype? % t))\n                      (map c/fully-resolve-type (c/RClass-supers* s)))\n              *sub-current-seen*\n              (fail! s t)))\n\n        ; handles classes with heterogeneous vector ancestors (eg. IMapEntry)\n        (and (r/RClass? s)\n             (r/HeterogeneousVector? t))\n        (if (some #(when (r/HeterogeneousVector? %)\n                     (subtype? % t))\n                  (map c/fully-resolve-type (c/RClass-supers* s)))\n          *sub-current-seen*\n          (fail! s t))\n\n        ; hack for FnIntersection <: clojure.lang.IFn\n        (when (r/FnIntersection? s)\n          (subtype? (c/RClass-of clojure.lang.IFn) t))\n        *sub-current-seen*\n\n        (and (r/CountRange? s)\n             (r/CountRange? t))\n        (subtype-CountRange s t)\n\n        ; CLJS special types\n        (and (r/IntegerCLJS? s)\n             (r/NumberCLJS? t))\n        *sub-current-seen*\n\n        (and (r/PolyDots? s)\n             (r/PolyDots? t)\n             (= (:nbound s) (:nbound t)))\n        (let [;instantiate both sides with the same fresh variables\n              names (repeatedly (:nbound s) gensym)\n              bbnds1 (c/PolyDots-bbnds* names s)\n              bbnds2 (c/PolyDots-bbnds* names t)\n              b1 (c/PolyDots-body* names s)\n              b2 (c/PolyDots-body* names t)]\n          (if (and (= bbnds1 bbnds2)\n                   (free-ops/with-bounded-frees (zipmap (map r/F-maker names) bbnds1)\n                     (subtype? b1 b2)))\n            *sub-current-seen*\n            (fail! s t)))\n\n        ; TODO if s is (All [r x ...] [x ... x -> r]) and t is (All [r x] [x * -> r]) then we should say yes?\n\n        :else (fail! s t)))))", :ns "clojure.core.typed.subtype", :name "subtypeA*", :file "clojure/core/typed/subtype.clj", :column 1, :line 137, :arglists ([A s t])}
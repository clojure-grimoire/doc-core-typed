{:type :fn, :src "(defn subtype-Result\n  [{t1 :t ^FilterSet f1 :fl o1 :o flow1 :flow :as s}\n   {t2 :t ^FilterSet f2 :fl o2 :o flow2 :flow :as t}]\n  (cond\n    ;trivial case\n    (and (= o1 o2)\n         (subtype-filter-set? f1 f2)\n         (subtype-flow-set? flow1 flow2))\n    (subtype t1 t2)\n\n    ;we can ignore some interesting results\n    (and (orep/EmptyObject? o2)\n         (= f2 (fops/-FS fr/-top fr/-top))\n         (= flow2 (r/-flow fr/-top)))\n    (subtype t1 t2)\n\n    (and (orep/EmptyObject? o2)\n         (= f1 f2)\n         (= flow2 (r/-flow fr/-top)))\n    (subtype t1 t2)\n\n    ;special case for (& (is y sym) ...) <: (is y sym)\n    (and (fr/AndFilter? (:then f1))\n         (fr/TypeFilter? (:then f2))\n         (every? fops/atomic-filter? (:fs (:then f1)))\n         (= 1 (count (filter fr/TypeFilter? (:fs (:then f1)))))\n         (= fr/-top (:else f2))\n         (= flow1 flow2 (r/-flow fr/-top))\n         (= o1 o2))\n    (let [f1-tf (first (filter fr/TypeFilter? (:fs (:then f1))))]\n      (if (= f1-tf (:then f2))\n        (subtype t1 t2)\n        (fail! t1 t2)))\n\n    :else (fail! t1 t2)))", :ns "clojure.core.typed.subtype", :name "subtype-Result", :file "clojure/core/typed/subtype.clj", :column 1, :line 1122, :arglists ([{t1 :t, f1 :fl, o1 :o, flow1 :flow, :as s} {t2 :t, f2 :fl, o2 :o, flow2 :flow, :as t}])}
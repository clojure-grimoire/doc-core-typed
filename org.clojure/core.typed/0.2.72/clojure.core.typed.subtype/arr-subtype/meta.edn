{:type :fn, :src "(defn arr-subtype [A0 ^Function s ^Function t]\n  {:pre [(r/Function? s)\n         (r/Function? t)]}\n  ;; top for functions is above everything\n  (cond\n    ;; top for functions is above everything\n    (r/TopFunction? t) A0\n    ;; the really simple case\n    (and (not ((some-fn :rest :drest :kws) s))\n         (not ((some-fn :rest :drest :kws) t)))\n    (do\n      (when-not (= (count (.dom s))\n                   (count (.dom t)))\n        (fail! s t))\n      (-> *sub-current-seen*\n        ((fn [A0]\n           (reduce (fn [A* [s t]]\n                     (subtypeA* A* s t))\n                   A0\n                   (map vector (.dom t) (.dom s)))))\n        (subtypeA* (.rng s) (.rng t))))\n\n    ;kw args\n    (and (.kws s)\n         (.kws t))\n    (do\n      (mapv subtype (.dom t) (.dom s))\n      (subtype (.rng s) (.rng t))\n      (subtype-kwargs* (.kws t) (.kws s)))\n\n    (and (:rest s)\n         (not ((some-fn :rest :drest :kws) t)))\n    (-> *sub-current-seen*\n      (subtypes*-varargs (.dom t) (.dom s) (.rest s) nil)\n      (subtypeA* (.rng s) (.rng t)))\n\n    (and (not ((some-fn :rest :drest :kws) s))\n         (:rest t))\n    (fail! s t)\n\n    (and (.rest s)\n         (.rest t))\n    (-> *sub-current-seen*\n      (subtypes*-varargs (:dom t) (:dom s) (:rest s) nil)\n      (subtypeA* (:rest t) (:rest s))\n      (subtypeA* (:rng s) (:rng t)))\n\n    ;; handle ... varargs when the bounds are the same\n    (and (:drest s)\n         (:drest t)\n         (= (-> s :drest :name)\n            (-> t :drest :name)))\n    (-> *sub-current-seen*\n      (subtypeA* (-> t :drest :pre-type) (-> s :drest :pre-type))\n      ((fn [A0] \n         (reduce (fn [A* [s t]]\n                   (subtypeA* A* s t))\n                 A0 (map vector (:dom t) (:dom s)))))\n      (subtypeA* (:rng s) (:rng t)))\n    :else (fail! s t)))", :ns "clojure.core.typed.subtype", :name "arr-subtype", :file "clojure/core/typed/subtype.clj", :column 1, :line 967, :arglists ([A0 s t])}
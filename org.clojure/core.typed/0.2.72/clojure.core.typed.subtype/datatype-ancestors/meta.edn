{:type :fn, :src "(defn datatype-ancestors \n  \"Returns a set of Types which are ancestors of this datatype.\n  Only useful when checking Clojure. This is because we need to query datatypes\n  for their ancestors, as sometimes datatypes do not appear in `extenders`\n  of a protocol (this happens when a protocol is extend directly in a deftype).\"\n  [{:keys [the-class] :as dt}]\n  {:pre [(r/DataType? dt)]}\n  (impl/assert-clojure)\n  (u/p :subtype/datatype-ancestors\n  (let [overidden-by (fn [sym o]\n                       ;(prn \"overriden by\" sym (class o) o)\n                       (cond\n                         ((some-fn r/DataType? r/RClass?) o)\n                         (when (#{sym} (:the-class o))\n                           o)\n                         (r/Protocol? o)\n                         ; protocols are extended via their interface if they\n                         ; show up in the ancestors of the datatype\n                         (when (#{sym} (:on-class o))\n                           o)))\n        overrides (doall (map c/fully-resolve-type (ancest/get-datatype-ancestors dt)))\n        ;_ (prn \"datatype name\" the-class)\n        ;_ (prn \"datatype overrides\" overrides)\n        _ (assert (every? (some-fn r/Protocol? r/DataType? r/RClass?) overrides)\n                  \"Overriding datatypes to things other than datatypes, protocols and classes NYI\")\n        ; the classes that this datatype extends.\n        ; No vars should occur here because protocol are extend via\n        ; their interface.\n        normal-asyms (->> (ancestors (coerce/symbol->Class the-class))\n                          (filter class?)\n                          (map coerce/Class->symbol))\n        ;_ (prn \"normal-asyms\" normal-asyms)\n        post-override (set\n                        (for [sym normal-asyms]\n                          ; either we override this ancestor ...\n                          (if-let [o (some #(overidden-by sym %) overrides)]\n                            o\n                            (let [protocol-varsym (c/Protocol-interface->on-var sym)]\n                              (if (resolve protocol-varsym)\n                                ;... or we make a protocol type from the varified interface ...\n                                (c/Protocol-with-unknown-params protocol-varsym)\n                                ;... or we make an RClass from the actual ancestor.\n                                (c/RClass-of-with-unknown-params sym))))))]\n    post-override)))", :ns "clojure.core.typed.subtype", :name "datatype-ancestors", :file "clojure/core/typed/subtype.clj", :column 1, :line 1215, :arglists ([{:keys [the-class], :as dt}]), :doc "Returns a set of Types which are ancestors of this datatype.\n  Only useful when checking Clojure. This is because we need to query datatypes\n  for their ancestors, as sometimes datatypes do not appear in `extenders`\n  of a protocol (this happens when a protocol is extend directly in a deftype)."}
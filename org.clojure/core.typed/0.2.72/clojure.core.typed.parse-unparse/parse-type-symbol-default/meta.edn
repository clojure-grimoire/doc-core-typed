{:type :fn, :src "(defn parse-type-symbol-default\n  [sym]\n  (let [primitives (impl/impl-case\n                     :clojure (clj-primitives-fn)\n                     :cljs (cljs-primitives-fn))\n        rsym (impl/impl-case\n               :clojure (when-let [res (when (symbol? sym)\n                                         (resolve-type-clj sym))]\n                          (cond \n                            (class? res) (coerce/Class->symbol res)\n                            (var? res) (coerce/var->symbol res)))\n               :cljs (when (symbol? sym)\n                       (resolve-type-cljs sym)))\n        free (when (symbol? sym) \n               (free-ops/free-in-scope sym))\n        _ (assert ((some-fn symbol? nil?) rsym))]\n    (cond\n      free free\n      (primitives sym) (primitives sym)\n      rsym ((some-fn deprecated-symbol r/Name-maker) rsym)\n      :else (let [menv (let [m (meta sym)]\n                         (when ((every-pred :line :column :file) m)\n                           m))]\n              (binding [vs/*current-env* (or menv vs/*current-env*)]\n                (err/int-error (str \"Cannot resolve type: \" (pr-str sym)\n                                    \"\\nHint: Is \" (pr-str sym) \" in scope?\"\n                                    \"\\nHint: Has \" (pr-str sym) \"'s annotation been\"\n                                    \" found via check-ns, cf or typed-deps?\")\n                               {:use-current-env true}))))))", :ns "clojure.core.typed.parse-unparse", :name "parse-type-symbol-default", :file "clojure/core/typed/parse_unparse.clj", :column 1, :line 932, :arglists ([sym])}
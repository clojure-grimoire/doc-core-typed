{:type :fn, :src "(defn parse-function [f]\n  {:post [(r/Function? %)]}\n  (let [is-arrow '#{-> :->}\n        all-dom (take-while (complement is-arrow) f)\n        [the-arrow rng & opts-flat :as chk] (drop-while (complement is-arrow) f) ;opts aren't used yet\n        _ (when ('#{->} the-arrow)\n            ;TODO deprecate\n            )\n        _ (when-not (<= 2 (count chk)) \n            (err/int-error (str \"Incorrect function syntax: \" f)))\n\n        _ (when-not (even? (count opts-flat)) \n            (err/int-error (str \"Incorrect function syntax, must have even number of keyword parameters: \" f)))\n\n        opts (apply hash-map opts-flat)\n\n        {ellipsis-pos '...\n         asterix-pos '*\n         kw-asterix-pos :*\n         ampersand-pos '&}\n        (zipmap all-dom (range))\n\n        _ (when-not (#{0 1} (count (filter identity [asterix-pos ellipsis-pos ampersand-pos\n                                                     kw-asterix-pos])))\n            (err/int-error \"Can only provide one rest argument option: & ... or *\"))\n\n        asterix-pos (or asterix-pos kw-asterix-pos)\n\n        _ (when-let [ks (seq (remove #{:filters :object :flow} (keys opts)))]\n            (err/int-error (str \"Invalid function keyword option/s: \" ks)))\n\n        filters (when-let [[_ fsyn] (find opts :filters)]\n                  (parse-filter-set fsyn))\n\n        object (when-let [[_ obj] (find opts :object)]\n                 (parse-object obj))\n\n        flow (when-let [[_ obj] (find opts :flow)]\n               (r/-flow (parse-filter obj)))\n\n        fixed-dom (cond \n                    asterix-pos (take (dec asterix-pos) all-dom)\n                    ellipsis-pos (take (dec ellipsis-pos) all-dom)\n                    ampersand-pos (take ampersand-pos all-dom)\n                    :else all-dom)\n\n        rest-type (when asterix-pos\n                    (nth all-dom (dec asterix-pos)))\n        _ (when-not (or (not asterix-pos)\n                        (= (count all-dom) (inc asterix-pos)))\n            (err/int-error (str \"Trailing syntax after rest parameter: \" (pr-str (drop (inc asterix-pos) all-dom)))))\n        [drest-type _ drest-bnd :as drest-seq] (when ellipsis-pos\n                                                 (drop (dec ellipsis-pos) all-dom))\n        _ (when-not (or (not ellipsis-pos) (= 3 (count drest-seq))) \n            (err/int-error \"Dotted rest entry must be 3 entries\"))\n        _ (when-not (or (not ellipsis-pos) (symbol? drest-bnd))\n            (err/int-error \"Dotted bound must be symbol\"))\n        ;TODO check for duplicate entries\n        [& {optional-kws :optional mandatory-kws :mandatory} :as kws-seq]\n        (let [kwsyn (when ampersand-pos\n                      (drop (inc ampersand-pos) all-dom))]\n          ; support deprecated syntax [& {} -> ] to be equivalent to [& :optional {} -> ]\n          (if (and kwsyn\n                   (map? (first kwsyn)))\n            (do (err/deprecated-warn \"[& {} -> ] function syntax is deprecated. Use [& :optional {} -> ]\")\n                (cons :optional kwsyn))\n            kwsyn))\n\n        _ (when-not (or (not ampersand-pos) (seq kws-seq)) \n            (err/int-error \"Must provide syntax after &\"))]\n    (r/make-Function (mapv parse-type fixed-dom)\n                     (parse-type rng)\n                     (when asterix-pos\n                       (parse-type rest-type))\n                     (when ellipsis-pos\n                       (let [bnd (dvar/*dotted-scope* drest-bnd)\n                             _ (when-not bnd \n                                 (err/int-error (str (pr-str drest-bnd) \" is not in scope as a dotted variable\")))]\n                         (r/DottedPretype1-maker\n                           (free-ops/with-frees [bnd] ;with dotted bound in scope as free\n                             (parse-type drest-type))\n                           (:name bnd))))\n                     :filter filters\n                     :object object\n                     :flow flow\n                     :optional-kws (when optional-kws\n                                     (parse-kw-map optional-kws))\n                     :mandatory-kws (when mandatory-kws\n                                      (parse-kw-map mandatory-kws)))))", :ns "clojure.core.typed.parse-unparse", :name "parse-function", :file "clojure/core/typed/parse_unparse.clj", :column 1, :line 1066, :arglists ([f])}
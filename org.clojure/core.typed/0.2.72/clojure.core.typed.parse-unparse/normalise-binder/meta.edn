{:type :fn, :src "(defn normalise-binder [bnds]\n  (loop [bnds bnds\n         out []]\n    (cond\n      (empty? bnds) out\n\n      (vector? (first bnds)) (let [[s & rst] bnds]\n                               (recur rst\n                                      (conj out s)))\n      :else\n      (let [[sym & rst] bnds\n            [group rst] (loop [bnds rst\n                               out [sym]]\n                          (if (keyword? (second bnds))\n                            (let [_ (when-not (#{2} (count (take 2 bnds)))\n                                      (err/int-error (str \"Keyword option \" (second bnds)\n                                                        \" has no associated value\")))\n                                  [k v & rst] bnds]\n                              (recur rst\n                                     (conj out k v)))\n                            [bnds out]))]\n        (recur rst\n               (conj out group))))))", :ns "clojure.core.typed.parse-unparse", :name "normalise-binder", :file "clojure/core/typed/parse_unparse.clj", :column 1, :line 288, :arglists ([bnds])}
{:ns "clojure.core.typed.utils", :name "add-defmethod-generator", :file "clojure/core/typed/utils.clj", :type :macro, :src "(defmacro add-defmethod-generator \n  \"Generates a macro called mm-name, which can be used instead\n  of defmethod of the multimethod called mm-name.\n  The generated macro adds a meaningful name to the local function\n  of the defmethod, and profiling information via timbre for each\n  defmethod.\n  \n  Usage: (add-mm-name-method check)\n\n  (defmethod check  ...) then becomes (add-check-method ...)\"\n  [mm-name]\n  `(defmacro ~(symbol (str \"add-\" mm-name \"-method\")) \n     [~'nme ~'params & ~'body]\n     (let [[~'assertmap ~'body] (if (and (map? (first ~'body))\n                                         (< 1 (count ~'body)))\n                                  [(first ~'body) (next ~'body)]\n                                  [nil ~'body])]\n       `(defmethod \n          ;the multimethod to install methods to\n          ~'~mm-name \n          ;the dispatch value\n          ~~'nme\n          ;the local fn name of this defmethod, gensymed to\n          ;avoid reloading conflicts\n          ~(symbol (str ~(str mm-name \" \") (str ~'nme) (gensym \"\")))\n          ;the param list\n          ~~'params\n          ;the pre/post condition map\n          ~~'assertmap\n          ;the body, wrapped in a profiling macro\n          (u/p ~(keyword (str '~mm-name) (str ~'nme))\n               ~@~'body)))))", :column 1, :line 291, :macro true, :arglists ([mm-name]), :doc "Generates a macro called mm-name, which can be used instead\n  of defmethod of the multimethod called mm-name.\n  The generated macro adds a meaningful name to the local function\n  of the defmethod, and profiling information via timbre for each\n  defmethod.\n  \n  Usage: (add-mm-name-method check)\n\n  (defmethod check  ...) then becomes (add-check-method ...)"}
{:type :fn, :src "(defn check-special-fn \n  [check {[_ _ fn-ann-expr :as statements] :statements fexpr :ret :as expr} expected]\n  {:pre [(#{3} (count statements))]}\n  (let [fn-anns (ast-u/map-expr-at fn-ann-expr :ann)\n        ann-expected\n        (binding [prs/*parse-type-in-ns* (cu/expr-ns expr)]\n          (apply\n            r/make-FnIntersection\n            (doall\n              (for [{:keys [dom rest drest ret-type]} fn-anns]\n                (r/make-Function (mapv (comp prs/parse-type :type) dom)\n                                 (prs/parse-type (:type ret-type))\n                                 (when rest\n                                   (prs/parse-type (:type rest)))\n                                 (when drest\n                                   (r/DottedPretype1-maker\n                                     (prs/parse-type (:pretype drest))\n                                     (:bound drest))))))))\n\n        ; if the t/fn statement looks unannotated, use the expected type if possible\n        use-expected (if (every? (fn [{:keys [dom rest drest rng] :as f}]\n                                   {:pre [(r/Function? f)]}\n                                   (and (every? #{r/-any} dom)\n                                        ((some-fn nil? #{r/-any}) rest)\n                                        (#{r/-any} (:t rng))))\n                                 (:types ann-expected))\n                       (or (when expected (r/ret-t expected)) ann-expected)\n                       ann-expected)\n        cfexpr (check fexpr (r/ret use-expected))\n        _ (when expected\n            (let [actual (-> cfexpr u/expr-type r/ret-t)]\n              (when-not (sub/subtype? actual (r/ret-t expected))\n                (cu/expected-error actual (r/ret-t expected)))))]\n    (assoc expr\n           :ret cfexpr\n           u/expr-type (u/expr-type cfexpr))))", :ns "clojure.core.typed.check.special.fn", :name "check-special-fn", :file "clojure/core/typed/check/special/fn.clj", :column 1, :line 9, :arglists ([check {[_ _ fn-ann-expr :as statements] :statements, fexpr :ret, :as expr} expected])}
{:type :fn, :src "(defn tc-isa? \n  \"Type check a call to isa?. Assumes global hierarchy.\n  Also supports the case where both elements are vectors, but not recursively.\"\n  [child-ret parent-ret]\n  {:pre [(r/TCResult? child-ret)\n         (r/TCResult? parent-ret)]\n   :post [(r/TCResult? %)]}\n  (t/letfn> [fs :- [TCResult TCResult -> '{:then fprotocol/IFilter :else fprotocol/IFilter}]\n             (fs [child1 parent1]\n                 {:pre [(r/TCResult? child1)\n                        (r/TCResult? parent1)]\n                  :post [((con/hmap-c? :then fl/Filter? :else fl/Filter?) %)]}\n                 {:then (fo/-filter-at (r/ret-t parent1) (r/ret-o child1))\n                  :else (fo/-not-filter-at (r/ret-t parent1) (r/ret-o child1))})]\n    (let [child-t (r/ret-t child-ret)\n          parent-t (r/ret-t parent-ret)\n          fs (cond\n               ; interesting case with (isa? [...] [...])\n               ; use each pairing between child and parent\n               (and (r/HeterogeneousVector? child-t)\n                    (r/HeterogeneousVector? parent-t))\n               (let [individual-fs (map fs (cu/hvec->rets child-t) (cu/hvec->rets parent-t))]\n                 (fo/-FS (apply fo/-and (map :then individual-fs))\n                         (apply fo/-or (map :else individual-fs))))\n               ; simple (isa? child parent) \n               :else (let [{:keys [then else]} (fs child-ret parent-ret)]\n                       (fo/-FS then else)))]\n      (r/ret (c/Un r/-true r/-false) fs obj/-empty))))", :ns "clojure.core.typed.check.isa", :name "tc-isa?", :file "clojure/core/typed/check/isa.clj", :column 1, :line 16, :arglists ([child-ret parent-ret]), :doc "Type check a call to isa?. Assumes global hierarchy.\n  Also supports the case where both elements are vectors, but not recursively."}
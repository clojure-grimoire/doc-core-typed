{:type :fn, :src "(defn resolve-name* [sym]\n  {:pre [(symbol? sym)]\n   :post [(r/Type? %)]}\n  (let [t (get-type-name sym)\n        tfn ((some-fn dtenv/get-datatype \n                      prenv/get-protocol\n                      (impl/impl-case :clojure #(or (rcls/get-rclass %)\n                                                    (when (class? (resolve %))\n                                                      (c/RClass-of-with-unknown-params %)))\n                                      :cljs jsnom/get-jsnominal)\n                      ; during the definition of RClass's that reference\n                      ; themselves in their definition, a temporary TFn is\n                      ; added to the declared kind env which is enough to determine\n                      ; type rank and variance.\n                      kinds/declared-kind-or-nil) \n             sym)]\n    (if tfn\n      tfn\n      (cond\n        (= protocol-name-type t) (prenv/resolve-protocol sym)\n        (= datatype-name-type t) (dtenv/resolve-datatype sym)\n        (= declared-name-type t) (throw (IllegalArgumentException. (str \"Reference to declared but undefined name \" sym)))\n        (r/Type? t) (vary-meta t assoc :source-Name sym)\n        :else (err/int-error (str \"Cannot resolve name \" (pr-str sym)\n                                  (when t\n                                    (str \" (Resolved to instance of)\" (pr-str (class t))))))))))", :ns "clojure.core.typed.name-env", :name "resolve-name*", :file "clojure/core/typed/name_env.clj", :column 1, :line 136, :arglists ([sym])}
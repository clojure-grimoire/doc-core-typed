{:type :fn, :src "(defn invoke-keyword [expr kw-ret target-ret default-ret expected-ret]\n  {:pre [(r/TCResult? kw-ret)\n         (r/TCResult? target-ret)\n         ((some-fn nil? r/TCResult?) default-ret)\n         ((some-fn nil? r/TCResult?) expected-ret)\n         ((some-fn nil? map?) expr)]\n   :post [(r/TCResult? %)]}\n  (u/p :check/invoke-keyword\n  (let [targett (c/-resolve (r/ret-t target-ret))\n        kwt (r/ret-t kw-ret)\n        defaultt (when default-ret\n                   (r/ret-t default-ret))]\n    (cond\n      ;Keyword must be a singleton with no default\n      (c/keyword-value? kwt)\n      (let [{path-hm :path id-hm :id :as o} (when (obj/Path? (r/ret-o target-ret))\n                                              (r/ret-o target-ret))\n            o (or o (r/ret-o target-ret))\n            _ (assert ((some-fn obj/Path? obj/EmptyObject?) o))\n            this-pelem (pe/-kpe (:val kwt))\n            val-type (c/find-val-type targett kwt defaultt)]\n        (when expected-ret\n          (when-not (sub/subtype? val-type (r/ret-t expected-ret))\n            (binding [vs/*current-expr* (or expr vs/*current-expr*)]\n              (cu/expected-error val-type (r/ret-t expected-ret)))))\n        (if (not= (c/Un) val-type)\n          (r/ret val-type\n               (fo/-FS (if (obj/Path? o)\n                         (fo/-filter val-type id-hm (concat path-hm [this-pelem]))\n                         fl/-top)\n                       (if (obj/Path? o)\n                         (fo/-or (fo/-filter (c/make-HMap :absent-keys #{kwt}) id-hm path-hm) ; this map doesn't have a kwt key or...\n                                 (fo/-filter (c/Un r/-nil r/-false) id-hm (concat path-hm [this-pelem]))) ; this map has a false kwt key\n                         fl/-top))\n               (if (obj/Path? o)\n                 (update-in o [:path] #(seq (concat % [this-pelem])))\n                 o))\n          (do (u/tc-warning (str \"Keyword lookup gave bottom type: \"\n                               (:val kwt) \" \" (prs/unparse-type targett)))\n              (r/ret r/-any))))\n\n      :else (err/int-error (str \"keyword-invoke only supports keyword lookup, no default. Found \" \n                              (prs/unparse-type kwt)))))))", :ns "clojure.core.typed.check.invoke-kw", :name "invoke-keyword", :file "clojure/core/typed/check/invoke_kw.clj", :column 1, :line 16, :arglists ([expr kw-ret target-ret default-ret expected-ret])}
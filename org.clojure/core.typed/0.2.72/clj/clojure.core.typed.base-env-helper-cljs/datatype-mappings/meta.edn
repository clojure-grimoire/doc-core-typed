{:type :macro, :src "(defmacro datatype-mappings [& args]\n  `(impl/with-cljs-impl\n     (let [ts# (partition 2 '~args)]\n       (into {}\n             (doall\n               (for [[n# [binder# & {record?# :record? :as opts#}]] ts#]\n                 (let [names# (when (seq binder#)\n                                (map first binder#))\n                       {vs# :variances\n                        names# :names\n                        bnds# :bnds} \n                       (when (seq binder#)\n                         ; don't bound frees because mutually dependent bounds are problematic\n                         ; FIXME ... Or is this just laziness? \n                         (let [b# (free-ops/with-free-symbols names#\n                                    (mapv prs/parse-tfn-binder binder#))]\n                           {:variances (seq (map :variance b#))\n                            :names (seq (map :nme b#))\n                            :bnds (seq (map :bound b#))}))\n                       frees# (seq (map r/make-F names#))\n                       fields# (free-ops/with-bounded-frees (zipmap frees# bnds#)\n                                 (into {}\n                                       (for [[mname# mtype#] (:fields opts#)]\n                                         [mname# (prs/parse-type mtype#)])))]\n                   (decl-env/remove-declared-kind n#)\n                   [n# (c/DataType* names# vs# frees# n# bnds# fields# (boolean record?#))])))))))", :macro true, :ns "clojure.core.typed.base-env-helper-cljs", :name "datatype-mappings", :file "clojure/core/typed/base_env_helper_cljs.clj", :column 1, :line 140, :arglists ([& args])}
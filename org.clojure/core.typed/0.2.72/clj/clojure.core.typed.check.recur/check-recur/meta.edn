{:type :fn, :src "(defn check-recur [args env recur-expr expected check]\n  (binding [vs/*current-env* env]\n    (let [{:keys [dom rest] :as recur-target} (if-let [r recur-u/*recur-target*]\n                                                r\n                                                (err/int-error (str \"No recur target\")))\n          _ (assert (not ((some-fn :drest :kw) recur-target)) \"NYI\")\n          fixed-args (if rest\n                       (butlast args)\n                       args)\n          rest-arg (when rest\n                     (last args))\n          rest-arg-type (when rest-arg\n                          (impl/impl-case\n                            :clojure (c/Un r/-nil (c/In (c/RClass-of clojure.lang.ISeq [rest])\n                                                        (r/make-CountRange 1)))\n                             :cljs (c/Un r/-nil (c/In (c/Protocol-of 'cljs.core/ISeq [rest])\n                                                      (r/make-CountRange 1)))))\n          cargs (mapv check args (map r/ret\n                                      (concat dom \n                                              (when rest-arg-type\n                                                [rest-arg-type]))))\n          _ (when-not (and (= (count fixed-args) (count dom))\n                           (= (boolean rest) (boolean rest-arg)))\n              (err/tc-delayed-error \n                (str \"Wrong number of arguments to recur:\"\n                     \" Expected: \" ((if rest inc identity) \n                                    (count dom))\n                     \" Given: \" ((if rest-arg inc identity)\n                                 (count fixed-args)))))]\n      (assoc recur-expr\n             :exprs cargs\n             u/expr-type (r/ret (c/Un))))))", :ns "clojure.core.typed.check.recur", :name "check-recur", :file "clojure/core/typed/check/recur.clj", :column 1, :line 12, :arglists ([args env recur-expr expected check])}
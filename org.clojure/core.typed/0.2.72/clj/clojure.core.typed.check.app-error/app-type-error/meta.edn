{:type :fn, :src "(defn ^String app-type-error [fexpr args fin arg-ret-types expected poly?]\n  {:pre [(r/FnIntersection? fin)\n         (or (not poly?)\n             ((some-fn r/Poly? r/PolyDots?) poly?))]\n   :post [(r/TCResult? %)]}\n  (let [fin (apply r/make-FnIntersection\n                   ;try and prune some of the arities\n                   ; Lots more improvements we can port from Typed Racket:\n                   ;  typecheck/tc-app-helper.rkt\n                   (or\n                     (seq\n                       (remove (fn [{:keys [dom rest drest kws rng]}]\n                                 ;remove arities that have a differing\n                                 ; number of fixed parameters than what we\n                                 ; require\n                                 (or\n                                   (and (not rest) (not drest) (not kws)\n                                        (not= (count dom)\n                                              (count arg-ret-types)))\n                                   ; remove if we don't have even the fixed args\n                                   (< (count arg-ret-types)\n                                      (count dom))))\n                               (:types fin)))\n                     ;if we remove all the arities, default to all of them\n                     (:types fin)))\n        static-method? (= :static-call (:op fexpr))\n        instance-method? (= :instance-call (:op fexpr))\n        method-sym (when (or static-method? instance-method?)\n                     (cu/MethodExpr->qualsym fexpr))]\n    (prs/with-unparse-ns (or prs/*unparse-type-in-ns*\n                             (or (when fexpr\n                                   (cu/expr-ns fexpr))\n                                 (when vs/*current-expr*\n                                   (cu/expr-ns vs/*current-expr*))))\n      (err/tc-delayed-error\n        (str\n          (if poly?\n            (str \"Polymorphic \" \n                 (cond static-method? \"static method \"\n                       instance-method? \"instance method \"\n                       :else \"function \"))\n            (cond static-method? \"Static method \"\n                  instance-method? \"Instance method \"\n                  :else \"Function \"))\n          (if (or static-method?\n                  instance-method?)  \n            method-sym\n            (if fexpr\n              (ast-u/emit-form-fn fexpr)\n              \"<NO FORM>\"))\n          \" could not be applied to arguments:\\n\"\n          (when poly?\n            (let [names (cond \n                          (r/Poly? poly?) (c/Poly-fresh-symbols* poly?)\n                          ;PolyDots\n                          :else (c/PolyDots-fresh-symbols* poly?))\n                  bnds (if (r/Poly? poly?)\n                         (c/Poly-bbnds* names poly?)\n                         (c/PolyDots-bbnds* names poly?))\n                  dotted (when (r/PolyDots? poly?)\n                           (last names))]\n              (str \"Polymorphic Variables:\\n\\t\"\n                   (str/join \"\\n\\t\" \n                                        (map (partial apply pr-str)\n                                             (map (fn [{:keys [lower-bound upper-bound] :as bnd} nme]\n                                                    {:pre [(r/Bounds? bnd)\n                                                           (symbol? nme)]}\n                                                    (cond\n                                                      (= nme dotted) [nme '...]\n                                                      :else (concat [nme]\n                                                                    (when-not (= r/-nothing lower-bound)\n                                                                      [:> (prs/unparse-type lower-bound)])\n                                                                    (when-not (= r/-any upper-bound)\n                                                                      [:< (prs/unparse-type upper-bound)]))))\n                                                  bnds (map (comp r/F-original-name r/make-F) names)))))))\n          \"\\n\\nDomains:\\n\\t\" \n          (str/join \"\\n\\t\" \n                               (map (partial apply pr-str) \n                                    (map (fn [{:keys [dom rest drest kws]}]\n                                           (concat (map prs/unparse-type dom)\n                                                   (when rest\n                                                     [(prs/unparse-type rest) '*])\n                                                   (when-let [{:keys [pre-type name]} drest]\n                                                     [(prs/unparse-type pre-type) \n                                                      '... \n                                                      (-> name r/make-F r/F-original-name)])\n                                                   (letfn [(readable-kw-map [m]\n                                                             (into {} (for [[k v] m]\n                                                                        (do (assert (r/Value? k))\n                                                                            [(:val k) (prs/unparse-type v)]))))]\n                                                     (when-let [{:keys [mandatory optional]} kws]\n                                                       (concat ['&]\n                                                               (when (seq mandatory)\n                                                                 [:mandatory (readable-kw-map mandatory)])\n                                                               (when (seq optional)\n                                                                 [:optional (readable-kw-map optional)]))))))\n                                         (:types fin))))\n          \"\\n\\n\"\n          \"Arguments:\\n\\t\" (apply prn-str (map (comp prs/unparse-type r/ret-t) arg-ret-types))\n          \"\\n\"\n          \"Ranges:\\n\\t\"\n          (str/join \"\\n\\t\" \n                               (map (partial apply pr-str) (map (comp prs/unparse-result :rng) (:types fin))))\n          \"\\n\\n\"\n          (when expected (str \"with expected type:\\n\\t\" (pr-str (prs/unparse-type (r/ret-t expected))) \"\\n\\n\"))\n          \"in: \" (if fexpr\n                   (if (or static-method? instance-method?)\n                     (ast-u/emit-form-fn fexpr)\n                     (list* (ast-u/emit-form-fn fexpr)\n                            (map ast-u/emit-form-fn args)))\n                   \"<NO FORM>\"))\n        :return (or expected (r/ret r/Err))))))", :ns "clojure.core.typed.check.app-error", :name "app-type-error", :file "clojure/core/typed/check/app_error.clj", :column 1, :line 14, :tag java.lang.String, :arglists ([fexpr args fin arg-ret-types expected poly?])}
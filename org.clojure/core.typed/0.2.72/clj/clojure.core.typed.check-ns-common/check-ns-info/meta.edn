{:type :fn, :src "(defn check-ns-info\n  [impl ns-or-syms & {:keys [collect-only trace profile file-mapping]}]\n  (p/profile-if profile\n    (let [start (. System (nanoTime))]\n      (reset-caches/reset-caches)\n      (let [nsym-coll (map #(if (symbol? %)\n                              ; namespace might not exist yet, so ns-name is not appropriate\n                              ; to convert to symbol\n                              %\n                              (ns-name %))\n                           (if ((some-fn symbol? con/namespace?)\n                                ns-or-syms)\n                             [ns-or-syms]\n                             ns-or-syms))]\n        (cond\n          vs/*checking* (err/int-error \"Found inner call to check-ns or cf\")\n\n          :else\n          (impl/with-full-impl impl\n            (binding [vs/*checking* true\n                      vs/*delayed-errors* (err/-init-delayed-errors)\n                      vs/*already-checked* (atom #{})\n                      vs/*trace-checker* trace\n                      vs/*analyze-ns-cache* (cache/soft-cache-factory {})\n                      ; we only use this if we have exactly one namespace passed\n                      vs/*checked-asts* (when (#{impl/clojure} impl)\n                                          (when (== 1 (count nsym-coll))\n                                            (atom {})))\n                      vs/*already-collected* (atom #{})]\n              (let [terminal-error (atom nil)]\n                (reset-env/reset-envs!)\n                ;(reset-caches)\n                ;; handle terminal type error\n                (try\n                  ;-------------------------\n                  ; Collect phase\n                  ;-------------------------\n                  (let [collect-ns (impl/impl-case\n                                     :clojure collect-clj/collect-ns\n                                     :cljs    (impl/v 'clojure.core.typed.collect-cljs/collect-ns))]\n                    (doseq [nsym nsym-coll]\n                      (collect-ns nsym)))\n                  (let [ms (/ (double (- (. System (nanoTime)) start)) 1000000.0)\n                        collected (if-let [c vs/*already-collected*]\n                                    @c\n                                    (err/int-error \"*already-collected* unbound\"))]\n                    (println \"Collected\" (count collected) \"namespaces in\" ms \"msecs\")\n                    (flush))\n\n                  ;-------------------------\n                  ; Check phase\n                  ;-------------------------\n                  (when-not collect-only\n                    (let [check-ns (impl/impl-case\n                                     :clojure chk-clj/check-ns-and-deps\n                                     :cljs    (impl/v 'clojure.core.typed.check-cljs/check-ns))]\n                      (doseq [nsym nsym-coll]\n                        (check-ns nsym)))\n                    (let [vs (var-env/vars-with-unchecked-defs)]\n                      (binding [*out* *err*]\n                        (doseq [v vs]\n                          (println \"WARNING: Type Checker: Definition missing:\" v \n                                   \"\\nHint: Use :no-check metadata with ann if this is an unchecked var\")\n                          (flush))))\n                    (let [ms (/ (double (- (. System (nanoTime)) start)) 1000000.0)\n                          checked (some-> vs/*already-checked* deref)]\n                      (println \"Checked\" (count checked) \"namespaces \"\n                               \"in\" ms \"msecs\")\n                      (flush)))\n                  (catch ExceptionInfo e\n                    (if (-> e ex-data :type-error)\n                      (reset! terminal-error e)\n                      (throw e))))\n                (merge\n                  {:delayed-errors (vec (concat (some-> vs/*delayed-errors* deref)\n                                                (when-let [e @terminal-error]\n                                                  [e])))}\n                  (when (#{impl/clojure} impl)\n                    (when (and file-mapping\n                               (== 1 (count nsym-coll)))\n                      {:file-mapping (apply merge\n                                            (map #(impl/with-full-impl impl\n                                                    (file-map/ast->file-mapping %))\n                                                 (get (some-> vs/*checked-asts* deref) (first nsym-coll))))})))))))))))", :ns "clojure.core.typed.check-ns-common", :name "check-ns-info", :file "clojure/core/typed/check_ns_common.clj", :column 1, :line 24, :arglists ([impl ns-or-syms & {:keys [collect-only trace profile file-mapping]}])}
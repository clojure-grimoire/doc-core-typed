{:type :fn, :src "(deftest Name-resolve-test\n  (is-with-aliases (= (tc-t (clojure.core.typed/fn> [tmap :- clojure.core.typed.test.util-aliases/MyName]\n                                                    ;call to (apply hash-map tmap) should be eliminated\n                                                    (let [{e :a} tmap]\n                                                      e)))\n                      (ret (make-FnIntersection \n                             (Function-maker [(Name-maker 'clojure.core.typed.test.util-aliases/MyName)]\n                                         (make-Result (-val 1) (-FS -top -top) -empty)\n                                         nil nil nil))\n                           (-FS -top -bot) -empty)))\n  (is-with-aliases (= (tc-t (clojure.core.typed/fn> [tmap :- clojure.core.typed.test.util-aliases/MapName]\n                                                    (let [{e :a} tmap]\n                                                      (assoc e :c :b))))\n                      (ret (make-FnIntersection (Function-maker [(Name-maker 'clojure.core.typed.test.util-aliases/MapName)]\n                                                            (make-Result (make-HMap :mandatory {(-val :a) (-val 1)\n                                                                                 (-val :c) (-val :b)})\n                                                                         (-FS -top -bot) -empty)\n                                                            nil nil nil))\n                           (-FS -top -bot) -empty)))\n  ; Name representing union of two maps, both with :type key\n  (is-with-aliases (subtype? \n                     (-> (tc-t (clojure.core.typed/fn> [tmap :- clojure.core.typed.test.util-aliases/UnionName]\n                                                       (:type tmap)))\n                         ret-t)\n                     (parse-type \n                       `[clojure.core.typed.test.util-aliases/UnionName :-> (U (Value :MapStruct2)\n                                                                               (Value :MapStruct1))])))\n  ; using = to derive paths\n  (is-with-aliases (subtype? \n                     (-> (tc-t (clojure.core.typed/fn> [tmap :- clojure.core.typed.test.util-aliases/UnionName]\n                                                       (= :MapStruct1 (:type tmap))))\n                         ret-t)\n                     (make-FnIntersection \n                       (make-Function \n                         [(Name-maker 'clojure.core.typed.test.util-aliases/UnionName)]\n                         (Un -false -true)\n                         nil nil\n                         :filter (let [t (-val :MapStruct1)\n                                       path [(-kpe :type)]]\n                                   (-FS (-and \n                                          (-filter (make-HMap :mandatory {(-val :type) (-val :MapStruct1)\n                                                           (-val :a) (Name-maker 'clojure.core.typed.test.util-aliases/MyName)})\n                                                   0)\n                                          (-filter (-val :MapStruct1) 0 path)\n                                          (-filter t 0 path))\n                                        (-not-filter t 0 path)))))))\n  ; using filters derived by =\n  (is-with-aliases (subtype? (-> (tc-t (clojure.core.typed/fn> [tmap :- clojure.core.typed.test.util-aliases/UnionName]\n                                                               (if (= :MapStruct1 (:type tmap))\n                                                                 (:a tmap)\n                                                                 (:b tmap))))\n                                 ret-t)\n                             (parse-type \n                               `[clojure.core.typed.test.util-aliases/UnionName :-> clojure.core.typed.test.util-aliases/MyName])))\n  ; following paths with test of conjuncts\n  ;FIXME\n  #_(is-clj (= (tc-t (clojure.core.typed/fn> [tmap :- clojure.core.typed.test.util-aliases/UnionName]\n                                         ; (and (= :MapStruct1 (-> tmap :type))\n                               ;      (= 1 1))\n                               (if (clojure.core.typed/print-filterset \"final filters\"\n                                    (let [and1 (clojure.core.typed/print-filterset \"first and1\"\n                                                 (= :MapStruct1 (-> tmap :type)))]\n                                      (clojure.core.typed/print-env \"first conjunct\")\n                                      (clojure.core.typed/print-filterset \"second and1\"\n                                        (if (clojure.core.typed/print-filterset \"second test\"\n                                              and1)\n                                          (do (clojure.core.typed/print-env \"second conjunct\")\n                                            (clojure.core.typed/print-filterset \"third and1\"\n                                              (= 1 1)))\n                                          (do (clojure.core.typed/print-env \"fail conjunct\")\n                                            (clojure.core.typed/print-filterset \"fail and1\"\n                                              and1))))))\n                                 (do (clojure.core.typed/print-env \"follow then\")\n                                   (assoc tmap :c :d))\n                                 1)))\n         (ret (make-FnIntersection (Function-maker [(Name-maker 'clojure.core.typed.test.util-aliases/UnionName)]\n                              (let [t (Un (-val 1)\n                                          (make-HMap :mandatory {(-val :type) (-val :MapStruct1)\n                                                               (-val :c) (-val :d)\n                                                               (-val :a) (Name-maker 'clojure.core.typed.test.util-aliases/MyName)}))]\n                                (make-Result t (-FS -top -bot) -empty))\n                              nil nil nil))\n              (-FS -top -bot) -empty))))", :ns "clojure.core.typed.test.core", :name "Name-resolve-test", :file "clojure/core/typed/test/core.clj", :column 1, :line 536, :test #<core$fn__25931 clojure.core.typed.test.core$fn__25931@1b86be2e>}
{:ns "clojure.core.typed.test.tools-analyzer-jvm-ann", :name "Expr", :type :var, :src nil, :doc "\n\n(t/Rec\n [Expr]\n (t/U\n  (t/HMap\n   :mandatory\n   {:op ':const,\n    :env Env,\n    :type t/Keyword,\n    :literal Boolean,\n    :val Form,\n    :form Form}\n   :optional\n   {:meta Expr, :children Children})\n  (t/HMap\n   :mandatory\n   {:op ':vector,\n    :env Env,\n    :items (t/Vec Expr),\n    :form Form,\n    :children Children})\n  (t/HMap\n   :mandatory\n   {:op ':with-meta,\n    :env Env,\n    :form Form,\n    :meta Expr,\n    :expr Expr,\n    :children Children})\n  (t/HMap\n   :mandatory\n   {:op ':map,\n    :env Env,\n    :keys (t/Vec Expr),\n    :vals (t/Vec Expr),\n    :form Form,\n    :children Children})\n  (t/HMap\n   :mandatory\n   {:op ':set,\n    :env Env,\n    :items (t/Vec Expr),\n    :form Form,\n    :children Children})\n  (t/HMap\n   :mandatory\n   {:op ':local,\n    :form Form,\n    :name t/Symbol,\n    :assignable? Boolean,\n    :children Children}\n   :optional\n   {:env Env})\n  (t/HMap\n   :mandatory\n   {:op ':var, :env Env, :form Form, :assignable? Boolean})\n  (t/HMap\n   :mandatory\n   {:op ':maybe-host-form,\n    :env Env,\n    :form Form,\n    :class (t/U nil t/Symbol),\n    :field t/Symbol})\n  (t/HMap\n   :mandatory\n   {:op ':maybe-class,\n    :env Env,\n    :form Form,\n    :class (t/U nil t/Symbol)})\n  (t/HMap\n   :mandatory\n   {:op ':do,\n    :env Env,\n    :form Form,\n    :statements (t/Vec Expr),\n    :ret Expr,\n    :children Children})\n  (t/HMap\n   :mandatory\n   {:op ':if,\n    :env Env,\n    :form Form,\n    :test Expr,\n    :then Expr,\n    :else Expr,\n    :children Children})\n  (t/HMap\n   :mandatory\n   {:op ':new,\n    :env Env,\n    :form Form,\n    :class Class,\n    :args (t/Vec Expr),\n    :children Children})\n  (t/HMap\n   :mandatory\n   {:op ':quote,\n    :env Env,\n    :form Form,\n    :expr Expr,\n    :literal? Boolean,\n    :children Children})\n  (t/HMap\n   :mandatory\n   {:op ':set!,\n    :env Env,\n    :form Form,\n    :target Expr,\n    :val Expr,\n    :children Children})\n  (t/HMap\n   :mandatory\n   {:op ':try,\n    :env Env,\n    :form Form,\n    :body Expr,\n    :catches (t/Vec Expr),\n    :children Children}\n   :optional\n   {:finally Expr})\n  (t/HMap\n   :mandatory\n   {:op ':binding, :env Env, :form Form, :name t/Symbol, :local t/Any}\n   :optional\n   {:tag Tag,\n    :arg-id t/Int,\n    :variadic? Boolean,\n    :o-tag OTag,\n    :mutable t/Any})\n  (t/HMap\n   :mandatory\n   {:op ':catch,\n    :env Env,\n    :form Form,\n    :class Class,\n    :local Expr,\n    :body Expr,\n    :children Children})\n  (t/HMap\n   :mandatory\n   {:op ':throw, :env Env, :form Form, :exception Expr})\n  (t/HMap\n   :mandatory\n   {:op ':letfn,\n    :env Env,\n    :form Form,\n    :body Expr,\n    :bindings (t/Vec Expr),\n    :children Children})\n  (t/HMap\n   :mandatory\n   {:op ':let,\n    :form Form,\n    :env Env,\n    :body Expr,\n    :bindings (t/Vec Expr),\n    :children Children})\n  (t/HMap\n   :mandatory\n   {:op ':loop,\n    :form Form,\n    :env Env,\n    :loop-id t/Symbol,\n    :body Expr,\n    :bindings (t/Vec Expr),\n    :children Children})\n  (t/HMap\n   :mandatory\n   {:op ':recur,\n    :env Env,\n    :form Form,\n    :exprs (t/Vec Expr),\n    :loop-id t/Symbol,\n    :children Children})\n  (t/HMap\n   :mandatory\n   {:children Children,\n    :loop-id t/Symbol,\n    :params (t/Vec Expr),\n    :fixed-arity t/Int,\n    :op ':fn-method,\n    :env Env,\n    :variadic? Boolean,\n    :form Form,\n    :body Expr}\n   :optional\n   {:local Expr})\n  (t/HMap\n   :mandatory\n   {:op ':fn,\n    :env Env,\n    :form Form,\n    :name (t/U nil t/Symbol),\n    :variadic? Boolean,\n    :max-fixed-arity (t/U nil t/Int),\n    :methods (t/Vec Expr),\n    :children Children}\n   :optional\n   {:local Expr})\n  (t/HMap\n   :mandatory\n   {:op ':def, :env Env, :form Form, :name t/Symbol}\n   :optional\n   {:meta Expr, :init Expr, :doc String, :children Children})\n  (t/HMap\n   :mandatory\n   {:op ':host-call,\n    :env Env,\n    :form Form,\n    :target Expr,\n    :method t/Symbol,\n    :args (t/Vec Expr),\n    :children Children})\n  (t/HMap\n   :mandatory\n   {:op ':host-field,\n    :env Env,\n    :form Form,\n    :target Expr,\n    :field t/Symbol,\n    :children Children})\n  (t/HMap\n   :mandatory\n   {:op ':host-interop,\n    :env Env,\n    :form Form,\n    :target Expr,\n    :m-or-f t/Symbol,\n    :children Children})\n  (t/HMap\n   :mandatory\n   {:op ':invoke,\n    :env Env,\n    :form Form,\n    :fn Expr,\n    :args (t/Vec Expr),\n    :children Children}\n   :optional\n   {:meta Expr})\n  (t/HMap :mandatory {:op ':the-var, :env Env, :form Form})\n  (t/HMap\n   :mandatory\n   {:op ':monitor-enter,\n    :env Env,\n    :form Form,\n    :target Expr,\n    :children Children})\n  (t/HMap\n   :mandatory\n   {:op ':monitor-exit,\n    :env Env,\n    :form Form,\n    :target Expr,\n    :children Children})\n  (t/HMap\n   :mandatory\n   {:op ':import, :env Env, :form Form, :class String})\n  (t/HMap\n   :mandatory\n   {:op ':method,\n    :env Env,\n    :form Form,\n    :loop-id t/Symbol,\n    :params (t/Vec Expr),\n    :fixed-arity t/Int,\n    :body Expr,\n    :children Children}\n   :optional\n   {:local Expr, :interfaces (t/Set (t/U nil Class))})\n  (t/HMap\n   :mandatory\n   {:op ':reify,\n    :env Env,\n    :form Form,\n    :class-name t/Symbol,\n    :methods (t/Vec Expr),\n    :children Children})\n  (t/HMap\n   :mandatory\n   {:interfaces (t/Set t/Any),\n    :children Children,\n    :name t/Symbol,\n    :fields (t/Vec Expr),\n    :op ':deftype,\n    :env Env,\n    :methods (t/Vec Expr),\n    :class-name t/Symbol,\n    :form Form})\n  (t/HMap\n   :mandatory\n   {:op ':case-test, :hash t/Any, :test Expr, :children Children})\n  (t/HMap\n   :mandatory\n   {:op ':case-then, :hash t/Any, :then Expr, :children Children})\n  (t/HMap\n   :mandatory\n   {:shift t/Any,\n    :mask t/Any,\n    :children Children,\n    :tests (t/Vec Expr),\n    :default Expr,\n    :skip-check? Boolean,\n    :op ':case,\n    :env Env,\n    :high t/Any,\n    :test-type t/Any,\n    :thens (t/Vec Expr),\n    :low t/Any,\n    :form Form,\n    :test Expr,\n    :switch-type t/Any})\n  (t/HMap\n   :mandatory\n   {:children Children,\n    :instance Expr,\n    :method t/Symbol,\n    :op ':instance-call,\n    :env Env,\n    :o-tag OTag,\n    :class Class,\n    :form Form,\n    :tag Tag}\n   :optional\n   {:args (t/Vec Expr)})\n  (t/HMap\n   :mandatory\n   {:op ':static-call,\n    :form Form,\n    :env Env,\n    :tag Tag,\n    :o-tag OTag,\n    :class Class,\n    :method t/Symbol}\n   :optional\n   {:args (t/Vec Expr)})\n  (t/HMap\n   :mandatory\n   {:op ':static-field,\n    :form Form,\n    :env Env,\n    :assignable? Boolean,\n    :class Class,\n    :field t/Symbol,\n    :o-tag OTag,\n    :tag Tag})\n  (t/HMap\n   :mandatory\n   {:children Children,\n    :instance Expr,\n    :field t/Symbol,\n    :op ':instance-field,\n    :env Env,\n    :o-tag OTag,\n    :class Class,\n    :form Form,\n    :tag Tag,\n    :assignable? Boolean})\n  (t/HMap\n   :mandatory\n   {:op ':keyword-invoke,\n    :env Env,\n    :form Form,\n    :fn Expr,\n    :args (t/Vec Expr),\n    :children Children}\n   :optional\n   {:meta Expr})\n  (t/HMap\n   :mandatory\n   {:op ':instance?,\n    :env Env,\n    :form Form,\n    :class Class,\n    :target Expr,\n    :o-tag OTag,\n    :tag Tag,\n    :children Children})\n  (t/HMap\n   :mandatory\n   {:op ':protocol-invoke,\n    :env Env,\n    :form Form,\n    :fn Expr,\n    :args (t/Vec Expr),\n    :children Children}\n   :optional\n   {:meta Expr})\n  (t/HMap\n   :mandatory\n   {:args (t/Vec Expr),\n    :children Children,\n    :fn Expr,\n    :op ':prim-invoke,\n    :env Env,\n    :o-tag OTag,\n    :prim-interface Class,\n    :form Form,\n    :tag Tag}\n   :optional\n   {:meta Expr})))\n"}
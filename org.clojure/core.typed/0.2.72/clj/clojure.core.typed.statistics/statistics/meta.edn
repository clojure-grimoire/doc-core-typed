{:type :fn, :src "(defn statistics \n  \"Takes a collection of namespace symbols and returns a map mapping the namespace\n  symbols to a map of data\"\n  [nsyms]\n  (assert (and (coll? nsyms) (every? symbol? nsyms))\n          \"Must pass a collection of symbols to statistics\")\n  (reduce (fn [stats nsym]\n            (let [_ (chk-ns-clj/check-ns nsym :collect-only true)\n                  ns (find-ns nsym)\n                  _ (assert ns (str \"Namespace \" nsym \" not found\"))]\n              (conj stats\n                    [nsym\n                     {:vars {:all-vars (all-defs-in-ns ns)\n                             :no-checks (let [; deref the atom\n                                              all-no-checks @var-env/CLJ-NOCHECK-VAR?]\n                                          (filter (fn [s] (= (namespace s) nsym)) all-no-checks))\n                             :var-annotations (let [; deref the atom\n                                                    annots @var-env/CLJ-VAR-ANNOTATIONS]\n                                                (->> annots\n                                                     (filter (fn [[k v]] (= (namespace k) (str nsym))))\n                                                     (map (fn [[k v]] [k (binding [vs/*verbose-types* true]\n                                                                           (prs/unparse-type v))]))\n                                                     (into {})))}}])))\n          {} nsyms))", :ns "clojure.core.typed.statistics", :name "statistics", :file "clojure/core/typed/statistics.clj", :column 1, :line 22, :arglists ([nsyms]), :doc "Takes a collection of namespace symbols and returns a map mapping the namespace\n  symbols to a map of data"}
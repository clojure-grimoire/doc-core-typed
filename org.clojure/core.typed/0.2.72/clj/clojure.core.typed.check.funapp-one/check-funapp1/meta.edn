{:type :fn, :src "(defn check-funapp1 [fexpr arg-exprs {{optional-kw :optional mandatory-kw :mandatory :as kws} :kws\n                                      :keys [dom rng rest drest] :as ftype0}\n                     argtys expected & {:keys [check?] :or {check? true}}]\n  {:pre [(r/Function? ftype0)\n         (every? r/TCResult? argtys)\n         ((some-fn nil? r/TCResult?) expected)\n         (con/boolean? check?)]\n   :post [(r/TCResult? %)]}\n  (when drest \n    (err/nyi-error \"funapp with drest args NYI\"))\n  ;  (prn \"check-funapp1\")\n  ;  (prn \"argtys objects\" (map r/ret-o argtys))\n  ;checking\n  (when check?\n    (let [nactual (count argtys)]\n      (when-not (or (when (and (not rest)\n                               (empty? optional-kw)\n                               (empty? mandatory-kw))\n                      (= (count dom) (count argtys)))\n                    (when rest\n                      (<= (count dom) nactual))\n                    (when kws\n                      (let [nexpected (+ (count dom)\n                                         (* 2 (count mandatory-kw)))]\n                        (and (even? (- nactual (count dom)))\n                             ((if (seq optional-kw) <= =)\n                              nexpected\n                              nactual)))))\n        (err/tc-delayed-error (str \"Wrong number of arguments, expected \" (count dom) \" fixed parameters\"\n                                 (cond\n                                   rest \" and a rest parameter \"\n                                   drest \" and a dotted rest parameter \"\n                                   kws (cond\n                                         (and (seq mandatory-kw) (seq optional-kw))\n                                         (str \", some optional keyword arguments and \" (count mandatory-kw) \n                                              \" mandatory keyword arguments\")\n\n                                         (seq mandatory-kw) (str \"and \" (count mandatory-kw) \"  mandatory keyword arguments\")\n                                         (seq optional-kw) \" and some optional keyword arguments\"))\n                                 \", and got \" nactual\n                                 \" for function \" (pr-str (prs/unparse-type ftype0))\n                                 \" and arguments \" (pr-str (mapv (comp prs/unparse-type r/ret-t) argtys)))))\n      (cond\n        ; case for regular rest argument, or no rest parameter\n        (or rest (empty? (remove nil? [rest drest kws])))\n        (doseq [[arg-t dom-t] (map vector \n                                   (map r/ret-t argtys) \n                                   (concat dom (when rest (repeat rest))))]\n          (below/check-below arg-t dom-t))\n        \n        ; case for mandatory or optional keyword arguments\n        kws\n        (do\n          ;check regular args\n          (doseq [[arg-t dom-t] (map vector (map r/ret-t (take (count dom) argtys)) dom)]\n            (below/check-below arg-t dom-t))\n          ;check keyword args\n          (let [flat-kw-argtys (drop (count dom) argtys)]\n            (when-not (even? (count flat-kw-argtys))\n              (err/tc-delayed-error  \n                (str \"Uneven number of arguments to function expecting keyword arguments\")))\n            (let [kw-args-paired-t (apply hash-map (map r/ret-t flat-kw-argtys))]\n              ;make sure all mandatory keys are present\n              (when-let [missing-ks (seq \n                                      (set/difference (set (keys mandatory-kw))\n                                                      (set (keys kw-args-paired-t))))]\n                (err/tc-delayed-error (str \"Missing mandatory keyword keys: \"\n                                         (pr-str (interpose \", \" (map prs/unparse-type missing-ks))))))\n              ;check each keyword argument is correctly typed\n              (doseq [[kw-key-t kw-val-t] kw-args-paired-t]\n                (when-not (r/Value? kw-key-t)\n                  (err/tc-delayed-error (str \"Can only check keyword arguments with Value keys, found\"\n                                           (pr-str (prs/unparse-type kw-key-t)))))\n                (let [expected-val-t ((some-fn optional-kw mandatory-kw) kw-key-t)]\n                  (if expected-val-t\n                    (below/check-below kw-val-t expected-val-t)\n                    ; It is an error to use an undeclared keyword arg because we want to treat the rest parameter\n                    ; as a complete hash-map.\n                    (err/tc-delayed-error (str \"Undeclared keyword parameter \" \n                                             (pr-str (prs/unparse-type kw-key-t)))))))))))))\n  (let [dom-count (count dom)\n        arg-count (+ dom-count (if rest 1 0) (count optional-kw))\n        o-a (map r/ret-o argtys)\n        _ (assert (every? obj/RObject? o-a))\n        t-a (map r/ret-t argtys)\n        _ (assert (every? r/Type? t-a))\n        [o-a t-a] (let [rs (for [[nm oa ta] (map vector \n                                                 (range arg-count) \n                                                 (concat o-a (repeatedly obj/EmptyObject-maker))\n                                                 (concat t-a (repeatedly c/Un)))]\n                             [(if (>= nm dom-count) (obj/EmptyObject-maker) oa)\n                              ta])]\n                    [(map first rs) (map second rs)])\n        [t-r f-r o-r flow-r] (open-result/open-Result rng o-a t-a)]\n    (r/ret t-r f-r o-r flow-r)))", :ns "clojure.core.typed.check.funapp-one", :name "check-funapp1", :file "clojure/core/typed/check/funapp_one.clj", :column 1, :line 13, :arglists ([fexpr arg-exprs {{optional-kw :optional, mandatory-kw :mandatory, :as kws} :kws, :keys [dom rng rest drest], :as ftype0} argtys expected & {:keys [check?], :or {check? true}}])}
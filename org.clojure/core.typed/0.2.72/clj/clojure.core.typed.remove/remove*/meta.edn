{:type :fn, :src "(defn remove* [old rem]\n  (let [old (c/fully-resolve-type old)\n        rem (c/fully-resolve-type rem)\n        initial (if (sub/subtype? old rem)\n                  (c/Un) ;the empty type\n                  (cond\n                    ;FIXME TR also tests for App? here. ie (or (r/Name? old) (App? old))\n                    (r/Name? old) ;; must be different, since they're not subtypes \n                    ;; and n must refer to a distinct struct type\n                    old\n                    (r/Union? old) (let [l (:types old)]\n                                   (apply c/Un (map (fn [e] (remove* e rem)) l)))\n                    (r/Mu? old) (remove* (c/unfold old) rem)\n                    (r/Poly? old) (let [vs (c/Poly-fresh-symbols* old)\n                                        b (c/Poly-body* vs old)]\n                                    (c/Poly* vs \n                                             (c/Poly-bbnds* vs old)\n                                             (remove* b rem)))\n                    :else old))]\n    (if (sub/subtype? old initial) old initial)))", :ns "clojure.core.typed.remove", :name "remove*", :file "clojure/core/typed/remove.clj", :column 1, :line 9, :arglists ([old rem])}
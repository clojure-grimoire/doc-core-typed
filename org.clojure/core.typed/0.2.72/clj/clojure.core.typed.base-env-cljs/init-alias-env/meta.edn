{:type :fn, :src "(delay-and-cache-env init-alias-env \n  (reset-protocol-env!)\n  (reset-jsnominal-env!)\n  (h/alias-mappings\n\n  ^{:doc \"A type that returns true for cljs.core/integer?\"}\ncljs.core.typed/AnyInteger int\n\n  ^{:doc \"A type that returns true for cljs.core/integer?\"}\ncljs.core.typed/Integer int\n\n  ^{:doc \"A type that returns true for cljs.core/number?\"}\ncljs.core.typed/Number number\n\n  ^{:doc \"A type that returns true for cljs.core/string?\"}\ncljs.core.typed/String string\n\n  ^{:doc \"A type that returns true for cljs.core/boolean?\"}\ncljs.core.typed/Boolean boolean\n\n  ^{:doc \"vector -- alias for common anns\"}\ncljs.core.typed/Vec (TFn [[x :variance :covariant]]\n                         (IVector x))\n\n  ^{:doc \"vector -- alias for common anns\"}\ncljs.core.typed/IPersistentVector (TFn [[x :variance :covariant]]\n                                       (IVector x))\n\n  ^{:doc \"map -- alias for common anns\"}\ncljs.core.typed/Map (TFn [[k :variance :covariant]\n                          [v :variance :covariant]]\n                         (IMap k v))\n\n  ^{:doc \"map -- alias for common anns\"}\ncljs.core.typed/IPersistentMap (TFn [[k :variance :covariant]\n                                     [v :variance :covariant]]\n                         (IMap k v))\n\n  ^{:doc \"map -- alias for common anns\"}\ncljs.core.typed/APersistentMap (TFn [[k :variance :covariant]\n                                     [v :variance :covariant]]\n                         (IMap k v))\n\n  ^{:doc \"associative -- alias for common anns\"}\ncljs.core.typed/Associative IAssociative\n\n  ^{:doc \"An atom that can read and write type x.\"\n    :forms [(Atom1 t)]}\ncljs.core.typed/Atom1 (TFn [[x :variance :invariant]] \n                           (cljs.core/Atom x x))\n  ^{:doc \"An atom that can write type w and read type r.\"\n    :forms [(Atom2 t)]}\ncljs.core.typed/Atom2 (TFn [[w :variance :contravariant]\n                            [r :variance :covariant]] \n                           (cljs.core/Atom w r))\n\n  ^{:doc \"sequential -- alias for common anns\"}\ncljs.core.typed/Sequential ISequential\n\n  ^{:doc \"set -- alias for common anns\"}\ncljs.core.typed/Set ISet\n\n  ^{:doc \"set -- alias for common anns\"}\ncljs.core.typed/IPersistentSet ISet\n\n\n  ^{:doc \"A type that can be used to create a sequence of member type x.\"}\ncljs.core.typed/Seqable (TFn [[x :variance :covariant]]\n                             (cljs.core/ISeqable x))\n\n  ^{:doc \"A persistent sequence of member type x.\"\n    :forms [(Seq t)]}\ncljs.core.typed/Seq (TFn [[x :variance :covariant]]\n                         (cljs.core/ISeq x))\n\n  ^{:doc \"A persistent sequence of member type x with count greater than 0.\"\n    :forms [(NonEmptySeq t)]}\ncljs.core.typed/NonEmptySeq (TFn [[x :variance :covariant]]\n                                 (I (cljs.core/ISeq x) (CountRange 1)))\n\n\n\n\n   ;;copied from impl/init-aliases\n\n   ;;Seqables\n  ^{:doc \"A type that can be used to create a sequence of member type x\nwith count 0.\"\n    :forms [(EmptySeqable t)]}\ncljs.core.typed/EmptySeqable (TFn [[x :variance :covariant]]\n                                  (I (cljs.core.typed/Seqable x) (ExactCount 0)))\n\n   ^{:doc \"A type that can be used to create a sequence of member type x\nwith count greater than 0.\"\n     :forms [(NonEmptySeqable t)]}\ncljs.core.typed/NonEmptySeqable\n    (TFn [[x :variance :covariant]]\n         (I (cljs.core.typed/Seqable x) (CountRange 1)))\n\n    ;;Option\n  ^{:doc \"A union of x and nil.\"\n    :forms [(Option t)]}\ncljs.core.typed/Option (TFn [[x :variance :covariant]] (U nil x))\n\n\n  ^{:doc \"A persistent collection with member type x.\"\n    :forms [(Coll t)]}\ncljs.core.typed/Coll (TFn [[x :variance :covariant]]\n                          (cljs.core/ICollection x))\n\n  ^{:doc \"A persistent collection with member type x and count greater than 0.\"\n    :forms [(NonEmptyColl t)]}\ncljs.core.typed/NonEmptyColl (TFn [[x :variance :covariant]]\n                                  (I (cljs.core/ICollection x)\n                                     (CountRange 1)))\n\n  ^{:doc \"A sequential non-empty seq retured from clojure.core/seq\"\n    :forms [(NonEmptyASeq t)]}\ncljs.core.typed/NonEmptyASeq\n   (TFn [[x :variance :covariant]]\n        (I (cljs.core/ASeq x)\n           (cljs.core/ISeq x)\n           (cljs.core/ISeqable x)\n           cljs.core/ISequential\n           ;(Iterable x)\n           (cljs.core/ICollection x)\n           (cljs.core/IList x)\n           ;clojure.lang.IObj\n           (CountRange 1)))\n\n\n  ^{:doc \"The type of all things with count 0. Use as part of an intersection.\n           eg. See EmptySeqable.\"\n    :forms [EmptyCount]}\ncljs.core.typed/EmptyCount (ExactCount 0)\n\n  ^{:doc \"The type of all things with count greater than 0. Use as part of an intersection.\n           eg. See NonEmptySeq\"\n     :forms [NonEmptyCount]}\ncljs.core.typed/NonEmptyCount (CountRange 1)\n\n  ^{:doc \"A union of x and nil.\"\n    :forms [(Nilable t)]}\ncljs.core.typed/Nilable (TFn [[x :variance :covariant]] (U nil x))\n\n  ^{:doc \"A persistent vector returned from clojure.core/vector (and others)\"\n    :forms [(AVec t)]}\ncljs.core.typed/AVec (TFn [[x :variance :covariant]]\n                             (I (IPersistentVector x)\n                                ;(java.lang.Iterable x)\n                                (ICollection x)\n                                (IList x)\n                                ;clojure.lang.IObj\n                                ))\n\n  ^{:doc \"A persistent vector returned from clojure.core/vector (and others) and count greater than 0.\"\n    :forms [(NonEmptyAVec t)]}\ncljs.core.typed/NonEmptyAVec (TFn [[x :variance :covariant]]\n                                        (I (IPersistentVector x)\n                                           ;(java.lang.Iterable x)\n                                           (ICollection x)\n                                           (IList x)\n                                           ;clojure.lang.IObj\n                                           (CountRange 1)))\n\n  ^{:doc \"The result of clojure.core/seq.\"\n    :forms [(NilableNonEmptyASeq t)]}\ncljs.core.typed/NilableNonEmptyASeq\n   (TFn [[x :variance :covariant]]\n        (U nil\n           (I (cljs.core/ASeq x)\n              (cljs.core/ISeq x)\n              cljs.core/ISequential\n              ;(Iterable x)\n              (cljs.core/ICollection x)\n              (cljs.core/IList x)\n              ;clojure.lang.IObj\n              (CountRange 1))))\n\n  ^{:doc \"A Clojure persistent list.\"\n    :forms [(PersistentList t)]}\ncljs.core.typed/PersistentList\n   (TFn [[x :variance :covariant]]\n        (cljs.core/IList x))\n\n  ^{:doc \"Collection\"}\ncljs.core.typed/Collection\n   (TFn [[x :variance :covariant]]\n        (cljs.core/ICollection x))\n\n  ^{:doc \"A Clojure stack.\"\n    :forms [(Stack t)]}\ncljs.core.typed/Stack\n   (TFn [[x :variance :covariant]]\n        (cljs.core/IStack x))\n\n   ^{:doc \"Reversible maps to IReversible\"\n     :forms [(Reversible t)]}\ncljs.core.typed/Reversible\n   (TFn [[x :variance :covariant]]\n        (cljs.core/IReversible x))))", :ns "clojure.core.typed.base-env-cljs", :name "init-alias-env", :file "clojure/core/typed/base_env_cljs.clj", :column 1, :line 258, :arglists ([])}
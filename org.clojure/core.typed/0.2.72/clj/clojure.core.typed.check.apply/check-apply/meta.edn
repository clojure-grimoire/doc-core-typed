{:type :fn, :src "(defn check-apply\n  [check-fn {[fexpr & args] :args :as expr} expected]\n  {:post [((some-fn r/TCResult? #{cu/not-special}) %)]}\n  (binding [vs/*current-expr* expr]\n    (let [ftype (r/ret-t (u/expr-type (check-fn fexpr)))\n          [fixed-args tail] [(butlast args) (last args)]]\n      (cond\n        ;apply of a simple function\n        (r/FnIntersection? ftype)\n        (do \n          (when (empty? (:types ftype))\n            (err/int-error (str \"Empty function intersection given as argument to apply\")))\n          (let [arg-tres (mapv check-fn fixed-args)\n                arg-tys (mapv (comp r/ret-t u/expr-type) arg-tres)\n                tail-ty (r/ret-t (u/expr-type (check-fn tail)))]\n            (loop [[{:keys [dom rng rest drest]} :as fs] (:types ftype)]\n              (cond\n                ;we've run out of cases to try, so error out\n                (empty? fs)\n                (err/tc-delayed-error \n                  (prs/with-unparse-ns (cu/expr-ns expr)\n                    (str \"Bad arguments to apply: \"\n                         \"\\n\\nTarget: \\t\" (prs/unparse-type ftype) \n                         \"\\n\\nArguments:\\t\" (str/join \" \" (mapv prs/unparse-type (concat arg-tys [tail-ty])))))\n                  :return (cu/error-ret expected))\n\n                ;this case of the function type has a rest argument\n                (and rest\n                     ;; check that the tail expression is a subtype of the rest argument\n                     (sub/subtype? tail-ty (c/Un r/-nil (c/RClass-of Seqable [rest])))\n                     (sub/subtypes-varargs? arg-tys dom rest nil))\n                (r/ret (r/Result-type* rng)\n                       (r/Result-filter* rng)\n                       (r/Result-object* rng))\n\n                ;other cases go here\n\n                ;next case\n                :else (recur (next fs))))))\n\n        ;; apply of a simple polymorphic function\n        (r/Poly? ftype)\n        (let [vars (c/Poly-fresh-symbols* ftype)\n              bbnds (c/Poly-bbnds* vars ftype)\n              body (c/Poly-body* vars ftype)\n              _ (assert (r/FnIntersection? body))\n              arg-tres (mapv check-fn fixed-args)\n              arg-tys (mapv (comp r/ret-t u/expr-type) arg-tres)\n              tail-bound nil\n              tail-ty (r/ret-t (u/expr-type (check-fn tail)))]\n          (loop [[{:keys [dom rng rest drest] :as ftype0} :as fs] (:types body)]\n            ;          (when (seq fs)\n            ;            (prn \"checking fn\" (prs/unparse-type (first fs))\n            ;                 (mapv prs/unparse-type arg-tys)))\n            (cond\n              (empty? fs) (err/tc-delayed-error (str \"Bad arguments to polymorphic function in apply\")\n                                                :return (cu/error-ret expected))\n              ;the actual work, when we have a * function and a list final argument\n              :else \n              (if-let [substitution (cgen/handle-failure\n                                      (and rest (not tail-bound) \n                                           (<= (count dom)\n                                               (count arg-tys))\n                                           (cgen/infer-vararg (zipmap vars bbnds) {}\n                                                              (cons tail-ty arg-tys)\n                                                              (cons (c/Un r/-nil (c/RClass-of Seqable [rest])) dom)\n                                                              rest\n                                                              (r/Result-type* rng))))]\n                (r/ret (subst/subst-all substitution (r/Result-type* rng)))\n                (recur (next fs))))))\n\n        :else cu/not-special))))", :ns "clojure.core.typed.check.apply", :name "check-apply", :file "clojure/core/typed/check/apply.clj", :column 1, :line 15, :arglists ([check-fn {[fexpr & args] :args, :as expr} expected])}
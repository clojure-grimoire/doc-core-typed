{:ns "clojure.core.typed.test.protocol-monads", :name "do", :file "clojure/core/typed/test/protocol_monads.clj", :type :macro, :src "(defmacro do\n  \"Monad comprehension. Takes the name of a monad (like vector, hash-set),\n   a vector of steps given as binding-form/monadic-expression pairs, and\n   a result value specified by expr. The monadic-expression terms can use\n   the binding variables of the previous steps.\n   If the monad contains a definition of m-zero, the step list can also\n   contain conditions of the form :when p, where the predicate p can\n   contain the binding variables from all previous steps.\n   A clause of the form :let [binding-form expr ...], where the bindings\n   are given as a vector as for the use in let, establishes additional\n   bindings that can be used in the following steps.\"\n  [result bindings expr]\n  (let [steps (partition 2 bindings)]\n    `(monads.core/bind (~result nil)\n                       (fn [_#]\n                         ~(reduce (fn [expr [sym mv]]\n                                    (cond\n                                     (= :when sym) `(if ~mv\n                                                      ~expr\n                                                      (monads.core/zero (~result nil)))\n                                     (= :let sym) `(let ~mv\n                                                     ~expr)\n                                     :else `(monads.core/bind ~mv (fn [~sym]\n                                                                     ~expr))))\n                                  `(monads.core/do-result (~result nil) ~expr)\n                                  (reverse steps))))))", :column 1, :line 25, :macro true, :arglists ([result bindings expr]), :doc "Monad comprehension. Takes the name of a monad (like vector, hash-set),\n   a vector of steps given as binding-form/monadic-expression pairs, and\n   a result value specified by expr. The monadic-expression terms can use\n   the binding variables of the previous steps.\n   If the monad contains a definition of m-zero, the step list can also\n   contain conditions of the form :when p, where the predicate p can\n   contain the binding variables from all previous steps.\n   A clause of the form :let [binding-form expr ...], where the bindings\n   are given as a vector as for the use in let, establishes additional\n   bindings that can be used in the following steps."}
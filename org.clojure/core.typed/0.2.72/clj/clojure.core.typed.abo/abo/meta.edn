{:type :fn, :src "(defn abo [xs idxs f]\n  {:pre [(every? symbol? xs)\n         (every? integer? idxs)\n         (fl/Filter? f)]\n   :post [(fl/Filter? %)]}\n  ;(prn \"abo\" xs idxs f)\n  (letfn [(lookup [y]\n            ; Difference from Typed Racket:\n            ;   because abstract-result calls abstract-type, we could have\n            ;   already-abstracted filters at this point. We relax the contract\n            ;   to allow naturals.\n            ;\n            ; eg. (ann-form (fn [] (fn [b] b)) [-> [Any -> Any]])\n            ;\n            ;    In this type the (fn [b] b) is already abstracted as \n            ;      [Any -> Any :filters {:then (! (U nil false) 0), :else (is (U nil false) 0)} :object {:id 0}]\n            ;    by the time we call abstract-result.\n            {:pre [((some-fn symbol? con/znat?) y)]\n             :post [((some-fn nil? integer?) %)]}\n            (some (fn [[x i]] (and (= x y) i))\n                  (map vector xs idxs)))\n          (rec [f] (abo xs idxs f))\n          (sb-t [t] (abstract-type xs idxs t))]\n    (fold/fold-rhs ::abo\n      {:type-rec sb-t \n       :filter-rec rec\n       :locals {:lookup lookup}}\n      f)))", :ns "clojure.core.typed.abo", :name "abo", :file "clojure/core/typed/abo.clj", :column 1, :line 90, :arglists ([xs idxs f])}
{:type :fn, :src "(defn check-nthnext [check-fn {:keys [args] :as expr} expected & {:keys [cargs]}]\n  (let [[ctarget cn :as cargs] (or cargs (mapv check-fn args))]\n    (if-not (#{2} (count cargs))\n      cu/not-special\n      (let [target-t (c/fully-resolve-type (-> ctarget u/expr-type r/ret-t))\n            target-types (if (r/Union? target-t)\n                           (:types target-t)\n                           [target-t])\n            num-t (-> cn u/expr-type r/ret-t)]\n        (if (and (every? c/AnyHSequential? target-types)\n                 (r/Value? num-t)\n                 (integer? (:val num-t)))\n          (-> expr\n              (update-in [:fn] check-fn)\n              (assoc\n                  :args cargs\n                  u/expr-type (r/ret (apply c/Un (map (partial nthnext-type num-t) target-types)))))\n          cu/not-special)))))", :ns "clojure.core.typed.check.nthnext", :name "check-nthnext", :file "clojure/core/typed/check/nthnext.clj", :column 1, :line 28, :arglists ([check-fn {:keys [args], :as expr} expected & {:keys [cargs]}])}
{:ns "clojure.core.typed.test.common-utils", :name "tc-e", :file "clojure/core/typed/test/common_utils.clj", :type :fn, :src "(defn tc-e \n  \"Type check an an expression in namespace that :refer's\n  all of clojure.core.typed (aliased to t) and aliases clojure.core\n  to core.\n\n  Takes one form and then options, and returns true if the form checks\n  with the expected input/output types according to the provided options.\n  \n  The first form in the options can be a static type syntax scoped\n  in the new namespace. This is disambiguated with a call to keyword?\n  (literal keywords aren't valid type syntax).\n  \n  eg. (tc-e (+ 1 1) Num)\n      ;=> Num\n\n  Keyword Options:\n\n    :expected-ret An expected ret, evaluated in the current namespace (not the new\n                  one that refers c.c.t). Cannot be provided in combination with the implicit\n                  first option as a type, as above.\n    :ret          Check the return TCResult of this expression against this ret. Evaluated\n                  in the current namespace.\"\n  [tc-common* frm & opts]\n  (let [[opts t has-t?] (if (and opts (not (keyword? (first opts))))\n                          [(rest opts) (first opts) true]\n                          [opts])\n        _ (assert (even? (count opts))\n                  \"Uneven arguments to tc-e\")\n        {:as opts} opts\n        _ (assert (not (and has-t? (contains? opts :expected)))\n                  \"Can't provide both implicit expected type and :expected kw to tc-e\")\n        has-t? (or has-t? (contains? opts :expected))\n        t (or t (:expected opts))\n        has-ret? (contains? opts :ret)\n        _ (assert (not (and has-t? (contains? opts :expected-ret)))\n                  \"Can't provide both expected type and expected ret\")\n        actual-ret (gensym 'ret)]\n    `(let [{~actual-ret :ret delayed-errors# :delayed-errors} ~(tc-common* frm (assoc opts\n                                                                               :expected-syntax {:provided? has-t?\n                                                                                                 :syn t}))]\n       (or (when (empty? delayed-errors#)\n             ~(when has-ret?\n                `(assert (= ~actual-ret ~(:ret opts))))\n             ~actual-ret)\n           (err/print-errors! delayed-errors#)))))", :column 1, :line 4, :arglists ([tc-common* frm & opts]), :doc "Type check an an expression in namespace that :refer's\n  all of clojure.core.typed (aliased to t) and aliases clojure.core\n  to core.\n\n  Takes one form and then options, and returns true if the form checks\n  with the expected input/output types according to the provided options.\n  \n  The first form in the options can be a static type syntax scoped\n  in the new namespace. This is disambiguated with a call to keyword?\n  (literal keywords aren't valid type syntax).\n  \n  eg. (tc-e (+ 1 1) Num)\n      ;=> Num\n\n  Keyword Options:\n\n    :expected-ret An expected ret, evaluated in the current namespace (not the new\n                  one that refers c.c.t). Cannot be provided in combination with the implicit\n                  first option as a type, as above.\n    :ret          Check the return TCResult of this expression against this ret. Evaluated\n                  in the current namespace."}
{:type :fn, :src "(defn combine-props [new-props old-props flag]\n  {:pre [(every? fl/Filter? (concat new-props old-props))\n         (instance? clojure.lang.Atom flag)\n         (con/boolean? @flag)]\n   :post [(let [[derived-props derived-atoms] %]\n            (and (every? (some-fn fl/ImpFilter? fl/OrFilter? fl/AndFilter?) derived-props)\n                 (every? (some-fn fl/TypeFilter? fl/NotTypeFilter?) derived-atoms)))]}\n  (let [atomic-prop? (some-fn fl/TypeFilter? fl/NotTypeFilter?)\n        {new-atoms true new-formulas false} (group-by (comp boolean atomic-prop?) (flatten-props new-props))]\n    (loop [derived-props []\n           derived-atoms new-atoms\n           worklist (concat old-props new-formulas)]\n      (if (empty? worklist)\n        [derived-props derived-atoms]\n        (let [p (first worklist)\n              p (resolve* derived-atoms p)]\n          (cond\n            (fl/AndFilter? p) (recur derived-props derived-atoms (concat (:fs p) (next worklist)))\n            (fl/ImpFilter? p) \n            (let [{:keys [a c]} p\n                  implied? (some (fn [p] (fo/implied-atomic? a p)) (concat derived-props derived-atoms))]\n              #_(prn \"combining \" (unparse-filter p) \" with \" (map unparse-filter (concat derived-props\n                                                                                          derived-atoms))\n                     \" and implied:\" implied?)\n              (if implied?\n                (recur derived-props derived-atoms (cons c (rest worklist)))\n                (recur (cons p derived-props) derived-atoms (next worklist))))\n            (fl/OrFilter? p)\n            (let [ps (:fs p)\n                  new-or (loop [ps ps\n                                result []]\n                           (cond\n                             (empty? ps) (apply fo/-or result)\n                             (some (fn [other-p] (fo/opposite? (first ps) other-p))\n                                   (concat derived-props derived-atoms))\n                             (recur (next ps) result)\n                             (some (fn [other-p] (fo/implied-atomic? (first ps) other-p))\n                                   derived-atoms)\n                             fl/-top\n                             :else (recur (next ps) (cons (first ps) result))))]\n              (if (fl/OrFilter? new-or)\n                (recur (cons new-or derived-props) derived-atoms (next worklist))\n                (recur derived-props derived-atoms (cons new-or (next worklist)))))\n            (and (fl/TypeFilter? p)\n                 (= (c/Un) (:type p)))\n            (do \n              ;(prn \"Variable set to bottom:\" (unparse-filter p))\n              (reset! flag false)\n              [derived-props derived-atoms])\n            (fl/TypeFilter? p) (recur derived-props (cons p derived-atoms) (next worklist))\n            (and (fl/NotTypeFilter? p)\n                 (= r/-any (:type p)))\n            (do \n              ;(prn \"Variable set to bottom:\" (unparse-filter p))\n              (reset! flag false)\n              [derived-props derived-atoms])\n            (fl/NotTypeFilter? p) (recur derived-props (cons p derived-atoms) (next worklist))\n            (fl/TopFilter? p) (recur derived-props derived-atoms (next worklist))\n            (fl/BotFilter? p) (do \n                                ;(prn \"Bot filter found\")\n                                (reset! flag false)\n                                [derived-props derived-atoms])\n            :else (recur (cons p derived-props) derived-atoms (next worklist))))))))", :ns "clojure.core.typed.update", :name "combine-props", :file "clojure/core/typed/update.clj", :column 1, :line 55, :arglists ([new-props old-props flag])}
{:type :fn, :src "(defn suggest-type-hints [m-or-f targett argtys & {:keys [constructor-call]}]\n  {:pre [((some-fn nil? r/Type?) targett)\n         (every? r/Type? argtys)]}\n  (let [targett (when targett\n                  (c/fully-resolve-type targett))\n        cls (cond\n              constructor-call (coerce/symbol->Class constructor-call)\n              (r/RClass? targett) (r/RClass->Class targett))]\n    (when cls\n      (let [r (reflect-u/reflect cls)\n            {methods clojure.reflect.Method\n             fields clojure.reflect.Field\n             ctors clojure.reflect.Constructor\n             :as members}\n            (group-by\n              class\n              (filter (fn [{:keys [name] :as m}] \n                        (if constructor-call\n                          (instance? clojure.reflect.Constructor m)\n                          (= m-or-f name)))\n                      (:members r)))]\n      (cond\n        (empty? members) (str \"\\n\\nTarget \" (coerce/Class->symbol cls) \" has no member \" m-or-f)\n        (seq members) (str \"\\n\\nAdd type hints to resolve the host call.\"\n                           (when (seq ctors)\n                             (str \"\\n\\nSuggested constructors:\\n\"\n                                  (apply str\n                                           (map \n                                             (fn [{ctor-name :name \n                                                   :keys [parameter-types flags] :as field}]\n                                               (str \"\\n  \"\n                                                    (apply str (interpose \" \" (map name flags)))\n                                                    (when (seq flags) \" \")\n                                                    (reflect-u/pprint-reflection-sym ctor-name) \" \"\n                                                    \"(\"\n                                                    (apply str \n                                                           (interpose \n                                                             \", \" \n                                                             (map reflect-u/pprint-reflection-sym parameter-types)))\n                                                    \")\"))\n                                             ctors))))\n                             (when (seq fields)\n                               (str \"\\n\\nSuggested fields:\\n\"\n                                    (apply str\n                                           (map \n                                             (fn [[clssym cls-fields]]\n                                               (apply str\n                                                      \"\\n \" (reflect-u/pprint-reflection-sym clssym)\n                                                      \"\\n \\\\\"\n                                                      (map\n                                                        (fn [{field-name :name \n                                                              :keys [flags type] :as field}]\n                                                          (str \"\\n  \"\n                                                               (apply str (interpose \" \" (map name flags)))\n                                                               (when (seq flags) \" \")\n                                                               (reflect-u/pprint-reflection-sym type) \" \"\n                                                               field-name))\n                                                        cls-fields)))\n                                             (group-by :declaring-class fields)))))\n                             (when (seq methods)\n                               (let [methods-by-class (group-by :declaring-class methods)]\n                                 (str \"\\n\\nSuggested methods:\\n\"\n                                      (apply str\n                                             (map\n                                               (fn [[clsym cls-methods]]\n                                                 (apply str\n                                                        \"\\n \" (reflect-u/pprint-reflection-sym clsym)\n                                                        \"\\n \\\\\"\n                                                        (map \n                                                          (fn [{method-name :name \n                                                                :keys [return-type parameter-types flags] :as method}] \n                                                            (str \n                                                              \"\\n  \"\n                                                              (apply str (interpose \" \" (map name flags)))\n                                                              (when (seq flags) \" \")\n                                                              (reflect-u/pprint-reflection-sym return-type) \" \"\n                                                              method-name \n                                                              \"(\" \n                                                              (apply str \n                                                                     (interpose \n                                                                       \", \" \n                                                                       (map reflect-u/pprint-reflection-sym parameter-types))) \n                                                              \")\"))\n                                                          cls-methods)))\n                                               methods-by-class)))))))))))", :ns "clojure.core.typed.check.type-hints", :name "suggest-type-hints", :file "clojure/core/typed/check/type_hints.clj", :column 1, :line 7, :arglists ([m-or-f targett argtys & {:keys [constructor-call]}])}
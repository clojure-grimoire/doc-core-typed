{:type :fn, :src "(defn check-funapp [fexpr args fexpr-ret-type arg-ret-types expected]\n  {:pre [(r/TCResult? fexpr-ret-type)\n         (every? r/TCResult? arg-ret-types)\n         ((some-fn nil? r/TCResult?) expected)]\n   :post [(r/TCResult? %)]}\n  (u/p :check/check-funapp\n  (let [fexpr-type (c/fully-resolve-type (r/ret-t fexpr-ret-type))\n        arg-types (mapv r/ret-t arg-ret-types)]\n    (prs/with-unparse-ns (or prs/*unparse-type-in-ns*\n                             (when fexpr\n                               (cu/expr-ns fexpr)))\n    ;(prn \"check-funapp\" (prs/unparse-type fexpr-type) (map prs/unparse-type arg-types))\n    (cond\n      ;; a union of functions can be applied if we can apply all of the elements\n      (r/Union? fexpr-type)\n      (r/ret (reduce (fn [t ftype]\n                     {:pre [(r/Type? t)\n                            (r/Type? ftype)]\n                      :post [(r/Type? %)]}\n                     (c/Un t (r/ret-t (check-funapp fexpr args (r/ret ftype) arg-ret-types expected))))\n                   (c/Un)\n                   (:types fexpr-type)))\n\n      ; try the first thing that looks like a Fn.\n      ; FIXME This should probably try and invoke every Fn it can\n      ; find, need to figure out how to clean up properly\n      ; after a failed invocation.\n      (r/Intersection? fexpr-type)\n      (let [a-fntype (first (filter\n                              (fn [t]\n                                (or (r/FnIntersection? t)\n                                    (r/Poly? t)))\n                              (map c/fully-resolve-type (:types fexpr-type))))]\n        (if a-fntype\n          (check-funapp fexpr args (r/ret a-fntype) arg-ret-types expected)\n          (err/int-error (str \"Cannot invoke type: \" fexpr-type))))\n\n      (ifn-ancestor fexpr-type)\n      (check-funapp fexpr args (r/ret (ifn-ancestor fexpr-type)) arg-ret-types expected)\n\n      ;keyword function\n      (c/keyword-value? fexpr-type)\n      (let [[target-ret default-ret & more-args] arg-ret-types]\n        (assert (empty? more-args))\n        (invoke-kw/invoke-keyword nil fexpr-ret-type target-ret default-ret expected))\n\n      ;set function\n      ;FIXME yuck. Also this is wrong, should be APersistentSet or something that *actually* extends IFn\n      (and (r/RClass? fexpr-type)\n           (isa? (coerce/symbol->Class (:the-class fexpr-type)) \n                 clojure.lang.IPersistentSet))\n      (do\n        (when-not (#{1} (count args))\n          (err/tc-delayed-error (str \"Wrong number of arguments to set function (\" (count args)\")\")))\n        (r/ret r/-any))\n\n      ;FIXME same as IPersistentSet case\n      (and (r/RClass? fexpr-type)\n           (isa? (coerce/symbol->Class (:the-class fexpr-type)) clojure.lang.IPersistentMap))\n      ;rewrite ({..} x) as (f {..} x), where f is some dummy fn\n      (let [mapfn (prs/parse-type `(t/All [x#] [(t/Map t/Any x#) t/Any ~'-> (t/U nil x#)]))]\n        (check-funapp fexpr args (r/ret mapfn) (concat [fexpr-ret-type] arg-ret-types) expected))\n\n      ;Symbol function\n      (and (r/RClass? fexpr-type)\n           ('#{clojure.lang.Symbol} (:the-class fexpr-type)))\n      (let [symfn (prs/parse-type `(t/All [x#] [(t/U (t/Map t/Any x#) t/Any) ~'-> (t/U x# nil)]))]\n        (check-funapp fexpr args (r/ret symfn) arg-ret-types expected))\n      \n      ;Var function\n      (and (r/RClass? fexpr-type)\n           ('#{clojure.lang.Var} (:the-class fexpr-type)))\n      (let [{[_ ftype :as poly?] :poly?} fexpr-type\n            _ (assert (#{2} (count poly?))\n                      \"Assuming clojure.lang.Var only takes 1 argument\")]\n        (check-funapp fexpr args (r/ret ftype) arg-ret-types expected))\n\n      ;Error is perfectly good fn type\n      (r/TCError? fexpr-type)\n      (r/ret r/Err)\n\n      (r/HSet? fexpr-type)\n      (let [fixed (:fixed fexpr-type)]\n        (cond\n          (not (#{1} (count arg-ret-types))) \n          (do (err/tc-delayed-error (str \"Wrong number of arguments to set (\" (count args)\")\"))\n              (r/ret r/Err))\n\n          :else\n          (let [[argt] arg-ret-types\n                ; default value is nil\n                set-return (apply c/Un r/-nil fixed)]\n            (if (and (:complete? fexpr-type)\n                     (every? (every-pred\n                               r/Value?\n                               (comp hset/valid-fixed? :val))\n                             fixed))\n              (let [; (#{false nil} a) returns false even if a is nil/false\n                    filter-type (apply c/Un\n                                       (disj (r/sorted-type-set fixed) \n                                             (r/-val nil)\n                                             (r/-val false)))]\n                (r/ret set-return\n                       (fops/-FS\n                         (fops/-filter-at filter-type (r/ret-o argt))\n                         (fops/-not-filter-at filter-type (r/ret-o argt)))))\n              (r/ret set-return)))))\n\n  ; FIXME error messages are worse here because we don't use line numbers for\n  ; specific arguments\n      ;ordinary Function, single case, special cased for improved error msgs\n;      (and (r/FnIntersection? fexpr-type)\n;           (let [[{:keys [drest] :as ft} :as ts] (:types fexpr-type)]\n;             (and (= 1 (count ts))\n;                  (not drest))))\n;      (u/p :check/funapp-single-arity-nopoly-nodots\n;      (let [argtys arg-ret-types\n;            {[t] :types} fexpr-type]\n;        (funapp1/check-funapp1 fexpr args t argtys expected)))\n\n      ;ordinary Function, multiple cases\n      (r/FnIntersection? fexpr-type)\n      (u/p :check/funapp-nopoly-nodots\n      (let [ftypes (:types fexpr-type)\n            matching-fns (filter (fn [{:keys [dom rest kws] :as f}]\n                                   {:pre [(r/Function? f)]}\n                                   (sub/subtypes-varargs? arg-types dom rest kws))\n                                 ftypes)\n            success-ret-type (when-let [f (first matching-fns)]\n                               (funapp1/check-funapp1 fexpr args f arg-ret-types expected :check? false))]\n        (if success-ret-type\n          success-ret-type\n          (app-err/plainapp-type-error fexpr args fexpr-type arg-ret-types expected))))\n\n      ;ordinary polymorphic function without dotted rest\n      (when (r/Poly? fexpr-type)\n        (let [names (c/Poly-fresh-symbols* fexpr-type)\n              body (c/Poly-body* names fexpr-type)]\n          (when (r/FnIntersection? body)\n            (every? (complement :drest) (:types body)))))\n      (u/p :check/funapp-poly-nodots\n      (let [fs-names (c/Poly-fresh-symbols* fexpr-type)\n            _ (assert (every? symbol? fs-names))\n            fin (c/Poly-body* fs-names fexpr-type)\n            bbnds (c/Poly-bbnds* fs-names fexpr-type)\n            _ (assert (r/FnIntersection? fin))\n            ;; Only infer free variables in the return type\n            ret-type \n            (free-ops/with-bounded-frees (zipmap (map r/F-maker fs-names) bbnds)\n                     (loop [[{:keys [dom rng rest drest kws] :as ftype} & ftypes] (:types fin)]\n                       (when ftype\n                         #_(prn \"infer poly fn\" (prs/unparse-type ftype) (map prs/unparse-type arg-types)\n                                (count dom) (count arg-types))\n                         #_(prn ftype)\n                         #_(when rest (prn \"rest\" (prs/unparse-type rest)))\n                         ;; only try inference if argument types are appropriate\n                         (if-let \n                           [substitution \n                            (cgen/handle-failure\n                              (cond\n                                ;possibly present rest argument, or no rest parameter\n                                (and (not (or drest kws))\n                                     ((if rest <= =) (count dom) (count arg-types)))\n                                (cgen/infer-vararg (zipmap fs-names bbnds) {} \n                                                   arg-types dom rest (r/Result-type* rng)\n                                                   (and expected (r/ret-t expected)))\n\n                                ;keyword parameters\n                                kws\n                                (let [{:keys [mandatory optional]} kws\n                                      [normal-argtys flat-kw-argtys] (split-at (count dom) arg-types)\n                                      _ (when-not (even? (count flat-kw-argtys))\n                                          ; move to next arity\n                                          (cgen/fail! nil nil)\n                                          #_(err/int-error (str \"Uneven number of keyword arguments \"\n                                                                \"provided to polymorphic function \"\n                                                                \"with keyword parameters.\")))\n                                      paired-kw-argtys (apply hash-map flat-kw-argtys)\n\n                                      ;generate two vectors identical in length with actual kw val types\n                                      ;on the left, and expected kw val types on the right.\n\n                                      [kw-val-actual-tys kw-val-expected-tys]\n                                      (reduce (fn [[kw-val-actual-tys kw-val-expected-tys]\n                                                   [kw-key-t kw-val-t]]\n                                                {:pre [(vector? kw-val-actual-tys)\n                                                       (vector? kw-val-expected-tys)\n                                                       (r/Type? kw-key-t)\n                                                       (r/Type? kw-val-t)]\n                                                 :post [((con/hvector-c? (every-pred vector? (con/every-c? r/Type?)) \n                                                                       (every-pred vector? (con/every-c? r/Type?)))\n                                                         %)]}\n                                                (when-not (r/Value? kw-key-t)\n                                                  ; move to next arity\n                                                  (cgen/fail! nil nil)\n                                                  #_(err/int-error \n                                                    (str \"Can only check keyword arguments with Value keys, found\"\n                                                         (pr-str (prs/unparse-type kw-key-t)))))\n                                                (let [expected-val-t ((some-fn optional mandatory) kw-key-t)]\n                                                  (if expected-val-t\n                                                    [(conj kw-val-actual-tys kw-val-t)\n                                                     (conj kw-val-expected-tys expected-val-t)]\n                                                    (do \n                                                      ; Using undeclared keyword keys is an error because we want to treat\n                                                      ; the rest param as a complete hash map when checking \n                                                      ; fn bodies.\n                                                      (err/tc-delayed-error (str \"Undeclared keyword parameter \" \n                                                                               (pr-str (prs/unparse-type kw-key-t))))\n                                                      [(conj kw-val-actual-tys kw-val-t)\n                                                       (conj kw-val-expected-tys r/-any)]))))\n                                              [[] []]\n                                              paired-kw-argtys)]\n                                  ;make sure all mandatory keys are present\n                                  (when-let [missing-ks (seq \n                                                          (set/difference (set (keys mandatory))\n                                                                          (set (keys paired-kw-argtys))))]\n                                    ; move to next arity\n                                    (cgen/fail! nil nil))\n                                    ;(err/tc-delayed-error (str \"Missing mandatory keyword keys: \"\n                                    ;                         (pr-str (vec (interpose \", \"\n                                    ;                                                 (map prs/unparse-type missing-ks))))))\n                                  ;; it's probably a bug to not infer for unused optional args, revisit this\n                                  ;(when-let [missing-optional-ks (seq\n                                  ;                                 (set/difference (set (keys optional))\n                                  ;                                                 (set (keys paired-kw-argtys))))]\n                                  ;  (err/nyi-error (str \"NYI POSSIBLE BUG?! Unused optional parameters\"\n                                  ;                    (pr-str (interpose \", \" (map prs/unparse-type missing-optional-ks)))))\n                                  ;  )\n                                  ; infer keyword and fixed parameters all at once\n                                  (cgen/infer (zipmap fs-names bbnds) {}\n                                              (concat normal-argtys kw-val-actual-tys)\n                                              (concat dom kw-val-expected-tys) \n                                              (r/Result-type* rng)\n                                              (and expected (r/ret-t expected))))))]\n                           (let [;_ (prn \"subst:\" substitution)\n                                 new-ftype (subst/subst-all substitution ftype)]\n                             ;(prn \"substituted type\" new-ftype)\n                             (funapp1/check-funapp1 fexpr args new-ftype\n                                            arg-ret-types expected :check? false))\n                           (if drest\n                             (do (err/tc-delayed-error (str \"Cannot infer arguments to polymorphic functions with dotted rest\"))\n                                 nil)\n                             (recur ftypes))))))]\n        (if ret-type\n          ret-type\n          (app-err/polyapp-type-error fexpr args fexpr-type arg-ret-types expected))))\n\n      :else ;; any kind of dotted polymorphic function without mandatory or optional keyword args\n      (if-let [[pbody fixed-map dotted-map]\n               (letfn [(should-infer? [t]\n                         (and (r/PolyDots? t)\n                              (r/FnIntersection?\n                                (c/PolyDots-body* (c/PolyDots-fresh-symbols* t)\n                                                  t))))\n                       (collect-polydots [t]\n                         {:post [((con/hvector-c? r/Type?\n                                                  (con/hash-c? symbol? r/Bounds?)\n                                                  (con/hash-c? symbol? r/Bounds?))\n                                  %)]}\n                         (loop [pbody (c/fully-resolve-type t)\n                                fixed {}\n                                dotted {}]\n                           (cond \n                             (r/PolyDots? pbody)\n                             (let [vars (vec (c/PolyDots-fresh-symbols* pbody))\n                                   bbnds (c/PolyDots-bbnds* vars pbody)\n                                   fixed* (apply zipmap (map butlast [vars bbnds]))\n                                   dotted* (apply hash-map (map last [vars bbnds]))\n                                   pbody (c/PolyDots-body* vars pbody)]\n                               (recur (c/fully-resolve-type pbody)\n                                      (merge fixed fixed*)\n                                      (merge dotted dotted*)))\n\n                             (and (r/FnIntersection? pbody)\n                                  (seq (:types pbody))\n                                  (not (some :kws (:types pbody))))\n                             [pbody fixed dotted])))]\n                 ; don't support nested PolyDots yet\n                 (when (should-infer? fexpr-type)\n                   (collect-polydots fexpr-type)))]\n        (let [;_ (prn \"polydots, no kw args\")\n              _ (assert (#{1} (count dotted-map)))\n              inferred-rng \n              (free-ops/with-bounded-frees (zipmap (map r/make-F (keys fixed-map)) (vals fixed-map))\n                ;(dvar-env/with-dotted-mappings (zipmap (keys dotted-map) (map r/make-F (vals dotted-map)))\n                 (some identity\n                       (for [{:keys [dom rest drest rng] :as ftype} (:types pbody)\n                             ;only try inference if argument types match\n                             :when (cond\n                                     rest (<= (count dom) (count arg-types))\n                                     drest (and (<= (count dom) (count arg-types))\n                                                (contains? (set (keys dotted-map)) (-> drest :name)))\n                                     :else (= (count dom) (count arg-types)))]\n                         (cgen/handle-failure\n                           ;(prn \"Inferring dotted fn\" (prs/unparse-type ftype))\n                           ;; Only try to infer the free vars of the rng (which includes the vars\n                           ;; in filters/objects).\n                           (let [substitution (cond\n                                                drest (cgen/infer-dots fixed-map (key (first dotted-map)) (val (first dotted-map))\n                                                                       arg-types dom (:pre-type drest) (r/Result-type* rng) \n                                                                       (frees/fv rng)\n                                                                       :expected (and expected (r/ret-t expected)))\n                                                rest (cgen/infer-vararg fixed-map dotted-map\n                                                                        arg-types dom rest (r/Result-type* rng)\n                                                                        (and expected (r/ret-t expected)))\n                                                :else (cgen/infer fixed-map dotted-map\n                                                                  arg-types dom (r/Result-type* rng)\n                                                                  (and expected (r/ret-t expected))))\n                                 ;_ (prn \"substitution:\" substitution)\n                                 substituted-type (subst/subst-all substitution ftype)\n                                 ;_ (prn \"substituted-type\" (prs/unparse-type substituted-type))\n                                 ;_ (prn \"args\" (map prs/unparse-type arg-types))\n                                 ]\n                             (or (and substitution\n                                      (funapp1/check-funapp1 fexpr args \n                                                     substituted-type arg-ret-types expected :check? false))\n                                 (err/tc-delayed-error \"Error applying dotted type\")\n                                 nil))))))]\n          ;(prn \"inferred-rng\"inferred-rng)\n          (if inferred-rng\n            inferred-rng\n            (app-err/polyapp-type-error fexpr args fexpr-type arg-ret-types expected)))\n\n        (err/tc-delayed-error (str\n                              \"Cannot invoke type: \" (pr-str (prs/unparse-type fexpr-type)))\n                            :return (or expected (r/ret (c/Un))))))))))", :ns "clojure.core.typed.check.funapp", :name "check-funapp", :file "clojure/core/typed/check/funapp.clj", :column 1, :line 44, :arglists ([fexpr args fexpr-ret-type arg-ret-types expected])}
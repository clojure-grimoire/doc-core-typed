{:type :fn, :src "(defn check-fn-methods [methods expected\n                        & {:keys [recur-target-fn\n                                  validate-expected-fn\n                                  self-name]}]\n  {:pre [(r/Type? expected)\n         ((some-fn nil? symbol?) self-name)]\n   :post [(-> % :fni r/Type?)]}\n  ; FIXME Unions of functions are not supported yet\n  (let [;; FIXME This is trying to be too smart, should be a simple cond with Poly/PolyDots cases\n\n        ; try and unwrap type enough to find function types\n        exp (c/fully-resolve-type expected)\n        ; unwrap polymorphic expected types\n        [fin inst-frees bnds poly?] (cu/unwrap-poly exp)\n        ; once more to make sure (FIXME is this needed?)\n        fin (c/fully-resolve-type fin)\n        ;ensure a function type\n        _ (when-not (r/FnIntersection? fin)\n            (err/int-error\n              (str (pr-str (prs/unparse-type fin)) \" is not a function type\")))\n        _ (when validate-expected-fn\n            (validate-expected-fn fin))\n        ;collect all inferred Functions\n        {:keys [inferred-fni cmethods]}\n                     (lex/with-locals (when-let [name self-name] ;self calls\n                                        (when-not expected \n                                          (err/int-error (str \"Recursive functions require full annotation\")))\n                                        (assert (symbol? name) name)\n                                        {name expected})\n                       ;scope type variables from polymorphic type in body\n                       (free-ops/with-free-mappings (case poly?\n                                                      :Poly (zipmap (map r/F-original-name inst-frees)\n                                                                    (map #(hash-map :F %1 :bnds %2) inst-frees bnds))\n                                                      :PolyDots (zipmap (map r/F-original-name (next inst-frees))\n                                                                        (map #(hash-map :F %1 :bnds %2) (next inst-frees) (next bnds)))\n                                                      {})\n                         (dvar-env/with-dotted-mappings (case poly?\n                                                          :PolyDots {(-> inst-frees last r/F-original-name) (last inst-frees)}\n                                                          {})\n                           (let [method-infos (mapv (fn [method]\n                                                      {:post [(seq %)]}\n                                                      (fn-method/check-fn-method \n                                                        method \n                                                        fin\n                                                        :recur-target-fn recur-target-fn))\n                                                    methods)]\n                             {:cmethods (vec (mapcat #(map :cmethod %) method-infos))\n                              :inferred-fni (apply r/make-FnIntersection (mapcat #(map :ftype %) method-infos))}))))\n        _ (assert (r/Type? inferred-fni))\n        ;rewrap in Poly or PolyDots if needed\n        pfni (cu/rewrap-poly inferred-fni inst-frees bnds poly?)]\n    {:cmethods cmethods\n     :fni pfni}))", :ns "clojure.core.typed.check.fn-methods", :name "check-fn-methods", :file "clojure/core/typed/check/fn_methods.clj", :column 1, :line 21, :arglists ([methods expected & {:keys [recur-target-fn validate-expected-fn self-name]}])}
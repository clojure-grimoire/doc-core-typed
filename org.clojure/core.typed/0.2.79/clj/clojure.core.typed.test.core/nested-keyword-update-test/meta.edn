{:type :fn, :src "(deftest nested-keyword-update-test\n  ; ordinary IPersistentMap does not get updated\n  (is-tc-e (fn []\n             (let [a :- (Map Any Any) {}]\n               (if (number? (-> a :a :b))\n                 a\n                 (assert nil))))\n           [-> (Map Any Any)])\n  ; HMaps can gain \"one level\" of known entries.\n  (is-tc-e (fn []\n             (let [a :- '{} {}]\n               (if (number? (-> a :a :b))\n                 a\n                 (assert nil))))\n           [-> (HMap :optional {:a Any})])\n  ; update a (HMap) with (is clojure.core.typed/Any a [(Key :a) (Key :b)])\n  ; returns a (HMap :optional {:a clojure.core.typed/Any})\n  ; Only one level is updated, we can't say any more about the inner\n  ; :b key.\n  (is-clj  (let [t (parse-clj '(HMap))\n                 path [(-kpe :a) (-kpe :b)]\n                 lo+ (-filter (parse-clj 'Number) 'a path)\n                 lo- (-not-filter (parse-clj 'Number) 'a path)\n                 expected+ (parse-clj `(HMap :optional {:a Any}))\n                 expected- (parse-clj `(HMap :optional {:a Any}))]\n             (and (both-subtype? (update t lo+) expected+)\n                  (both-subtype? (update t lo-) expected+))))\n  ; negative absent keys. The absent entry :a is not a Number (KeyPE does not support defaults), so we\n  ; just return the original type\n  (is-clj (let [t (parse-type `(HMap :absent-keys #{:a}))]\n            (= t\n               (update t (-not-filter (RClass-of Number) 'a [(-kpe :a) (-kpe :b)])))))\n\n  ; When we update a (HMap) that has no information about an :a key, sometimes we can prove\n  ; the updated type always has an :a key.\n  ;\n  ; Here we restrict to a '{:a Number} because the path is a Number, which is never nil. We assume\n  ; nil is the not-found type.\n  (is-clj (let [t (parse-type `(HMap))]\n            (both-subtype? (parse-type `(HMap :mandatory {:a Num}))\n                           (update t (-filter (RClass-of Number) 'a [(-kpe :a)])))))\n\n  ; We restrict (HMap) to (HMap :optional {:a clojure.core.typed/Any}), which is slightly less accurate, because\n  ; we can't prove that the HMap :a entry is never nil. \n  (is-clj (let [t (parse-type '(HMap))]\n            (both-subtype? (parse-type `(HMap :optional {:a Any}))\n                           (update t (-not-filter (RClass-of Number) 'a [(-kpe :a)]))))))", :ns "clojure.core.typed.test.core", :name "nested-keyword-update-test", :file "clojure/core/typed/test/core.clj", :column 1, :line 2535, :test #<core$fn__30450 clojure.core.typed.test.core$fn__30450@1fd6324a>}
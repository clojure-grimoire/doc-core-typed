{:type :fn, :src "(defn check-let [check {:keys [bindings] :as expr} expected & [{is-loop :loop? :keys [expected-bnds]}]]\n  (let [_ (assert (contains? expr (ast-u/let-body-kw))\n                  (keys expr))\n        body ((ast-u/let-body-kw) expr)]\n    (u/p :check/check-let\n     (cond\n       (and is-loop (seq bindings) (not expected-bnds) )\n       (do\n         (err/tc-delayed-error \"Loop requires more annotations\")\n         (assoc expr\n                u/expr-type (r/ret (c/Un))))\n       :else\n       (let [[env cbindings] \n             (reduce \n               (fn [[env cexprs] [{sym :name :keys [init] :as expr} expected-bnd]]\n                 {:pre [(lex/PropEnv? env)\n                        init\n                        sym\n                        ((some-fn nil? r/Type?) expected-bnd)\n                        (identical? (boolean expected-bnd) (boolean is-loop))]\n                  :post [((con/hvector-c? lex/PropEnv? vector?) %)]}\n                 (let [; check rhs\n                       cinit (binding [vs/*current-expr* init]\n                               (var-env/with-lexical-env env\n                                 (check init (when is-loop\n                                               (r/ret expected-bnd)))))\n                       cexpr (assoc expr\n                                    :init cinit\n                                    u/expr-type (u/expr-type cinit))\n                       {:keys [t fl flow o]} (u/expr-type cinit)\n                       _ (when (and expected-bnd\n                                    (not (sub/subtype? t expected-bnd)))\n                           (err/tc-delayed-error \n                             (str \"Loop variable \" sym \" initialised to \"\n                                  (pr-str (prs/unparse-type t))\n                                  \", expected \" (pr-str (prs/unparse-type expected-bnd))\n                                  \"\\n\\nForm:\\n\\t\" (ast-u/emit-form-fn init))))\n                       t (or expected-bnd t)]\n                   (cond\n                     (fl/FilterSet? fl)\n                     (let [{:keys [then else]} fl\n                           p* (cond\n                                (not (c/overlap t (c/Un r/-nil r/-false))) [then]\n                                ;; n is being bound to an expression w/ object o\n                                ;; we don't need any new info, aliasing and the\n                                ;; lexical environment will have the needed info\n                                (obj/Path? o) []\n\n                                ;; n is being bound to an expression w/o an object\n                                ;; so remember n in our propositions\n                                :else [(fo/-or (fo/-and (fo/-not-filter (c/Un r/-nil r/-false) sym)\n                                                        then)\n                                               (fo/-and (fo/-filter (c/Un r/-nil r/-false) sym) \n                                                        else))])\n                           flow-f (r/flow-normal flow)\n                           flow-atom (atom true)\n                           new-env (-> env\n                                       ;update binding type\n                                       (lex/extend-env sym t o)\n                                       ;update props\n                                       (update-in [:props] #(set \n                                                              (apply concat \n                                                                     (update/combine-props p* % (atom true)))))\n                                       (update/env+ [(if (= fl/-bot flow-f) fl/-top flow-f)] flow-atom))\n                           _ (when-not @flow-atom \n                               (binding [vs/*current-expr* init]\n                                 (err/int-error\n                                   (str \"Applying flow filter resulted in local being bottom\"\n                                        \"\\n\"\n                                        (with-out-str (print-env/print-env* new-env))\n                                        \"\\nOld: \"\n                                        (with-out-str (print-env/print-env* env))))))]\n                       [new-env (conj cexprs cexpr)])\n\n                     (fl/NoFilter? fl) (do\n                                         (assert (= (r/-flow fl/-top) flow))\n                                         [(-> env\n                                              ;no propositions to add, just update binding type\n                                              (assoc-in [:l sym] t))\n                                          (conj cexprs cexpr)])\n                     :else (err/int-error (str \"What is this?\" fl)))))\n               [lex/*lexical-env* []] (map vector bindings (or expected-bnds\n                                                               (repeat nil))))\n\n             cbody (var-env/with-lexical-env env\n                     (if is-loop\n                       (binding [recur-u/*recur-target* (recur-u/->RecurTarget expected-bnds nil nil nil)]\n                         (check body expected))\n                       (binding [vs/*current-expr* body]\n                         (check body expected))))\n             ;now we return a result to the enclosing scope, so we\n             ;erase references to any bindings this scope introduces\n             unshadowed-ret\n             (reduce (fn [ty sym]\n                       {:pre [(r/TCResult? ty)\n                              (symbol? sym)]}\n                       (-> ty\n                           (update-in [:t] subst-obj/subst-type sym obj/-empty true)\n                           (update-in [:fl] subst-obj/subst-filter-set sym obj/-empty true)\n                           (update-in [:o] subst-obj/subst-object sym obj/-empty true)\n                           (update-in [:flow :normal] subst-obj/subst-filter sym obj/-empty true)))\n                     (u/expr-type cbody)\n                     (map :name bindings))]\n         (assoc expr\n                (ast-u/let-body-kw) cbody\n                :bindings cbindings\n                u/expr-type unshadowed-ret))))))", :ns "clojure.core.typed.check.let", :name "check-let", :file "clojure/core/typed/check/let.clj", :column 1, :line 21, :arglists ([check {:keys [bindings], :as expr} expected & [{is-loop :loop?, :keys [expected-bnds]}]])}
{:type :fn, :src "(defn check-fn-method [method fin & {:keys [recur-target-fn]}]\n  {:pre [(r/FnIntersection? fin)]\n   :post [(seq %)\n          (every? (comp r/Function? :ftype) %)\n          (every? :cmethod %)]}\n  (u/p :check/check-fn-method\n  (let [required-params (ast-u/method-required-params method)\n        rest-param (ast-u/method-rest-param method)\n        mfns (cu/relevant-Fns required-params rest-param fin)]\n    (cond\n      ;If no matching cases, assign parameters to Any\n      (empty? mfns) [(fn-method1/check-fn-method1 \n                       method \n                       (r/make-Function (repeat (count required-params) r/-any) ;doms\n                                        r/-any  ;rng \n                                        (when rest-param ;rest\n                                          r/-any))\n                       :recur-target-fn recur-target-fn)]\n      :else (vec\n              (for [f mfns]\n                (fn-method1/check-fn-method1 \n                  method \n                  f\n                  :recur-target-fn recur-target-fn)))))))", :ns "clojure.core.typed.check.fn-method", :name "check-fn-method", :file "clojure/core/typed/check/fn_method.clj", :column 1, :line 10, :arglists ([method fin & {:keys [recur-target-fn]}])}
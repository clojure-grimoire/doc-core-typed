{:ns "clojure.core.typed.test.rbt", :name "insert", :file "clojure/core/typed/test/rbt.clj", :type :fn, :src "(defn insert [dict {:keys [key datum] :as entry}]\n  (let [\n        ;;  (*[ ins1 :> 'a rbt -> 'a badRoot \n        ;;            & 'a bt -> 'a rbt  ]*)\n\n\n         ins1 :-\n          (IFn [bt -> rbt]\n               [rbt -> (U rbt badRoot)])\n          (fn ins1 [{:keys [tree] :as tmap}]\n            (cond\n              (#{:Empty} tree) {:tree :Red\n                                :entry entry\n                                :left {:tree :Empty}\n                                :right {:tree :Empty}}\n              (#{:Red} tree) (let [{{key1 :key datum1 :datum :as entry1} \n                                    :entry\n                                    :keys [left right]} tmap]\n                               (cond\n                                 (= key key1) {:tree :Red\n                                               :entry entry\n                                               :left left\n                                               :right right}\n                                 (< key key1) {:tree :Red\n                                               :entry entry1\n                                               :left (ins1 left)\n                                               :right right}\n                                 :else {:tree :Red\n                                        :entry entry1\n                                        :left left\n                                        :right (ins1 right)}))\n              (#{:Black} tree) (let [{{key1 :key datum1 :datum :as e1} :entry\n                                      l :left r :right} tmap]\n                                 (cond\n                                   (= key key1) {:tree :Black\n                                                 :entry entry\n                                                 :left l\n                                                 :right r}\n                                   ; (< key key1) (restore-left {:tree :Black\n                                   ;                             :entry e1\n                                   ;                             :left (ins1 l)\n                                   ;                             :right r})\n                                   :else (restore-right {:tree :Black\n                                                         :entry e1\n                                                         :left l\n                                                         :right (ins1 r)})))\n              :else (assert nil \"Should never happen\")))]\n    (let [{:keys [tree l r] :as res} (ins1 dict)]\n      (cond\n        (and (-> tree #{:Red})\n             (or (-> l :tree #{:Red})\n                 (-> r :tree #{:Red})))\n        (assoc res\n               :tree :Black) ;re-color\n        :else res))))", :column 1, :line 183, :arglists ([dict {:keys [key datum], :as entry}])}
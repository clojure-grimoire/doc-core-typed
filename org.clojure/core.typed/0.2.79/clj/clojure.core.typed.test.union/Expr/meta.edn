{:ns "clojure.core.typed.test.union", :name "Expr", :type :var, :src nil, :doc "An AST node\n\n(t/Rec\n [Expr]\n (t/U\n  '{:op ':keyword, :env Env, :val t/Kw}\n  '{:op ':constant, :env Env, :val t/Any}\n  '{:op ':number, :env Env, :val Number}\n  '{:op ':string, :env Env, :val String}\n  '{:op ':nil, :env Env, :val nil}\n  '{:op ':boolean, :env Env, :val Boolean}\n  (t/HMap\n   :mandatory\n   {:op ':def,\n    :env Env,\n    :var (t/Var2 t/Nothing t/Any),\n    :meta (t/U nil Expr),\n    :init Expr,\n    :init-provided t/Any,\n    :is-dynamic t/Any}\n   :optional\n   {:children Children, :Expr-obj Compiler$DefExpr})\n  (t/HMap\n   :mandatory\n   {:op ':local-binding,\n    :env Env,\n    :sym t/Sym,\n    :tag (t/U nil t/Sym),\n    :init Expr}\n   :optional\n   {:children Children, :LocalBinding-obj Compiler$LocalBinding})\n  (t/HMap\n   :mandatory\n   {:op ':binding-init, :env Env, :local-binding Expr, :init Expr}\n   :optional\n   {:children Children, :BindingInit-obj Compiler$BindingInit})\n  (t/HMap\n   :mandatory\n   {:op ':let,\n    :env Env,\n    :binding-inits (t/Seqable Expr),\n    :body Expr,\n    :is-loop t/Any}\n   :optional\n   {:children Children, :Expr-obj Compiler$LetExpr})\n  (t/HMap\n   :mandatory\n   {:op ':letfn, :env Env, :body Expr, :binding-inits (t/Seqable Expr)}\n   :optional\n   {:children Children, :Expr-obj Compiler$LetFnExpr})\n  (t/HMap\n   :mandatory\n   {:op ':local-binding-expr,\n    :env Env,\n    :local-binding Expr,\n    :tag (t/U nil t/Sym)}\n   :optional\n   {:children Children, :Expr-obj Compiler$LocalBindingExpr})\n  (t/HMap\n   :mandatory\n   {:op ':static-method,\n    :env Env,\n    :class Class,\n    :method-name t/Sym,\n    :method t/Nothing,\n    :args (t/Seqable Expr),\n    :tag (t/U nil t/Sym)}\n   :optional\n   {:children Children, :Expr-obj Compiler$StaticMethodExpr})\n  (t/HMap\n   :mandatory\n   {:op ':instance-method,\n    :env Env,\n    :target Expr,\n    :method-name t/Sym,\n    :method t/Nothing,\n    :args (t/Seqable Expr),\n    :tag (t/U nil t/Sym)}\n   :optional\n   {:children Children, :Expr-obj Compiler$InstanceMethodExpr})\n  (t/HMap\n   :mandatory\n   {:op ':static-field,\n    :env Env,\n    :class Class,\n    :field-name t/Sym,\n    :field t/Nothing,\n    :tag (t/U nil t/Sym)}\n   :optional\n   {:Expr-obj Compiler$StaticFieldExpr})\n  (t/HMap\n   :mandatory\n   {:op ':instance-field,\n    :env Env,\n    :target Expr,\n    :target-class Class,\n    :field t/Nothing,\n    :field-name t/Sym,\n    :tag (t/U nil t/Sym)}\n   :optional\n   {:children Children, :Expr-obj Compiler$InstanceFieldExpr})\n  (t/HMap\n   :mandatory\n   {:op ':new,\n    :env Env,\n    :ctor t/Nothing,\n    :class Class,\n    :args (t/Seqable Expr)}\n   :optional\n   {:children Children, :Expr-obj Compiler$NewExpr})\n  (t/HMap\n   :mandatory\n   {:op ':empty-expr,\n    :env Env,\n    :coll (t/I (t/Seqable t/Nothing) (t/ExactCount 0))}\n   :optional\n   {:Expr-obj Compiler$EmptyExpr})\n  (t/HMap\n   :mandatory\n   {:op ':set, :env Env, :keys (t/Seqable Expr)}\n   :optional\n   {:children Children, :Expr-obj Compiler$SetExpr})\n  (t/HMap\n   :mandatory\n   {:op ':vector, :env Env, :args (t/Seqable Expr)}\n   :optional\n   {:children Children, :Expr-obj Compiler$VectorExpr})\n  (t/HMap\n   :mandatory\n   {:op ':map, :env Env, :keyvals (t/Seqable Expr)}\n   :optional\n   {:children Children, :Expr-obj Compiler$MapExpr})\n  (t/HMap\n   :mandatory\n   {:op ':monitor-enter, :env Env, :target Expr}\n   :optional\n   {:children Children, :Expr-obj Compiler$MonitorEnterExpr})\n  (t/HMap\n   :mandatory\n   {:op ':monitor-exit, :env Env, :target Expr}\n   :optional\n   {:children Children, :Expr-obj Compiler$MonitorExitExpr})\n  (t/HMap\n   :mandatory\n   {:op ':throw, :env Env, :exception Expr}\n   :optional\n   {:children Children, :Expr-obj Compiler$ThrowExpr})\n  (t/HMap\n   :mandatory\n   {:args (t/Seqable Expr),\n    :site-index t/Any,\n    :fexpr Expr,\n    :is-direct t/Any,\n    :op ':invoke,\n    :env Env,\n    :tag (t/U nil t/Sym),\n    :protocol-on t/Any,\n    :is-protocol t/Any}\n   :optional\n   {:method t/Nothing,\n    :children Children,\n    :Expr-obj Compiler$InvokeExpr})\n  (t/HMap\n   :mandatory\n   {:op ':keyword-invoke,\n    :env Env,\n    :kw Expr,\n    :tag (t/U nil t/Sym),\n    :target Expr}\n   :optional\n   {:children Children, :Expr-obj Compiler$KeywordInvokeExpr})\n  (t/HMap\n   :mandatory\n   {:op ':the-var, :env Env, :var Var}\n   :optional\n   {:Expr-obj Compiler$TheVarExpr})\n  (t/HMap\n   :mandatory\n   {:op ':var, :env Env, :var Var, :tag (t/U nil t/Sym)}\n   :optional\n   {:Expr-obj Compiler$VarExpr})\n  (t/HMap\n   :mandatory\n   {:op ':unresolved-var, :env Env, :sym t/Sym}\n   :optional\n   {:Expr-obj Compiler$UnresolvedVarExpr})\n  (t/HMap\n   :mandatory\n   {:op ':obj-expr, :env Env, :tag (t/U nil t/Sym)}\n   :optional\n   {:Expr-obj Compiler$ObjExpr})\n  (t/HMap\n   :mandatory\n   {:op ':new-instance-method,\n    :env Env,\n    :name t/Sym,\n    :required-params (t/Seqable Expr),\n    :body Expr}\n   :optional\n   {:children Children, :ObjMethod-obj Compiler$NewInstanceMethod})\n  (t/HMap\n   :mandatory\n   {:op ':fn-method,\n    :env Env,\n    :body Expr,\n    :required-params (t/Seqable Expr),\n    :rest-param (t/U nil Expr)}\n   :optional\n   {:children Children, :ObjMethod-obj Compiler$FnMethod})\n  (t/HMap\n   :mandatory\n   {:op ':fn-expr,\n    :env Env,\n    :methods (t/Seqable Expr),\n    :variadic-method (t/U nil Expr),\n    :tag (t/U nil t/Sym)}\n   :optional\n   {:name t/Sym, :children Children, :Expr-obj Compiler$FnExpr})\n  (t/HMap\n   :mandatory\n   {:compiled-class Class,\n    :name t/Sym,\n    :mmap t/Any,\n    :fields (t/Set Expr),\n    :this-name t/Sym,\n    :op ':deftype*,\n    :env Env,\n    :methods (t/Seqable Expr),\n    :covariants t/Any,\n    :tag (t/U nil t/Sym),\n    :internal-name t/Sym}\n   :optional\n   {:children Children, :Expr-obj Compiler$NewInstanceExpr})\n  (t/HMap\n   :mandatory\n   {:op ':instance-of, :env Env, :class Class, :the-expr Expr}\n   :optional\n   {:children Children, :Expr-obj Compiler$InstanceOfExpr})\n  (t/HMap\n   :mandatory\n   {:op ':meta, :env Env, :meta Expr, :expr Expr}\n   :optional\n   {:children Children, :Expr-obj Compiler$MetaExpr})\n  (t/HMap\n   :mandatory\n   {:op ':do, :env Env, :exprs (t/Seqable Expr)}\n   :optional\n   {:children Children, :Expr-obj Compiler$BodyExpr})\n  (t/HMap\n   :mandatory\n   {:op ':if, :env Env, :test Expr, :then Expr, :else Expr}\n   :optional\n   {:children Children, :Expr-obj Compiler$IfExpr})\n  (t/HMap\n   :mandatory\n   {:shift t/Any,\n    :mask t/Any,\n    :the-expr Expr,\n    :skip-check t/Any,\n    :tests (t/Seqable Expr),\n    :default Expr,\n    :op ':case*,\n    :env Env,\n    :tests-hashes t/Any,\n    :test-type t/Any,\n    :thens (t/Seqable Expr),\n    :switch-type t/Any}\n   :optional\n   {:children Children, :Expr-obj Compiler$CaseExpr})\n  (t/HMap\n   :mandatory\n   {:op ':import*, :env Env, :class-str String}\n   :optional\n   {:Expr-obj Compiler$ImportExpr})\n  (t/HMap\n   :mandatory\n   {:op ':set!, :env Env, :target Expr, :val Expr}\n   :optional\n   {:children Children, :Expr-obj Compiler$AssignExpr})\n  (t/HMap\n   :mandatory\n   {:op ':catch,\n    :env Env,\n    :class Class,\n    :local-binding Expr,\n    :handler Expr}\n   :optional\n   {:children Children, :CatchClause-obj Compiler$TryExpr$CatchClause})\n  (t/HMap\n   :mandatory\n   {:op ':try,\n    :env Env,\n    :try-expr Expr,\n    :finally-expr (t/U nil Expr),\n    :catch-exprs (t/Seqable Expr),\n    :ret-local t/Any,\n    :finally-local t/Any}\n   :optional\n   {:children Children, :Expr-obj Compiler$TryExpr})\n  (t/HMap\n   :mandatory\n   {:op ':recur,\n    :env Env,\n    :loop-locals (t/Seqable Expr),\n    :args (t/Seqable Expr)}\n   :optional\n   {:children Children, :Expr-Obj Compiler$RecurExpr})\n  (t/HMap\n   :mandatory\n   {:op ':method-param,\n    :env Env,\n    :class Class,\n    :can-emit-primitive t/Any}\n   :optional\n   {:Expr-obj Compiler$MethodParamExpr})))\n"}
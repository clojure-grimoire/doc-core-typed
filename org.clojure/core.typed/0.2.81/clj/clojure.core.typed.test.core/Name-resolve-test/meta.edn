{:type :fn, :src "(deftest Name-resolve-test\n  (is-with-aliases (= (tc-t (fn [tmap :- clojure.core.typed.test.util-aliases/MyName]\n                              ;call to (apply hash-map tmap) should be eliminated\n                              (let [{e :a} tmap]\n                                e)))\n                      (ret (make-FnIntersection \n                             (Function-maker [(Name-maker 'clojure.core.typed.test.util-aliases/MyName)]\n                                         (make-Result (-val 1) \n                                                      (-true-filter)\n                                                      (-path [(-kpe :a)] 0))\n                                         nil nil nil))\n                           (-FS -top -bot) -empty)))\n  (is-with-aliases (= (tc-t (fn [tmap :- clojure.core.typed.test.util-aliases/MapName]\n                                                    (let [{e :a} tmap]\n                                                      (assoc e :c :b))))\n                      (ret (make-FnIntersection (Function-maker [(Name-maker 'clojure.core.typed.test.util-aliases/MapName)]\n                                                            (make-Result (make-HMap :mandatory {(-val :a) (-val 1)\n                                                                                 (-val :c) (-val :b)})\n                                                                         (-FS -top -bot) -empty)\n                                                            nil nil nil))\n                           (-FS -top -bot) -empty)))\n  ; Name representing union of two maps, both with :type key\n  (is-with-aliases (subtype? \n                     (-> (tc-t (fn [tmap :- clojure.core.typed.test.util-aliases/UnionName]\n                                 (:type tmap)))\n                         ret-t)\n                     (parse-type \n                       `[clojure.core.typed.test.util-aliases/UnionName :-> (U (Value :MapStruct2)\n                                                                               (Value :MapStruct1))])))\n  ; using = to derive paths\n  (is-with-aliases (subtype? \n                     (-> (tc-t (fn [tmap :- clojure.core.typed.test.util-aliases/UnionName]\n                                 (= :MapStruct1 (:type tmap))))\n                         ret-t)\n                     (make-FnIntersection \n                       (make-Function \n                         [(Name-maker 'clojure.core.typed.test.util-aliases/UnionName)]\n                         (Un -false -true)\n                         nil nil\n                         :filter (let [t (-val :MapStruct1)\n                                       path [(-kpe :type)]]\n                                   (-FS (-and \n                                          (-filter (make-HMap :mandatory {(-val :type) (-val :MapStruct1)\n                                                           (-val :a) (Name-maker 'clojure.core.typed.test.util-aliases/MyName)})\n                                                   0)\n                                          (-filter (-val :MapStruct1) 0 path)\n                                          (-filter t 0 path))\n                                        (-not-filter t 0 path)))))))\n  ; using filters derived by =\n  (is-with-aliases (subtype? (-> (tc-t (fn [tmap :- clojure.core.typed.test.util-aliases/UnionName]\n                                         (if (= :MapStruct1 (:type tmap))\n                                           (:a tmap)\n                                           (:b tmap))))\n                                 ret-t)\n                             (parse-type \n                               `[clojure.core.typed.test.util-aliases/UnionName :-> clojure.core.typed.test.util-aliases/MyName])))\n  ; following paths with test of conjuncts\n  #_(is-clj (= (tc-t (fn [tmap :- clojure.core.typed.test.util-aliases/UnionName]\n                       ; (and (= :MapStruct1 (-> tmap :type))\n                       ;      (= 1 1))\n                       (if (print-filterset \"final filters\"\n                                            (let [and1 (print-filterset \"first and1\"\n                                                                        (= :MapStruct1 (-> tmap :type)))]\n                                              (print-env \"first conjunct\")\n                                              (print-filterset \"second and1\"\n                                                               (if (print-filterset \"second test\"\n                                                                                    and1)\n                                                                 (do (print-env \"second conjunct\")\n                                                                     (print-filterset \"third and1\"\n                                                                                      (= 1 1)))\n                                                                 (do (print-env \"fail conjunct\")\n                                                                     (print-filterset \"fail and1\"\n                                                                                      and1))))))\n                         (do (print-env \"follow then\")\n                             (assoc tmap :c :d))\n                         1)))\n         (ret (make-FnIntersection (Function-maker [(Name-maker 'clojure.core.typed.test.util-aliases/UnionName)]\n                              (let [t (Un (-val 1)\n                                          (make-HMap :mandatory {(-val :type) (-val :MapStruct1)\n                                                               (-val :c) (-val :d)\n                                                               (-val :a) (Name-maker 'clojure.core.typed.test.util-aliases/MyName)}))]\n                                (make-Result t (-FS -top -bot) -empty))\n                              nil nil nil))\n              (-FS -top -bot) -empty))))", :ns "clojure.core.typed.test.core", :name "Name-resolve-test", :file "clojure/core/typed/test/core.clj", :column 1, :line 639, :test #<core$fn__25566 clojure.core.typed.test.core$fn__25566@67688de1>}
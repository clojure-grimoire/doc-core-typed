{:type :fn, :src "(defn check-invoke-method [check-fn {c :class method-name :method :keys [args env] :as expr} expected inst?\n                           & {:keys [ctarget cargs method-override]}]\n  {:pre [((some-fn nil? r/TCResult?) expected)\n         ((some-fn nil? r/Type?) method-override)\n         (or (not ctarget) inst?)]\n   :post [(-> % u/expr-type r/TCResult?)\n          (vector? (:args %))]}\n  (binding [vs/*current-env* env\n            vs/*current-expr* expr]\n    (let [method (cu/MethodExpr->Method expr)\n          msym (cu/MethodExpr->qualsym expr)\n          rfin-type (or method-override\n                        (when msym\n                          (@mth-override/METHOD-OVERRIDE-ENV msym))\n                        (when method\n                          (cu/Method->Type method)))\n          ctarget (when inst?\n                    (assert (:instance expr))\n                    (or ctarget (check-fn (:instance expr))))\n          cargs (or cargs (mapv check-fn args))]\n      (if-not rfin-type\n        (err/tc-delayed-error (str \"Unresolved \" (if inst? \"instance\" \"static\") \n                                 \" method invocation \" \n                                 (type-hints/suggest-type-hints \n                                   method-name \n                                   (when ctarget\n                                     (-> ctarget u/expr-type r/ret-t))\n                                   (map (comp r/ret-t u/expr-type) cargs))\n                                 \".\\n\\nHint: use *warn-on-reflection* to identify reflective calls\")\n                            :form (ast-u/emit-form-fn expr)\n                            :return (merge\n                                      (assoc expr \n                                             :args cargs\n                                             u/expr-type (cu/error-ret expected))\n                                      (when ctarget {:instance ctarget})))\n        (let [_ (when inst?\n                  (let [target-class (resolve (:declaring-class method))\n                        _ (assert (class? target-class))]\n                    ;                (prn \"check target\" (prs/unparse-type (r/ret-t (u/expr-type ctarget)))\n                    ;                     (prs/unparse-type (c/RClass-of (coerce/Class->symbol (resolve (:declaring-class method))) nil)))\n                    (when-not (sub/subtype? (r/ret-t (u/expr-type ctarget)) (c/RClass-of-with-unknown-params target-class))\n                      (err/tc-delayed-error (str \"Cannot call instance method \" (cu/Method->symbol method)\n                                               \" on type \" (pr-str (prs/unparse-type (r/ret-t (u/expr-type ctarget)))))\n                                          :form (ast-u/emit-form-fn expr)))))\n              result-type (funapp/check-funapp expr args (r/ret rfin-type) (map u/expr-type cargs) expected)\n              _ (when expected\n                  (when-not (sub/subtype? (r/ret-t result-type) (r/ret-t expected))\n                    (err/tc-delayed-error (str \"Return type of \" (if inst? \"instance\" \"static\")\n                                             \" method \" (cu/Method->symbol method)\n                                             \" is \" (prs/unparse-type (r/ret-t result-type))\n                                             \", expected \" (prs/unparse-type (r/ret-t expected)) \".\"\n                                             (when (sub/subtype? r/-nil (r/ret-t result-type))\n                                               (str \"\\n\\nHint: Use `non-nil-return` and `nilable-param` to configure \"\n                                                    \"where `nil` is allowed in a Java method call. `method-type` \"\n                                                    \"prints the current type of a method.\")))\n                                        :form (ast-u/emit-form-fn expr))))]\n          (merge\n            (assoc expr\n                   :args cargs\n                   u/expr-type result-type)\n            (when ctarget {:instance ctarget})))))))", :ns "clojure.core.typed.check.method", :name "check-invoke-method", :file "clojure/core/typed/check/method.clj", :column 1, :line 16, :arglists ([check-fn {c :class, method-name :method, :keys [args env], :as expr} expected inst? & {:keys [ctarget cargs method-override]}])}
{:type :var, :src "(delay-and-cache-env ^:private init-method-override-env\n  (reset-alias-env!)\n  (merge\n    {'clojure.lang.RT/nth (nth-type)}\n    (h/method-override-mappings\n\nclojure.lang.RT/isReduced (Pred (Reduced Any))\n\nclojure.lang.Indexed/nth\n  (All [x y]\n       (IFn [(Indexed x) AnyInteger -> x]\n           [(Indexed x) AnyInteger y -> (U x y)]))\n\n\n;what about combinations of references and primitives?\nclojure.lang.RT/box\n(All [x]\n     (IFn [Character -> Character]\n          [Integer -> Integer]\n          [Short -> Short]\n          [Boolean -> Boolean]\n          [Byte -> Byte]\n          [Long -> Long]\n          [Float -> Float]\n          [Double -> Double]\n          [(U Byte Short Integer Long) -> AnyInteger]\n          [(U Float Double) -> Number]\n          [nil -> nil]\n          [x -> x]))\n\nclojure.lang.RT/booleanCast [Any -> Boolean]\n\nclojure.lang.Numbers/char_array (IFn [(U nil Number (Seqable Character)) -> (Array char)]\n                                    [Number (U Number (Seqable Character)) -> (Array char)])\n\n\nclojure.lang.LockingTransaction/runInTransaction\n                 (All [x]\n                   [[-> x] -> x])\n\n;array ops\nclojure.lang.RT/alength [(ReadOnlyArray Any) -> Integer]\n\nclojure.lang.RT/aget (All [o]\n                        [(ReadOnlyArray o) Integer -> o])\n\nclojure.lang.RT/aset (All [i o]\n                          [(Array2 i o) AnyInteger i -> o])\n\n;get\n;same as clojure.core/get\nclojure.lang.RT/get (All [x y]\n                         (IFn \n                           ;no default\n                           [(IPersistentSet x) Any -> (Option x)]\n                           [nil Any -> nil]\n                           [(Option (ILookup Any x)) Any -> (Option x)]\n                           [java.util.Map Any -> (Option Any)]\n                           [String Any -> (Option Character)]\n                           ;default\n                           [(IPersistentSet x) Any y -> (U y x)]\n                           [nil Any y -> y]\n                           [(Option (ILookup Any x)) Any y -> (U y x)]\n                           [java.util.Map Any y -> (U y Any)]\n                           [String Any y -> (U y Character)]))\n\n;numbers\nclojure.lang.Numbers/add (IFn [Long Long -> Long]\n                              [Double Double -> Double]\n                              [AnyInteger AnyInteger -> AnyInteger]\n                              [Number Number -> Number])\nclojure.lang.Numbers/inc (IFn [Long -> Long]\n                              [Double -> Double]\n                              [AnyInteger -> AnyInteger]\n                              [Number -> Number])\nclojure.lang.Numbers/dec (IFn [Long -> Long]\n                              [Double -> Double]\n                              [AnyInteger -> AnyInteger]\n                              [Number -> Number])\nclojure.lang.Numbers/quotient (IFn [Long Long -> Long]\n                                   [(U Long Double) (U Long Double) -> Double]\n                                   [AnyInteger AnyInteger -> AnyInteger]\n                                   [Number Number -> Number])\nclojure.lang.Numbers/incP (IFn [Long -> (U clojure.lang.BigInt Long)]\n                               [Double -> Double]\n                               [AnyInteger -> AnyInteger]\n                               [Number -> Number])\nclojure.lang.Numbers/decP (IFn [Long -> (U clojure.lang.BigInt Long)]\n                               [Double -> Double]\n                               [AnyInteger -> AnyInteger]\n                               [Number -> Number])\nclojure.lang.Numbers/unchecked_inc (IFn [Long -> Long]\n                                        [Double -> Double]\n                                        [AnyInteger -> AnyInteger]\n                                        [Number -> Number])\nclojure.lang.Numbers/unchecked_dec (IFn [Long -> Long]\n                                        [Double -> Double]\n                                        [AnyInteger -> AnyInteger]\n                                        [Number -> Number])\nclojure.lang.Numbers/unchecked_int_inc [Number -> AnyInteger]\nclojure.lang.Numbers/unchecked_int_dec [Number -> AnyInteger]\nclojure.lang.Numbers/unchecked_int_negate [Number -> AnyInteger]\nclojure.lang.Numbers/unchecked_int_subtract [Number Number -> AnyInteger]\nclojure.lang.Numbers/unchecked_int_add [Number -> AnyInteger]\nclojure.lang.Numbers/unchecked_minus (IFn \n                                       ; negate\n                                       [Long -> Long]\n                                       [Double -> Double]\n                                       [AnyInteger AnyInteger -> AnyInteger]\n                                       [Number Number -> Number]\n                                       ; subtract\n                                       [Long Long -> Long]\n                                       [(U Long Double) (U Long Double) -> Double]\n                                       [AnyInteger -> AnyInteger]\n                                       [Number -> Number])\nclojure.lang.Numbers/minus (IFn\n                             ; negate\n                             [Long -> Long]\n                             [Double -> Double]\n                             [AnyInteger -> AnyInteger]\n                             [Number -> Number]\n                             ;minus\n                             [Long Long -> Long]\n                             [(U Double Long) (U Double Long) -> Long]\n                             [AnyInteger AnyInteger -> AnyInteger]\n                             [Number Number -> Number])\nclojure.lang.Numbers/unchecked_multiply (IFn [Long Long -> Long]\n                                             [(U Long Double) (U Long Double) -> Double]\n                                             [AnyInteger AnyInteger -> AnyInteger]\n                                             [Number Number -> Number])\nclojure.lang.Numbers/unchecked_int_multiply [Number Number -> AnyInteger]\nclojure.lang.Numbers/unchecked_int_divide [Number Number -> AnyInteger]\nclojure.lang.Numbers/unchecked_int_remainder [Number Number -> AnyInteger]\nclojure.lang.Numbers/multiply (IFn [Long Long -> Long]\n                                   [(U Double Long) (U Double Long) -> Double]\n                                   [AnyInteger AnyInteger -> AnyInteger]\n                                   [Number Number -> Number])\nclojure.lang.Numbers/divide (IFn [Long Long -> Long]\n                                   [(U Double Long) (U Double Long) -> Double]\n                                   [AnyInteger AnyInteger -> AnyInteger]\n                                   [Number Number -> Number])\n      ;bit-not\nclojure.lang.Numbers/not [AnyInteger -> Long]\n;bit-and\nclojure.lang.Numbers/and [AnyInteger AnyInteger -> Long]\n;bit-or\nclojure.lang.Numbers/or [AnyInteger AnyInteger -> Long]\n;bit-xor\nclojure.lang.Numbers/xor [AnyInteger AnyInteger -> Long]\n;bit-and-not\nclojure.lang.Numbers/andNot [AnyInteger AnyInteger -> Long]\n; unsigned-bit-shift-right \nclojure.lang.Numbers/unsignedShiftRight [AnyInteger AnyInteger -> Long]\n\nclojure.lang.Numbers/max (IFn \n                           [Long Long -> Long]\n                           [Double Double -> Double]\n                           [Number Number -> Number])\nclojure.lang.Numbers/min (IFn \n                           [Long Long -> Long]\n                           [Double Double -> Double]\n                           [Number Number -> Number])\n\nclojure.lang.Numbers/lt [Number Number -> Boolean]\nclojure.lang.Numbers/lte [Number Number -> Boolean]\nclojure.lang.Numbers/gt [Number Number -> Boolean]\nclojure.lang.Numbers/gte [Number Number -> Boolean]\n\nclojure.lang.Numbers/isZero (Pred (Value 0))\n\nclojure.lang.Util/compare [Any Any -> Number]\n\n; this is overloaded in interesting ways, but this is good enough for destructuring purposes\nclojure.lang.PersistentHashMap/create [(U nil (ISeq Any) java.util.Map (ReadOnlyArray Object)) -> (Map Any Any)]\n    )\n    {'clojure.lang.RT/count (count-type)}))", :ns "clojure.core.typed.base-env", :name "thread-bindings-init-method-override-env", :file "clojure/core/typed/base_env.clj", :column 1, :line 1594}
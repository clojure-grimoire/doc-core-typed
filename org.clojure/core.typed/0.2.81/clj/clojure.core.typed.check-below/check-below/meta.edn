{:type :fn, :src "(defn check-below [tr1 expected]\n  {:pre [((some-fn r/TCResult? r/Type?) tr1)\n         ((some-fn r/TCResult? r/Type?) expected)]\n   :post [(cond\n            (r/TCResult? tr1) (r/TCResult? %)\n            (r/Type? tr1) (r/Type? %))]}\n  (letfn [;; Try and use subtyping, otherwise \n          (filter-better? [{f1+ :then f1- :else :as f1}\n                           {f2+ :then f2- :else :as f2}]\n            {:pre [(fl/FilterSet? f1)\n                   (fl/FilterSet? f2)]\n             :post [(con/boolean? %)]}\n            (cond\n              (= f1 f2) true\n              :else\n              (let [f1-better? (simple-filter-better? f1+ f2+)\n                    f2-better? (simple-filter-better? f1- f2-)] \n                (and f1-better? f2-better?))))\n          (object-better? [o1 o2]\n            {:pre [(obj/RObject? o1)\n                   (obj/RObject? o2)]\n             :post [(con/boolean? %)]}\n            (cond\n              (= o1 o2) true\n              ((some-fn obj/NoObject? obj/EmptyObject?) o2) true\n              :else false))\n          (flow-better? [{flow1 :normal :as f1}\n                         {flow2 :normal :as f2}]\n            {:pre [((every-pred r/FlowSet?) f1 f2)]\n             :post [(con/boolean? %)]}\n            (cond\n              (= flow1 flow2) true\n              (fl/NoFilter? flow2) true\n              (sub/subtype-filter? flow1 flow2) true\n              :else false))\n          (construct-ret [tr1 expected]\n            {:pre [((every-pred r/TCResult?) tr1 expected)]\n             :post [(r/TCResult? %)]}\n            (r/ret (r/ret-t expected)\n                   (let [exp-f (r/ret-f expected)\n                         tr-f (r/ret-f tr1)]\n                     (fo/-FS (if-not (fl/NoFilter? (:then exp-f))\n                               (:then exp-f)\n                               (:then tr-f))\n                             (if-not (fl/NoFilter? (:else exp-f))\n                               (:else exp-f)\n                               (:else tr-f))))\n                   (let [exp-o (r/ret-o expected)\n                         tr-o (r/ret-o tr1)]\n                     (if (obj/NoObject? exp-o)\n                       tr-o\n                       exp-o))\n                   (let [exp-flow (r/ret-flow expected)\n                         tr-flow (r/ret-flow tr1)]\n                     (if (fl/NoFilter? (:normal exp-flow))\n                       tr-flow\n                       exp-flow))))]\n    ;tr1 = arg\n    ;expected = dom\n    (cond\n      (and (r/TCResult? tr1)\n           (r/TCResult? expected))\n      (let [{t1 :t f1 :fl o1 :o flow1 :flow} tr1\n            {t2 :t f2 :fl o2 :o flow2 :flow} expected]\n        (cond\n          (not (sub/subtype? t1 t2)) (cu/expected-error t1 t2)\n\n          :else\n          (let [better-fs? (filter-better? f1 f2)\n                ;_ (prn \"better-fs?\" better-fs? f1 f2)\n                better-obj? (object-better? o1 o2)\n                better-flow? (flow-better? flow1 flow2)\n                ;_ (prn \"better-flow?\" better-flow? flow1 flow2)\n                ]\n            (cond\n              (not better-flow?) (err/tc-delayed-error (str \"Expected result with flow filter \" (pr-str flow2) \n                                                            \", got flow filter \"  (pr-str flow1)))\n              (and (not better-fs?)\n                   better-obj?)\n              (err/tc-delayed-error (str \"Expected result with filter \" (pr-str f2) \", got filter \"  (pr-str f1)))\n\n              (and better-fs? \n                   (not better-obj?))\n              (err/tc-delayed-error (str \"Expected result with object \" (pr-str o2) \", got object \" (pr-str o1)))\n\n              (and (not better-fs?)\n                   (not better-obj?))\n              (err/tc-delayed-error (str \"Expected result with object \" (pr-str o2) \", got object\"  o1 \" and filter \"\n                                         (pr-str f2) \" got filter \" (pr-str f1))))))\n        (construct-ret tr1 expected))\n\n      (and (r/TCResult? tr1)\n           (r/Type? expected))\n      (let [{t1 :t f :fl o :o} tr1\n            t2 expected]\n        (when-not (sub/subtype? t1 t2)\n          (cu/expected-error t1 t2))\n        (r/ret t2 f o))\n\n      ;FIXME\n      ;; erm.. ? What is (FilterSet: (list) (list))\n      ;; TODO this case goes here, but not sure what it means \n      ;\n      ;[((? r/Type? t1) (tc-result1: t2 (FilterSet: (list) (list)) (Empty:)))\n      ; (unless (sub/subtype t1 t2)\n      ;   (tc-error/expr \"Expected ~a, but got ~a\" t2 t1))\n      ; t1]\n\n      (and (r/Type? tr1)\n           (r/TCResult? expected))\n      (let [t1 tr1\n            {t2 :t f :fl o :o} expected]\n        (if (sub/subtype? t1 t2)\n          (err/tc-delayed-error (str \"Expected result with filter \" (pr-str f) \" and object \" (pr-str o) \", got trivial filter and empty object.\"))\n          (cu/expected-error t1 t2))\n        t1)\n\n      (and (r/Type? tr1)\n           (r/Type? expected))\n      (let [t1 tr1\n            t2 expected]\n        (when-not (sub/subtype? t1 t2)\n          (cu/expected-error t1 t2))\n        expected)\n\n      :else (let [a tr1\n                  b expected]\n              (err/int-error (str \"Unexpected input for check-below \" a b))))))", :ns "clojure.core.typed.check-below", :name "check-below", :file "clojure/core/typed/check_below.clj", :column 1, :line 33, :arglists ([tr1 expected])}
{:ns "clojure.core.typed", :name "cf", :file "clojure/core/typed.clj", :type :macro, :src "(defmacro cf\n  \"Takes a form and an optional expected type and\n  returns a human-readable inferred type for that form.\n  Throws an exception if type checking fails.\n\n  Do not use cf inside a typed namespace. cf is intended to be\n  used at the REPL or within a unit test. Note that testing for\n  truthiness is not sufficient to unit test a call to cf, as nil\n  and false are valid type syntax.\n\n  cf preserves annotations from previous calls to check-ns or cf,\n  and keeps any new ones collected during a cf. This is useful for\n  debugging and experimentation. cf may be less strict than check-ns\n  with type checker warnings.\n  \n  eg. (cf 1) \n      ;=> Long\n\n      (cf #(inc %) [Number -> Number])\n      ;=> [Number -> Number]\"\n   ([form] `(check-form* '~form))\n   ([form expected] `(check-form* '~form '~expected)))", :column 1, :line 2160, :macro true, :arglists ([form] [form expected]), :doc "Takes a form and an optional expected type and\n  returns a human-readable inferred type for that form.\n  Throws an exception if type checking fails.\n\n  Do not use cf inside a typed namespace. cf is intended to be\n  used at the REPL or within a unit test. Note that testing for\n  truthiness is not sufficient to unit test a call to cf, as nil\n  and false are valid type syntax.\n\n  cf preserves annotations from previous calls to check-ns or cf,\n  and keeps any new ones collected during a cf. This is useful for\n  debugging and experimentation. cf may be less strict than check-ns\n  with type checker warnings.\n  \n  eg. (cf 1) \n      ;=> Long\n\n      (cf #(inc %) [Number -> Number])\n      ;=> [Number -> Number]"}
{:ns "clojure.core.typed", :name "ann-datatype", :file "clojure/core/typed.clj", :type :macro, :src "(defmacro\n  ^{:forms '[(ann-datatype dname [field :- type*] opts*)\n             (ann-datatype binder dname [field :- type*] opts*)]}\n  ann-datatype\n  \"Annotate datatype Class name dname with expected fields.\n  If unqualified, qualify in the current namespace.\n  Takes an optional type variable binder before the name.\n\n  Fields must be specified in the same order as presented \n  in deftype, with exactly the same field names.\n\n  Also annotates datatype factories and constructors.\n\n  Binder is a vector of specs. Each spec is a vector\n  with the variable name as the first entry, followed by\n  keyword arguments:\n  - :variance (mandatory)\n    The declared variance of the type variable. Possible\n    values are :covariant, :contravariant and :invariant.\n  - :< (optional)\n    The upper type bound of the type variable. Defaults to\n    Any, or the most general type of the same rank as the\n    lower bound.\n  - :> (optional)\n    The lower type bound of the type variable. Defaults to\n    Nothing, or the least general type of the same rank as the\n    upper bound.\n\n  eg. ; a datatype in the current namespace\n      (ann-datatype MyDatatype [a :- Number,\n                                b :- Long])\n\n      ; a datatype in another namespace\n      (ann-datatype another.ns.TheirDatatype\n                    [str :- String,\n                     vec :- (Vec Number)])\n\n      ; a datatype, polymorphic in a\n      (ann-datatype [[a :variance :covariant]]\n                    MyPolyDatatype\n                    [str :- String,\n                     vec :- (Vec Number)\n                     ply :- (Set a)])\"\n  [& args]\n  ;[dname fields & {ancests :unchecked-ancestors rplc :replace :as opts}]\n  (let [bnd-provided? (vector? (first args))\n        vbnd (when bnd-provided?\n               (first args))\n        [dname fields & {ancests :unchecked-ancestors rplc :replace :as opts}]\n        (if bnd-provided?\n          (next args)\n          args)]\n    (assert (not rplc) \"Replace NYI\")\n    (assert (symbol? dname)\n            (str \"Must provide name symbol: \" dname))\n    (let [qname (if (some #{\\.} (str dname))\n                  dname\n                  (symbol (str (namespace-munge *ns*) \".\" dname)))]\n      (swap! impl/datatype-env \n             assoc \n             qname\n             {:record? false\n              :name qname\n              :fields fields\n              :bnd vbnd}))\n    `(ann-datatype* '~vbnd '~dname '~fields '~opts)))", :column 1, :line 1748, :macro true, :arglists ([& args]), :doc "Annotate datatype Class name dname with expected fields.\n  If unqualified, qualify in the current namespace.\n  Takes an optional type variable binder before the name.\n\n  Fields must be specified in the same order as presented \n  in deftype, with exactly the same field names.\n\n  Also annotates datatype factories and constructors.\n\n  Binder is a vector of specs. Each spec is a vector\n  with the variable name as the first entry, followed by\n  keyword arguments:\n  - :variance (mandatory)\n    The declared variance of the type variable. Possible\n    values are :covariant, :contravariant and :invariant.\n  - :< (optional)\n    The upper type bound of the type variable. Defaults to\n    Any, or the most general type of the same rank as the\n    lower bound.\n  - :> (optional)\n    The lower type bound of the type variable. Defaults to\n    Nothing, or the least general type of the same rank as the\n    upper bound.\n\n  eg. ; a datatype in the current namespace\n      (ann-datatype MyDatatype [a :- Number,\n                                b :- Long])\n\n      ; a datatype in another namespace\n      (ann-datatype another.ns.TheirDatatype\n                    [str :- String,\n                     vec :- (Vec Number)])\n\n      ; a datatype, polymorphic in a\n      (ann-datatype [[a :variance :covariant]]\n                    MyPolyDatatype\n                    [str :- String,\n                     vec :- (Vec Number)\n                     ply :- (Set a)])", :forms [(ann-datatype dname [field :- type*] opts*) (ann-datatype binder dname [field :- type*] opts*)]}
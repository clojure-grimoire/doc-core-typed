{:type :fn, :src "(defn\n  print-errors! \n  \"Internal use only\"\n  [errors]\n  {:pre [(seq errors)\n         (every? #(instance? clojure.lang.ExceptionInfo %) errors)]}\n  (binding [*out* *err*]\n    (doseq [^Exception e errors]\n      (let [{{:keys [file line column] :as env} :env :as data} (ex-data e)]\n        (print \"Type Error \")\n        (print (str \"(\" (or file \n                            (let [nsym (-> env :ns)]\n                              (when (symbol? nsym)\n                                nsym))\n                            \"NO_SOURCE_FILE\")\n                    (when line\n                      (str \":\" line\n                           (when column\n                             (str \":\" column))))\n                    \") \"))\n        (print (.getMessage e))\n        (println)\n        (flush)\n        (let [[_ form :as has-form?] (find data :form)]\n          (when has-form?\n            (print \"in: \")\n            (binding [*print-length* (when-not uvs/*verbose-forms*\n                                       6)\n                      *print-level* (when-not uvs/*verbose-forms*\n                                      4)]\n              (println form))\n            (println)\n            (println)\n            (flush)))\n        (flush))))\n  (throw (ex-info (str \"Type Checker: Found \" (count errors) \" error\" (when (< 1 (count errors)) \"s\"))\n                  {:type-error :top-level-error\n                   :errors errors})))", :ns "clojure.core.typed.errors", :name "print-errors!", :file "clojure/core/typed/errors.clj", :column 1, :line 197, :arglists ([errors]), :doc "Internal use only"}
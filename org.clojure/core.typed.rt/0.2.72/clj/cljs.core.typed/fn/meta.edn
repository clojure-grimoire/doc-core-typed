{:ns "cljs.core.typed", :name "fn", :file "clojure/core/typed/macros.clj", :type :macro, :src "(defmacro \n  ^{:forms '[(fn name? [param :- type* & param :- type * ?] :- type? exprs*)\n             (fn name? ([param :- type* & param :- type * ?] :- type? exprs*)+)]}\n  fn\n  \"Like clojure.core/fn, but with optional annotations.\n\n  eg. ;these forms are equivalent\n      (fn [a] b)\n      (fn [a :- Any] b)\n      (fn [a :- Any] :- Any b)\n      (fn [a] :- Any b)\n\n      ;annotate return\n      (fn [a :- String] :- String body)\n\n      ;named fn\n      (fn fname [a :- String] :- String body)\n\n      ;rest parameter\n      (fn [a :- String & b :- Number *] body)\n\n      ;dotted rest parameter\n      (fn [a :- String & b :- Number ... x] body)\n\n      ;multi-arity\n      (fn fname \n        ([a :- String] :- String ...)\n        ([a :- String, b :- Number] :- String ...))\"\n  [& forms]\n  (core/let [{:keys [fn ann]} (internal/parse-fn* false forms)]\n    (if vs/*checking*\n      `(do ~spec/special-form\n           ~(core-kw :fn)\n           {:ann '~ann}\n           ~fn)\n      fn)))", :column 1, :line 56, :macro true, :arglists ([& forms]), :doc "Like clojure.core/fn, but with optional annotations.\n\n  eg. ;these forms are equivalent\n      (fn [a] b)\n      (fn [a :- Any] b)\n      (fn [a :- Any] :- Any b)\n      (fn [a] :- Any b)\n\n      ;annotate return\n      (fn [a :- String] :- String body)\n\n      ;named fn\n      (fn fname [a :- String] :- String body)\n\n      ;rest parameter\n      (fn [a :- String & b :- Number *] body)\n\n      ;dotted rest parameter\n      (fn [a :- String & b :- Number ... x] body)\n\n      ;multi-arity\n      (fn fname \n        ([a :- String] :- String ...)\n        ([a :- String, b :- Number] :- String ...))", :forms [(fn name? [param :- type* & param :- type * ?] :- type? exprs*) (fn name? ([param :- type* & param :- type * ?] :- type? exprs*) +)]}
{:type :fn, :src "(defn parse-fn*\n  \"(fn name? [[param :- type]* & [param :- type *]?] :- type? exprs*)\n  (fn name? ([[param :- type]* & [param :- type *]?] :- type? exprs*)+)\"\n  [is-poly forms]\n  (let [name (when (symbol? (first forms))\n               (first forms))\n        forms (if name (rest forms) forms)\n        poly (when is-poly\n               (first forms))\n        forms (if poly (rest forms) forms)\n        methods (if ((some-fn vector? keyword?) (first forms))\n                  (list forms)\n                  forms)\n        parsed-methods (doall \n                         (for [method methods]\n                           (merge-with merge\n                             (loop [ann-params (first method)\n                                    pvec (empty (first method)) ; an empty param vector with same metadata\n                                    ann-info []]\n                               (cond\n                                 (empty? ann-params)\n                                 (let [[dom [amp rst]] (split-with (complement #{'&}) ann-info)]\n                                   {:pvec pvec\n                                    :ann (merge\n                                           {:dom dom}\n                                           (when (:rest rst)\n                                             {:rest (:rest rst)})\n                                           (when (:drest rst)\n                                             {:drest (:drest rst)}))})\n\n                                 ;rest param\n                                 (#{'&} (first ann-params))\n                                 (let [[amp & ann-params] ann-params]\n                                   (if (#{:-} (second ann-params))\n                                     (let [[p colon & rst-params] ann-params]\n                                       (cond\n                                         (#{'*} (second rst-params))\n                                         (let [[t star & after-rst] rst-params]\n                                           (recur after-rst\n                                                  (conj pvec amp p)\n                                                  (conj ann-info amp {:rest {:type t}})))\n\n                                         (#{'...} (second rst-params))\n                                         (let [[pretype dots bound & after-rst] rst-params]\n                                           (recur after-rst\n                                                  (conj pvec amp p)\n                                                  (conj ann-info amp {:drest {:pretype {:type pretype}\n                                                                              :bound bound}})))\n\n                                         :else\n                                         (throw (ex-info \"Rest annotation must be followed with * or ...\" {:form method}))))\n                                     (let [[p & after-rst] ann-params]\n                                       (recur after-rst\n                                              (conj pvec amp p)\n                                              (conj ann-info amp {:rest {:type 'clojure.core.typed/Any\n                                                                         :default true}})))))\n\n                                 ;fixed param\n                                 :else\n                                 (if (#{:-} (second ann-params))\n                                   (let [[p colon t & rest-params] ann-params]\n                                     (recur rest-params\n                                            (conj pvec p)\n                                            (conj ann-info {:type t})))\n                                   (let [[p & rest-params] ann-params]\n                                     (recur rest-params\n                                            (conj pvec p)\n                                            (conj ann-info {:type 'clojure.core.typed/Any\n                                                            :default true}))))))\n                             (if (#{:-} (second method))\n                               (let [[param colon t & body] method]\n                                 {:body body\n                                  :ann {:ret-type {:type t}}})\n                               (let [[param & body] method]\n                                 {:body body\n                                  :ann {:ret-type {:type 'clojure.core.typed/Any\n                                                   :default true}}})))))]\n    {:fn `(fn ~@(concat\n                  (when name\n                    [name])\n                  (for [{:keys [body pvec]} parsed-methods]\n                    (apply list pvec body))))\n     :ann (map :ann parsed-methods)}))", :ns "clojure.core.typed.internal", :name "parse-fn*", :file "clojure/core/typed/internal.clj", :column 1, :line 6, :arglists ([is-poly forms]), :doc "(fn name? [[param :- type]* & [param :- type *]?] :- type? exprs*)\n  (fn name? ([[param :- type]* & [param :- type *]?] :- type? exprs*)+)"}
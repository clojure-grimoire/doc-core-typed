{:type :fn, :src "(defn parse-fn>\n  \"(fn> name? poly? :- type? [[param :- type]* & [param :- type *]?] exprs*)\n   (fn> name? poly? (:- type? [[param :- type]* & [param :- type *]?] exprs*)+)\"\n  [is-poly forms]\n  (let [name (when (symbol? (first forms))\n               (first forms))\n        forms (if name (rest forms) forms)\n        poly (when is-poly\n               (first forms))\n        forms (if poly (rest forms) forms)\n        methods (if ((some-fn vector? keyword?) (first forms))\n                  (list forms)\n                  forms)\n        ; turn [param :- type* & param :- type *?]\n        ; into [[param :- type]* & [param :- type *]?]\n        normalise-args\n        (fn [arg-anns]\n          (loop [flat-result ()\n                 seq-exprs arg-anns]\n            (cond\n              (empty? seq-exprs) flat-result\n              (and (#{'&} (first seq-exprs))\n                   ; new syntax\n                   (#{:-} (nth seq-exprs 2)))\n              (do\n                (assert (#{'*} (nth seq-exprs 4)))\n                (assert (#{:-} (nth seq-exprs 2)))\n                (assert (empty? (drop 5 seq-exprs)))\n                (recur (concat flat-result ['& (vec (take 4 (next seq-exprs)))])\n                       (drop 4 seq-exprs)))\n\n              :else (do (assert (#{:-} (second seq-exprs))\n                                \"Incorrect syntax in fn>.\")\n                        (recur (concat flat-result [(vec (take 3 seq-exprs))])\n                               (drop 3 seq-exprs))))))\n        ;(fn> name? (:- type? [[param :- type]* & [param :- type *]?] exprs*)+)\"\n        ; (HMap {:dom (Seqable TypeSyntax)\n        ;        :rng (U nil TypeSyntax)\n        ;        :body Any})\n        parsed-methods (doall \n                         (for [method methods]\n                           (let [[ret has-ret?] (when (not (vector? (first method)))\n                                                  (assert (= :- (first method))\n                                                          \"Return type for fn> must be prefixed by :-\")\n                                                  [(second method) true])\n                                 method (if ret \n                                          (nnext method)\n                                          method)\n                                 body (rest method)\n                                 arg-anns (normalise-args (first method))\n                                 [required-params _ [rest-param]] (split-with #(not= '& %) arg-anns)]\n                             (assert (sequential? required-params)\n                                     \"Must provide a sequence of typed parameters to fn>\")\n                             (assert (not rest-param) \"fn> doesn't support rest parameters yet\")\n                             {:dom-syntax (doall (map (comp second next) required-params))\n                              :dom-lhs (doall (map first required-params))\n                              :rng-syntax ret\n                              :has-rng? has-ret?\n                              :body body})))]\n    {:poly poly\n     :fn `(fn ~@(concat\n                  (when name\n                    [name])\n                  (for [{:keys [body dom-lhs]} parsed-methods]\n                    (apply list (vec dom-lhs) body))))\n     :parsed-methods parsed-methods}))", :ns "clojure.core.typed.internal", :name "parse-fn>", :file "clojure/core/typed/internal.clj", :column 1, :line 99, :arglists ([is-poly forms]), :doc "(fn> name? poly? :- type? [[param :- type]* & [param :- type *]?] exprs*)\n   (fn> name? poly? (:- type? [[param :- type]* & [param :- type *]?] exprs*)+)"}
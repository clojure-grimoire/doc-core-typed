{:type :fn, :src "(defn parse-defprotocol*\n  [forms]\n  (let [[binder forms] (take-when vector? forms)\n        [pname & typed-decl-methods] forms\n        [pdoc typed-decl-methods] (take-when string? typed-decl-methods)\n        parse-pvec (fn [pvec] ; parse parameter vectors\n                     {:pre [(vector? pvec)]\n                      :post [((hmap-c? :actual vector?\n                                       :ptypes vector?)\n                              %)]}\n                     (assert (not (#{:-} (second pvec)))\n                             \"Annotating the first argument of a method is disallowed\")\n                     (loop [pvec pvec\n                            actual (empty pvec) ; empty vector with same metadata as pvec\n                            ptypes []]\n                       (assert (every? vector? [actual ptypes]))\n                       (cond\n                         (empty? pvec) {:ptypes ptypes :actual actual}\n                         :else (if (#{:-} (second pvec))\n                                 (let [_ (assert (#{3} (count (take 3 pvec)))\n                                                 \"Missing type annotation after :-\")\n                                       [b colon t & rst] pvec]\n                                   (recur rst \n                                          (conj actual b)\n                                          (conj ptypes {:type t})))\n                                 (let [_ (assert (seq pvec))\n                                       [b & rst] pvec]\n                                   (recur rst \n                                          (conj actual b)\n                                          (conj ptypes {:type 'clojure.core.typed/Any\n                                                        :default true})))))))\n        actual-decl-methods (for [m typed-decl-methods]\n                              (let [[poly rst] (take-when vector? m)\n                                    [name & dvecs] rst]\n                                (assert (symbol? name) (str \"defprotocol method name must be a symbol: \" pname))\n                                (loop [dvecs dvecs\n                                       arities []]\n                                  (cond \n                                    (or (empty? dvecs)\n                                        (string? (first dvecs)))\n                                    (merge {:poly poly\n                                            :name name\n                                            :arities arities}\n                                           (when (string? (first dvecs))\n                                             {:doc (first dvecs)}))\n\n                                    :else (if (#{:-} (second dvecs))\n                                            (let [_ (assert (#{3} (count (take 3 dvecs)))\n                                                            \"Missing type annotation after :-\")\n                                                  [v colon t & rst] dvecs\n                                                  {:keys [ptypes actual]} (parse-pvec v)]\n                                              (recur rst\n                                                     (conj arities {:ret {:type t}\n                                                                    :ptypes ptypes\n                                                                    :actual actual})))\n                                            (let [_ (assert (seq dvecs))\n                                                  [v & rst] dvecs\n                                                  {:keys [ptypes actual]} (parse-pvec v)]\n                                              (recur rst\n                                                     (conj arities {:ret {:type 'clojure.core.typed/Any\n                                                                          :default true}\n                                                                    :ptypes ptypes\n                                                                    :actual actual}))))))))\n        ann {:binder binder\n             :name pname\n             :methods (map #(dissoc % :doc) actual-decl-methods)}]\n    {:defprotocol `(clojure.core/defprotocol \n                     ~pname \n                     ~@(when pdoc [pdoc])\n                     ~@(map (fn [{:keys [name arities doc]}] \n                              `(~name ~@(concat ; prefer left-most arities if grouped duplicates\n                                                (reduce\n                                                  (fn [ret current]\n                                                    (if (= (count current) (count (last ret)))\n                                                      ret\n                                                      (conj ret current)))\n                                                  []\n                                                  (map :actual arities))\n                                                (when doc\n                                                  [doc]))))\n                            actual-decl-methods))\n     :ann-protocol (gen-ann-protocol ann)}))", :ns "clojure.core.typed.internal", :name "parse-defprotocol*", :file "clojure/core/typed/internal.clj", :column 1, :line 240, :arglists ([forms])}
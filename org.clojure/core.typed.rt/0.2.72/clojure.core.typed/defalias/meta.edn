{:ns "clojure.core.typed", :name "defalias", :file "clojure/core/typed.clj", :type :macro, :src "(defmacro defalias \n  \"Define a type alias. Takes an optional doc-string as a second\n  argument.\n\n  Updates the corresponding var with documentation.\n  \n  eg. (defalias MyAlias\n        \\\"Here is my alias\\\"\n        (U nil String))\"\n  ([sym doc-str t]\n   (assert (string? doc-str) \"Doc-string passed to defalias must be a string\")\n   `(defalias ~(vary-meta sym assoc :doc doc-str) ~t))\n  ([sym t]\n   (assert (symbol? sym) (str \"First argument to defalias must be a symbol: \" sym))\n   (let [qsym (if (namespace sym)\n                sym\n                (symbol (-> *ns* ns-name str) (str sym)))\n         m (-> (meta sym)\n             (update-in [:doc] #(str #_\"Type Alias\\n\\n\" % \"\\n\\n\" (with-out-str (pprint/pprint t)))))]\n     `(do\n        (tc-ignore (add-to-alias-env '~&form '~qsym '~t))\n        (let [v# (intern '~(symbol (namespace qsym)) '~(symbol (name qsym)))]\n          (tc-ignore (alter-meta! v# merge '~m)))\n        (def-alias* '~qsym '~t)))))", :column 1, :line 1268, :macro true, :arglists ([sym doc-str t] [sym t]), :doc "Define a type alias. Takes an optional doc-string as a second\n  argument.\n\n  Updates the corresponding var with documentation.\n  \n  eg. (defalias MyAlias\n        \"Here is my alias\"\n        (U nil String))"}
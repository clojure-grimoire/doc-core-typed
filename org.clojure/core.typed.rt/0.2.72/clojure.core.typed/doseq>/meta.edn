{:ns "clojure.core.typed", :name "doseq>", :file "clojure/core/typed.clj", :type :macro, :src "(defmacro ^{:deprecated \"0.2.45\"} doseq>\n  \"DEPRECATED: use clojure.core.typed/doseq\n\n  Like doseq but requires annotation for each loop variable: \n  [a [1 2]] becomes [a :- Long [1 2]]\n  \n  eg.\n  (doseq> [a :- (U nil AnyInteger) [1 nil 2 3]\n           :when a]\n     (inc a))\"\n  [seq-exprs & body]\n  (err/deprecated-renamed-macro\n    &form\n    'doseq>\n    'doseq)\n  (@#'core/assert-args\n     (vector? seq-exprs) \"a vector for its binding\"\n     (even? (count seq-exprs)) \"an even number of forms in binding vector\")\n  (let [normalise-args\n        ; change [a :- b c] to [[a :- b] c]\n        (fn [seq-exprs]\n          (loop [flat-result ()\n                 seq-exprs seq-exprs]\n            (cond\n              (empty? seq-exprs) flat-result\n              (keyword? (first seq-exprs)) (recur (concat flat-result (take 2 seq-exprs))\n                                                  (drop 2 seq-exprs))\n              (and (vector? (first seq-exprs))\n                   (#{:-} (-> seq-exprs first second))) (do\n                                                          (err/deprecated-macro-syntax\n                                                            &form\n                                                            \"doseq> binder syntax [[b :- t] i] has changed, use [b :- t i]\")\n                                                          (recur (concat flat-result (take 2 seq-exprs))\n                                                                 (drop 2 seq-exprs)))\n              :else (do (assert (#{:-} (second seq-exprs))\n                                \"Incorrect syntax in doseq>\")\n                        (recur (concat flat-result [(vec (take 3 seq-exprs))\n                                                    (nth seq-exprs 3)])\n                               (drop 4 seq-exprs))))))\n\n        ; normalise seq-exprs to be flat pairs\n        seq-exprs (normalise-args seq-exprs)\n        step (fn step [recform exprs]\n               (if-not exprs\n                 [true `(do ~@body)]\n                 (let [k (first exprs)\n                       v (second exprs)]\n                   (if (keyword? k)\n                     (let [steppair (step recform (nnext exprs))\n                           needrec (steppair 0)\n                           subform (steppair 1)]\n                       (cond\n                         (= k :let) [needrec `(core/let ~v ~subform)]\n                         (= k :while) [false `(when ~v\n                                                ~subform\n                                                ~@(when needrec [recform]))]\n                         (= k :when) [false `(if ~v\n                                               (do\n                                                 ~subform\n                                                 ~@(when needrec [recform]))\n                                               ~recform)]))\n                     ;; k is [k :- k-ann]\n                     (let [_ (assert (and (vector? k)\n                                          (#{3} (count k))\n                                          (#{:-} (second k))) \n                                     \"Binder must be of the form [lhs :- type]\")\n                           k-ann (nth k 2)\n                           k (nth k 0)\n                           ; k is the lhs binding\n                           seq- (gensym \"seq_\")\n                           chunk- (with-meta (gensym \"chunk_\")\n                                             {:tag 'clojure.lang.IChunk})\n                           count- (gensym \"count_\")\n                           i- (gensym \"i_\")\n                           recform `(recur (next ~seq-) nil 0 0)\n                           steppair (step recform (nnext exprs))\n                           needrec (steppair 0)\n                           subform (steppair 1)\n                           recform-chunk \n                             `(recur ~seq- ~chunk- ~count- (unchecked-inc ~i-))\n                           steppair-chunk (step recform-chunk (nnext exprs))\n                           subform-chunk (steppair-chunk 1)]\n                       [true\n                        `(loop> [~seq- :- (U nil (Seq ~k-ann)) (seq ~v), \n                                 ~chunk- :- (U nil (clojure.lang.IChunk ~k-ann)) nil\n                                 ~count- :- (U Integer Long) 0,\n                                 ~i- :- (U Integer Long) 0]\n                           (if (and (< ~i- ~count-)\n                                    ;; FIXME review this\n                                    ;; core.typed thinks chunk- could be nil here\n                                    ~chunk-)\n                             (core/let [;~k (.nth ~chunk- ~i-)\n                                        ~k (nth ~chunk- ~i-)]\n                               ~subform-chunk\n                               ~@(when needrec [recform-chunk]))\n                             (when-let [~seq- (seq ~seq-)]\n                               (if (chunked-seq? ~seq-)\n                                 (core/let [c# (chunk-first ~seq-)]\n                                   (recur (chunk-rest ~seq-) c#\n                                          (int (count c#)) (int 0)))\n                                 (core/let [~k (first ~seq-)]\n                                   ~subform\n                                   ~@(when needrec [recform]))))))])))))]\n    (nth (step nil (seq seq-exprs)) 1)))", :column 1, :line 466, :macro true, :deprecated "0.2.45", :arglists ([seq-exprs & body]), :doc "DEPRECATED: use clojure.core.typed/doseq\n\n  Like doseq but requires annotation for each loop variable: \n  [a [1 2]] becomes [a :- Long [1 2]]\n  \n  eg.\n  (doseq> [a :- (U nil AnyInteger) [1 nil 2 3]\n           :when a]\n     (inc a))"}
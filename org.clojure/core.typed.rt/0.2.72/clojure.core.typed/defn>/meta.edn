{:ns "clojure.core.typed", :name "defn>", :file "clojure/core/typed.clj", :type :macro, :src "(defmacro\n  ^{:deprecated \"0.2.57\"}\n  ^{:forms '[(defn> name docstring? :- type [param :- type *] exprs*)\n             (defn> name docstring? (:- type [param :- type *] exprs*)+)]}\n  defn>\n  \"DEPRECATED: Use defn\n  \n  Like defn, but with annotations. Annotations are mandatory for\n  parameters and for return type.\n\n  eg. (defn> fname :- Integer [a :- Number, b :- (U Symbol nil)] ...)\n\n  ;annotate return\n  (defn> fname :- String [a :- String] ...)\n\n  ;multi-arity\n  (defn> fname \n    (:- String [a :- String] ...)\n    (:- Long   [a :- String, b :- Number] ...))\"\n  [name & fdecl]\n  (err/deprecated-renamed-macro\n    &form\n    'defn>\n    'defn)\n  (let [[docstring fdecl] (internal/take-when string? fdecl)\n        signature (defn>-parse-typesig fdecl)]\n    `(do (ann ~name ~signature)\n         ~(list* 'def name \n                 (concat\n                   (when docstring [docstring])\n                   [`(fn> ~name ~@fdecl)])))))", :column 1, :line 730, :macro true, :deprecated "0.2.57", :arglists ([name & fdecl]), :doc "DEPRECATED: Use defn\n  \n  Like defn, but with annotations. Annotations are mandatory for\n  parameters and for return type.\n\n  eg. (defn> fname :- Integer [a :- Number, b :- (U Symbol nil)] ...)\n\n  ;annotate return\n  (defn> fname :- String [a :- String] ...)\n\n  ;multi-arity\n  (defn> fname \n    (:- String [a :- String] ...)\n    (:- Long   [a :- String, b :- Number] ...))", :forms [(defn> name docstring? :- type [param :- type *] exprs*) (defn> name docstring? (:- type [param :- type *] exprs*) +)]}
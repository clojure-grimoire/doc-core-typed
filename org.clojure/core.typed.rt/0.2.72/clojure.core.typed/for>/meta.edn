{:ns "clojure.core.typed", :name "for>", :file "clojure/core/typed.clj", :type :macro, :src "(defmacro ^{:deprecated \"0.2.45\"} for>\n  \"DEPRECATED: use clojure.core.typed/for\n\n  Like for but requires annotation for each loop variable: [a [1 2]] becomes [a :- Long [1 2]]\n  Also requires annotation for return type.\n  \n  eg. (for> :- Number\n        [a :- (U nil AnyInteger) [1 nil 2 3]\n         :when a]\n        (inc a))\"\n  [tk ret-ann seq-exprs body-expr]\n  (err/deprecated-macro-syntax\n    &form\n    (str \"clojure.core.typed/for> renamed to clojure.core.typed/for.\"\n         \" Note the return type annotation has changed to after the binder: (for [a :- t, i] :- r, i)\"))\n  (@#'core/assert-args\n     (vector? seq-exprs) \"a vector for its binding\"\n     (even? (count seq-exprs)) \"an even number of forms in binding vector\")\n  (assert (#{:-} tk) \"Must provide return type annotation for for>.\")\n  (let [normalise-args\n        ; change [a :- b c] to [[a :- b] c]\n        (fn [seq-exprs]\n          (loop [flat-result ()\n                 seq-exprs seq-exprs]\n            (cond\n              (empty? seq-exprs) flat-result\n              (keyword? (first seq-exprs)) (recur (concat flat-result (take 2 seq-exprs))\n                                                  (drop 2 seq-exprs))\n              (and (vector? (first seq-exprs))\n                   (#{:-} (-> seq-exprs first second))) (do\n                                                          (err/deprecated-macro-syntax \n                                                            &form\n                                                            \"for> syntax has changed, use [b :- t i] for clauses\")\n                                                          (recur (concat flat-result (take 2 seq-exprs))\n                                                                 (drop 2 seq-exprs)))\n              :else (do (assert (#{:-} (second seq-exprs))\n                                \"Incorrect syntax in for>.\")\n                        (recur (concat flat-result [(vec (take 3 seq-exprs))\n                                                    (nth seq-exprs 3)])\n                               (drop 4 seq-exprs))))))\n\n        ; normalise seq-exprs to be flat pairs\n        seq-exprs (normalise-args seq-exprs)\n\n        to-groups (fn [seq-exprs]\n                    (@#'core/reduce1 (fn [groups [k v]]\n                                               (if (keyword? k)\n                                                 (conj (pop groups) (conj (peek groups) [k v]))\n                                                 (conj groups [k v])))\n                                             [] (partition 2 seq-exprs)))\n        err (fn [& msg] (throw (IllegalArgumentException. ^String (apply str msg))))\n        emit-bind (fn emit-bind [[[bind expr & mod-pairs]\n                                  & [[_ next-expr] :as next-groups]]]\n                    (let [_ (assert (and (vector? bind)\n                                         (#{3} (count bind))\n                                         (#{:-} (second bind))) \n                                    \"Binder must be of the form [lhs :- type]\")\n                          bind-ann (nth bind 2)\n                          bind (nth bind 0)\n                          giter (gensym \"iter__\")\n                          gxs (gensym \"s__\")\n                          do-mod (fn do-mod [[[k v :as pair] & etc]]\n                                   (cond\n                                     (= k :let) `(core/let ~v ~(do-mod etc))\n                                     (= k :while) `(when ~v ~(do-mod etc))\n                                     (= k :when) `(if ~v\n                                                    ~(do-mod etc)\n                                                    (recur (rest ~gxs)))\n                                     (keyword? k) (err \"Invalid 'for' keyword \" k)\n                                     next-groups\n                                      `(core/let [iterys# ~(emit-bind next-groups)\n                                                  fs# (seq (iterys# ~next-expr))]\n                                         (if fs#\n                                           (concat fs# (~giter (rest ~gxs)))\n                                           (recur (rest ~gxs))))\n                                     :else `(cons ~body-expr\n                                                  (~giter (rest ~gxs)))))]\n                      (if next-groups\n                        #_\"not the inner-most loop\"\n                        `(ann-form\n                           (fn ~giter [~gxs]\n                             (lazy-seq\n                               (loop> [~gxs :- (Option (Seqable ~bind-ann)) ~gxs]\n                                 (when-first [~bind ~gxs]\n                                   ~(do-mod mod-pairs)))))\n                           [(~'clojure.core.typed/Option (~'clojure.lang.Seqable ~bind-ann)) ~'-> (~'clojure.core.typed/Seq ~ret-ann)])\n                        #_\"inner-most loop\"\n                        (let [gi (gensym \"i__\")\n                              gb (gensym \"b__\")\n                              do-cmod (fn do-cmod [[[k v :as pair] & etc]]\n                                        (cond\n                                          (= k :let) `(core/let ~v ~(do-cmod etc))\n                                          (= k :while) `(when ~v ~(do-cmod etc))\n                                          (= k :when) `(if ~v\n                                                         ~(do-cmod etc)\n                                                         (recur\n                                                           (unchecked-inc ~gi)))\n                                          (keyword? k)\n                                            (err \"Invalid 'for' keyword \" k)\n                                          :else\n                                            `(do (chunk-append ~gb \n                                                               ; put an ann-form here so at least one error message\n                                                               ; points to code the user can recognise.\n                                                               (ann-form ~body-expr\n                                                                         ~ret-ann))\n                                                 (recur (unchecked-inc ~gi)))))]\n                          `(ann-form\n                             (fn ~giter [~gxs]\n                               (lazy-seq\n                                 (loop> [~gxs :- (Option (Seqable ~bind-ann)) ~gxs]\n                                        (when-let [~gxs (seq ~gxs)]\n                                          (if (chunked-seq? ~gxs)\n                                            (core/let [c# (chunk-first ~gxs)\n                                                       size# (int (count c#))\n                                                       ~gb (ann-form (chunk-buffer size#)\n                                                                     (~'clojure.lang.ChunkBuffer ~ret-ann))]\n                                              (if (loop> [~gi :- AnyInteger, (int 0)]\n                                                         (if (< ~gi size#)\n                                                           (core/let [;~bind (.nth c# ~gi)]\n                                                                      ~bind (nth c# ~gi)]\n                                                             ~(do-cmod mod-pairs))\n                                                           true))\n                                                (chunk-cons\n                                                  (chunk ~gb)\n                                                  (~giter (chunk-rest ~gxs)))\n                                                (chunk-cons (chunk ~gb) nil)))\n                                            (core/let [~bind (first ~gxs)]\n                                              ~(do-mod mod-pairs)))))))\n                             [(~'clojure.core.typed/Option (~'clojure.lang.Seqable ~bind-ann)) ~'->\n                              (~'clojure.core.typed/Seq ~ret-ann)])))))]\n    `(core/let [iter# ~(emit-bind (to-groups seq-exprs))]\n        (iter# ~(second seq-exprs)))))", :column 1, :line 192, :macro true, :deprecated "0.2.45", :arglists ([tk ret-ann seq-exprs body-expr]), :doc "DEPRECATED: use clojure.core.typed/for\n\n  Like for but requires annotation for each loop variable: [a [1 2]] becomes [a :- Long [1 2]]\n  Also requires annotation for return type.\n  \n  eg. (for> :- Number\n        [a :- (U nil AnyInteger) [1 nil 2 3]\n         :when a]\n        (inc a))"}
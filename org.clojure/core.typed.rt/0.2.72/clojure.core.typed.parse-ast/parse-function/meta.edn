{:type :fn, :src "(defn parse-function [f]\n  (let [is-arrow '#{-> :->}\n        all-dom (take-while (complement is-arrow) f)\n        [the-arrow rng & opts-flat :as chk] (drop-while (complement is-arrow) f) ;opts aren't used yet\n        _ (when ('#{->} the-arrow)\n            ;TODO deprecate\n            )\n        _ (when-not (<= 2 (count chk)) \n            (err/int-error (str \"Incorrect function syntax: \" f)))\n\n        _ (when-not (even? (count opts-flat)) \n            (err/int-error (str \"Incorrect function syntax, must have even number of keyword parameters: \" f)))\n\n        opts (apply hash-map opts-flat)\n\n        {ellipsis-pos '...\n         asterix-pos '*\n         ampersand-pos '&}\n        (zipmap all-dom (range))\n\n        _ (when-not (#{0 1} (count (filter identity [asterix-pos ellipsis-pos ampersand-pos])))\n            (err/int-error \"Can only provide one rest argument option: & ... or *\"))\n\n        _ (when-let [ks (seq (remove #{:filters :object :flow} (keys opts)))]\n            (err/int-error (str \"Invalid function keyword option/s: \" ks)))\n\n        filters (when-let [[_ fsyn] (find opts :filters)]\n                  (parse-filter-set fsyn))\n\n        object (when-let [[_ obj] (find opts :object)]\n                 (parse-object obj))\n\n        flow (when-let [[_ obj] (find opts :flow)]\n               (parse-filter obj))\n\n        fixed-dom (cond \n                    asterix-pos (take (dec asterix-pos) all-dom)\n                    ellipsis-pos (take (dec ellipsis-pos) all-dom)\n                    ampersand-pos (take ampersand-pos all-dom)\n                    :else all-dom)\n\n        rest-type (when asterix-pos\n                    (nth all-dom (dec asterix-pos)))\n        _ (when-not (or (not asterix-pos)\n                        (= (count all-dom) (inc asterix-pos)))\n            (err/int-error (str \"Trailing syntax after rest parameter: \" (pr-str (drop (inc asterix-pos) all-dom)))))\n        [drest-type _ drest-bnd :as drest-seq] (when ellipsis-pos\n                                                 (drop (dec ellipsis-pos) all-dom))\n        _ (when-not (or (not ellipsis-pos) (= 3 (count drest-seq))) \n            (err/int-error \"Dotted rest entry must be 3 entries\"))\n        _ (when-not (or (not ellipsis-pos) (symbol? drest-bnd))\n            (err/int-error \"Dotted bound must be symbol\"))\n        [& {optional-kws :optional mandatory-kws :mandatory} :as kws-seq]\n        (let [kwsyn (when ampersand-pos\n                      (drop (inc ampersand-pos) all-dom))]\n          ; support deprecated syntax [& {} -> ] to be equivalent to [& :optional {} -> ]\n          (if (and kwsyn\n                   (map? (first kwsyn)))\n            (do (err/deprecated-warn \"[& {} -> ] function syntax is deprecated. Use [& :optional {} -> ]\")\n                (cons :optional kwsyn))\n            kwsyn))\n\n        _ (when-not (or (not ampersand-pos) (seq kws-seq)) \n            (err/int-error \"Must provide syntax after &\"))]\n    (merge\n      {:op :Fn-method\n       :dom (mapv parse fixed-dom)\n       :rng (parse rng)\n       :filter filters\n       :object object\n       :flow flow\n       :children (vec (concat [:dom :rng :filter :object :flow]\n                              (when asterix-pos\n                                [:rest])\n                              (when ellipsis-pos\n                                [:drest])))}\n      (when asterix-pos\n        {:rest (parse rest-type)})\n      (when ellipsis-pos\n        (let [bnd (*dotted-scope* drest-bnd)\n              _ (when-not (symbol? bnd)\n                  (err/int-error (str (pr-str drest-bnd) \" is not in scope as a dotted variable\")))\n              gbnd (gensym bnd)]\n          {:drest\n           {:op :dotted-pretype\n            :f {:op :F :name gbnd}\n            :drest (with-frees {drest-bnd gbnd} ;with dotted bound in scope as free\n                     (parse drest-type))\n            :name gbnd}})))))", :ns "clojure.core.typed.parse-ast", :name "parse-function", :file "clojure/core/typed/parse_ast.clj", :column 1, :line 683, :arglists ([f])}
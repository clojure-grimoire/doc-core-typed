{:ns "clojure.core.typed.macros", :name "defn", :file "clojure/core/typed/macros.clj", :type :macro, :src "(defmacro\n  ^{:forms '[(defn poly? name docstring? [param :- type *] :- type exprs*)\n             (defn poly? name docstring? ([param :- type *] :- type exprs*)+)]}\n  defn\n  \"Like defn, but with optional annotations. All annotations default to Any,\n  like the typed fn macro. Rest parameters default to starred.\n\n  eg. (defn fname [a :- Number, b :- (U Symbol nil)] :- Integer ...)\n\n  ;annotate return\n  (defn fname [a :- String] :- String ...)\n\n  ;multi-arity\n  (defn fname \n    ([a :- String] :- String ...)\n    ([a :- String, b :- Number] :- Long ...))\"\n  [& args]\n  (let [[poly args] (internal/take-when vector? args)\n        _ (when poly\n            (err/nyi-error \"Poly for defn\"))\n        [name & args] args\n        _ (assert (symbol? name) \"defn name should be a symbol\")\n        [docstring args] (internal/take-when string? args)]\n    `(def\n       ~(vary-meta name #(merge\n                           %\n                           (when docstring\n                             {:doc docstring})))\n       (fn ~@args))))", :column 1, :line 228, :macro true, :arglists ([& args]), :doc "Like defn, but with optional annotations. All annotations default to Any,\n  like the typed fn macro. Rest parameters default to starred.\n\n  eg. (defn fname [a :- Number, b :- (U Symbol nil)] :- Integer ...)\n\n  ;annotate return\n  (defn fname [a :- String] :- String ...)\n\n  ;multi-arity\n  (defn fname \n    ([a :- String] :- String ...)\n    ([a :- String, b :- Number] :- Long ...))", :forms [(defn poly? name docstring? [param :- type *] :- type exprs*) (defn poly? name docstring? ([param :- type *] :- type exprs*) +)]}
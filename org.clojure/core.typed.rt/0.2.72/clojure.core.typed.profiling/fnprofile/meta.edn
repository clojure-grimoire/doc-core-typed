{:added "1.0", :ns "clojure.core.typed.profiling", :name "fnprofile", :special-form true, :file "clojure/core/typed/profiling.clj", :type :macro, :src "(defmacro fnprofile\n  \"params => positional-params* , or positional-params* & next-param\n  positional-param => binding-form\n  next-param => binding-form\n  name => symbol\n\n  Defines a function\"\n  {:added \"1.0\", :special-form true,\n   :forms '[(fn name? [params* ] exprs*) (fn name? ([params* ] exprs*)+)]}\n  [{:keys [fake-name]} & sigs]\n  (let [name (if (symbol? (first sigs)) (first sigs) nil)\n        sigs (if name (next sigs) sigs)\n        sigs (if (vector? (first sigs)) \n               (list sigs) \n               (if (seq? (first sigs))\n                 sigs\n                 ;; Assume single arity syntax\n                 (throw (IllegalArgumentException. \n                          (if (seq sigs)\n                            (str \"Parameter declaration \" \n                                 (first sigs)\n                                 \" should be a vector\")\n                            (str \"Parameter declaration missing\"))))))\n        psig (fn* [sig]\n                  ;; Ensure correct type before destructuring sig\n                  (when (not (seq? sig))\n                    (throw (IllegalArgumentException.\n                             (str \"Invalid signature \" sig\n                                  \" should be a list\"))))\n                  (let [[params & body] sig\n                        _ (when (not (vector? params))\n                            (throw (IllegalArgumentException. \n                                     (if (seq? (first sigs))\n                                       (str \"Parameter declaration \" params\n                                            \" should be a vector\")\n                                       (str \"Invalid signature \" sig\n                                            \" should be a list\")))))\n                        conds (when (and (next body) (map? (first body))) \n                                (first body))\n                        body (if conds (next body) body)\n                        conds (or conds (meta params))\n                        pre (:pre conds)\n                        post (:post conds)                       \n                        body (if post\n                               `((let [~'% ~(if (< 1 (count body)) \n                                              `(do ~@body) \n                                              (first body))]\n                                   ~@(map (fn* [c] `(assert ~c)) post)\n                                   ~'%))\n                               body)\n                        body (if pre\n                               (concat (map (fn* [c] `(assert ~c)) pre) \n                                       body)\n                               body)]\n                    (#'clojure.core/maybe-destructured params body)))\n        new-sigs (map psig sigs)\n        add-profile (fn [name sigs]\n                      (map (fn [[a & body :as p]]\n                             (assert (seq? p) (pr-str sigs))\n                             (list a `(p ~(keyword (-> *ns* ns-name str)\n                                                     (str name))\n                                           ~@body)))\n                           sigs))]\n\n    (with-meta\n      (if name\n        (list* 'fn* name (add-profile name new-sigs))\n        (cons 'fn* (add-profile fake-name new-sigs)))\n      (meta &form))))", :column 1, :line 57, :macro true, :arglists ([{:keys [fake-name]} & sigs]), :doc "params => positional-params* , or positional-params* & next-param\n  positional-param => binding-form\n  next-param => binding-form\n  name => symbol\n\n  Defines a function", :forms [(fn name? [params*] exprs*) (fn name? ([params*] exprs*) +)]}
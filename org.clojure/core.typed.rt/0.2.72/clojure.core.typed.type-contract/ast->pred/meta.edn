{:ns "clojure.core.typed.type-contract", :name "ast->pred", :file "clojure/core/typed/type_contract.clj", :type :fn, :src "(defn ast->pred \n  \"Returns syntax representing a runtime predicate on the\n  given type ast.\"\n  [t]\n  (letfn [(gen-inner [{:keys [op] :as t} arg]\n            (case op\n              (:F) (err/int-error \"Cannot generate predicate for free variable\")\n              (:Poly) (err/int-error \"Cannot generate predicate for polymorphic type\")\n              (:PolyDots) (err/int-error \"Cannot generate predicate for dotted polymorphic type\")\n              (:Fn) (err/int-error \"Cannot generate predicate for function type\")\n              (:TApp) (let [{:keys [rator rands]} t]\n                        (cond \n                          ;needs resolving\n                          (#{:Name} (:op rator))\n                          (gen-inner (update-in t [:rator] ops/resolve-Name) arg)\n                          ;polymorphic class\n                          (#{:Class} (:op rator))\n                            (let [{:keys [args pred] :as rcls} (@impl/rclass-env (:name rator))\n                                  _ (when-not rcls\n                                      (err/int-error (str \"Class does not take arguments: \"\n                                                          (:name rator))))\n                                  _ (when-not (args (count rands))\n                                      (err/int-error (str \"Wrong number of arguments to \"\n                                                          (:name rator) \", expected \" args\n                                                          \" actual \" (count rands))))\n                                  rands-args (repeatedly (count rands) gensym)\n                                  rands-p (mapv (fn [ast gsym]\n                                                  `(fn [~gsym] ~(gen-inner ast gsym))) \n                                                rands rands-args)]\n                              `(and (instance? ~(:name rator) ~arg)\n                                    ~(apply pred arg rands-p)))\n                          ;substitute\n                          (#{:TFn} (:op rator))\n                          (gen-inner (ops/instantiate-TFn rator rands) arg)\n                          :else\n                          (err/int-error (str \"Don't know how to apply type: \" (:form t)))))\n              (:Class) `(instance? ~(:name t) ~arg)\n              (:Name) \n              (impl/impl-case\n                :clojure (gen-inner (ops/resolve-Name t) arg)\n                :cljs (err/int-error (str \"TODO CLJS Name\")))\n              ;              (cond\n              ;                              (empty? (:poly? t)) `(instance? ~(:the-class t) ~arg)\n              ;                              :else (err/int-error (str \"Cannot generate predicate for polymorphic Class\")))\n              (:Any) `true\n              ;TODO special case for union of HMap, and unions of constants\n              (:U) `(or ~@(mapv gen-inner (:types t) (repeat arg)))\n              (:I) `(and ~@(mapv gen-inner (:types t) (repeat arg)))\n              (:HVec) `(and (vector? ~arg)\n                            ~(cond\n                               (:rest t)\n                               `(<= ~(count (:types t)) (count ~arg))\n                               (:drest t)\n                               (err/int-error (str \"Cannot generate predicate for dotted HVec\"))\n                               :else\n                               `(== ~(count (:types t)) (count ~arg)))\n                            ~@(doall\n                                (map-indexed \n                                  (fn [i t*]\n                                    (let [vlocal (gensym \"vlocal\")]\n                                      `(let [~vlocal (nth ~arg ~i)]\n                                         ~(gen-inner t* vlocal))))\n                                  (:types t)))\n                            ~@(when (:rest t)\n                                (let [nfixed (count (:types t))]\n                                  [`(let [rstvec# (subvec ~arg ~nfixed)]\n                                      (every? ~(let [vlocal (gensym \"vlocal\")]\n                                                 `(fn [~vlocal] \n                                                    ~(gen-inner (:rest t) vlocal)))\n                                              rstvec#))])))\n              (:CountRange) (let [cnt (gensym \"cnt\")]\n                              `(and (or (nil? ~arg)\n                                        (coll? ~arg))\n                                    (let [~cnt (count ~arg)]\n                                      (<= ~@(let [{:keys [lower upper]} t]\n                                              (concat [lower cnt]\n                                                      (when upper\n                                                        [upper])))))))\n              (:singleton) (let [v (:val t)]\n                             (cond\n                               (nil? v) `(nil? ~arg)\n                               (symbol? v) `(= '~v ~arg)\n                               (keyword? v) `(identical? '~v ~arg)\n                               ((some-fn true? false?) v) `(identical? '~v ~arg)\n                               (number? v) `(when (number? ~arg)\n                                              ; I think = models the type system's behaviour better than ==\n                                              (= '~v ~arg))\n                               :else (err/int-error \n                                       (str \"Cannot generate predicate for value type: \" v))))\n              (:HMap) (let [mandatory (apply hash-map (:mandatory t))\n                            optional (apply hash-map (:optional t))\n                            absent-keys (:absent-keys t)\n                            valgen (fn [tmap]\n                                     (zipmap (map :val (keys tmap))\n                                             (mapv (fn [tsyn gi]\n                                                     `(fn [~gi]\n                                                        ~(gen-inner tsyn gi)))\n                                                   (vals tmap)\n                                                   (repeatedly (count tmap) gensym))))]\n                        `((impl/hmap-c? :mandatory ~(valgen mandatory)\n                                        :optional ~(valgen optional)\n                                        :absent-keys ~(set (map :val absent-keys))\n                                        :complete? ~(:complete? t))\n                          ~arg))\n              (:Rec) (cond\n                       ;we're already inside this rec\n                       (contains? *inside-rec* (:unwrap-id t))\n                         (let [{:keys [unwrap-id]} t]\n                           `(~unwrap-id ~arg))\n                       \n                       :else\n                        (let [unwrap-id (gensym 'Rec-id)\n                              body (ops/unwrap-rec t unwrap-id)\n                              garg (gensym 'garg)]\n                          (binding [*inside-rec* (conj *inside-rec* unwrap-id)]\n                            `((fn ~unwrap-id\n                                [~garg]\n                                ~(gen-inner body garg))\n                              ~arg))))\n              (err/int-error (str op \" not supported in type->pred: \" (:form t)))))]\n    (let [arg (gensym \"arg\")]\n      `(fn [~arg] \n         (boolean\n           ~(gen-inner t arg))))))", :column 1, :line 18, :arglists ([t]), :doc "Returns syntax representing a runtime predicate on the\n  given type ast."}
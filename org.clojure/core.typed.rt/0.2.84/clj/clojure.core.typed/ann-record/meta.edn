{:ns "clojure.core.typed", :name "ann-record", :file "clojure/core/typed.clj", :type :macro, :src "(defmacro \n  ^{:forms '[(ann-record dname [field :- type*] opts*)\n             (ann-record binder dname [field :- type*] opts*)]}\n  ann-record \n  \"Annotate record Class name dname with expected fields.\n  If unqualified, qualify in the current namespace.\n  Takes an optional type variable binder before the name.\n\n  Fields must be specified in the same order as presented \n  in defrecord, with exactly the same field names.\n\n  Also annotates record factories and constructors.\n\n  Binder is a vector of specs. Each spec is a vector\n  with the variable name as the first entry, followed by\n  keyword arguments:\n  - :variance (mandatory)\n    The declared variance of the type variable. Possible\n    values are :covariant, :contravariant and :invariant.\n  - :< (optional)\n    The upper type bound of the type variable. Defaults to\n    Any, or the most general type of the same rank as the\n    lower bound.\n  - :> (optional)\n    The lower type bound of the type variable. Defaults to\n    Nothing, or the least general type of the same rank as the\n    upper bound.\n  \n  eg. ; a record in the current namespace\n      (ann-record MyRecord [a :- Number,\n                            b :- Long])\n\n      ; a record in another namespace\n      (ann-record another.ns.TheirRecord\n                    [str :- String,\n                     vec :- (Vec Number)])\n\n      ; a record, polymorphic in a\n      (ann-record [[a :variance :covariant]]\n                  MyPolyRecord\n                  [str :- String,\n                   vec :- (Vec Number)\n                   ply :- (Set a)])\"\n  [& args]\n  ;[dname fields & {ancests :unchecked-ancestors rplc :replace :as opt}]\n  (let [bnd-provided? (vector? (first args))\n        vbnd (when bnd-provided?\n               (first args))\n        [dname fields & {ancests :unchecked-ancestors rplc :replace :as opt}]\n        (if bnd-provided?\n          (next args)\n          args)]\n    (let [qname (if (some #{\\.} (str dname))\n                  dname\n                  (symbol (str (namespace-munge *ns*) \".\" dname)))]\n      (swap! impl/datatype-env \n             assoc \n             qname\n             {:record? true\n              :name qname\n              :fields fields\n              :bnd vbnd}))\n    `(ann-record* '~vbnd '~dname '~fields '~opt)))", :column 1, :line 1835, :macro true, :arglists ([& args]), :doc "Annotate record Class name dname with expected fields.\n  If unqualified, qualify in the current namespace.\n  Takes an optional type variable binder before the name.\n\n  Fields must be specified in the same order as presented \n  in defrecord, with exactly the same field names.\n\n  Also annotates record factories and constructors.\n\n  Binder is a vector of specs. Each spec is a vector\n  with the variable name as the first entry, followed by\n  keyword arguments:\n  - :variance (mandatory)\n    The declared variance of the type variable. Possible\n    values are :covariant, :contravariant and :invariant.\n  - :< (optional)\n    The upper type bound of the type variable. Defaults to\n    Any, or the most general type of the same rank as the\n    lower bound.\n  - :> (optional)\n    The lower type bound of the type variable. Defaults to\n    Nothing, or the least general type of the same rank as the\n    upper bound.\n  \n  eg. ; a record in the current namespace\n      (ann-record MyRecord [a :- Number,\n                            b :- Long])\n\n      ; a record in another namespace\n      (ann-record another.ns.TheirRecord\n                    [str :- String,\n                     vec :- (Vec Number)])\n\n      ; a record, polymorphic in a\n      (ann-record [[a :variance :covariant]]\n                  MyPolyRecord\n                  [str :- String,\n                   vec :- (Vec Number)\n                   ply :- (Set a)])", :forms [(ann-record dname [field :- type*] opts*) (ann-record binder dname [field :- type*] opts*)]}
{:ns "cljs.core.typed", :name "fn", :file "clojure/core/typed/macros.clj", :type :macro, :src "(defmacro \n  ^{:forms '[(fn name? [param :- type* & param :- type * ?] :- type? exprs*)\n             (fn name? ([param :- type* & param :- type * ?] :- type? exprs*)+)]}\n  fn\n  \"Like clojure.core/fn, but with optional annotations.\n\n  eg. ;these forms are equivalent\n      (fn [a] b)\n      (fn [a :- Any] b)\n      (fn [a :- Any] :- Any b)\n      (fn [a] :- Any b)\n\n      ;annotate return\n      (fn [a :- String] :- String body)\n\n      ;named fn\n      (fn fname [a :- String] :- String body)\n\n      ;rest parameter\n      (fn [a :- String & b :- Number *] body)\n\n      ;dotted rest parameter\n      (fn [a :- String & b :- Number ... x] body)\n\n      ;multi-arity\n      (fn fname \n        ([a :- String] :- String ...)\n        ([a :- String, b :- Number] :- String ...))\n\n      ; polymorphic binder\n      (fn :forall [x y z]\n        fname \n        ([a :- String] :- String ...)\n        ([a :- String, b :- Number] :- String ...))\n  \"\n  [& forms]\n  (expand-typed-fn false forms))", :column 1, :line 66, :macro true, :arglists ([& forms]), :doc "Like clojure.core/fn, but with optional annotations.\n\n  eg. ;these forms are equivalent\n      (fn [a] b)\n      (fn [a :- Any] b)\n      (fn [a :- Any] :- Any b)\n      (fn [a] :- Any b)\n\n      ;annotate return\n      (fn [a :- String] :- String body)\n\n      ;named fn\n      (fn fname [a :- String] :- String body)\n\n      ;rest parameter\n      (fn [a :- String & b :- Number *] body)\n\n      ;dotted rest parameter\n      (fn [a :- String & b :- Number ... x] body)\n\n      ;multi-arity\n      (fn fname \n        ([a :- String] :- String ...)\n        ([a :- String, b :- Number] :- String ...))\n\n      ; polymorphic binder\n      (fn :forall [x y z]\n        fname \n        ([a :- String] :- String ...)\n        ([a :- String, b :- Number] :- String ...))\n  ", :forms [(fn name? [param :- type* & param :- type * ?] :- type? exprs*) (fn name? ([param :- type* & param :- type * ?] :- type? exprs*) +)]}
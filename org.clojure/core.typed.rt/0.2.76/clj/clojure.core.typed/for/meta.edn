{:ns "clojure.core.typed", :name "for", :file "clojure/core/typed.clj", :type :macro, :src "(defmacro for\n  \"Like clojure.core/for with optional type annotations.\n\n  All types default to Any.\n\n  The :let option uses clojure.core.typed/let.\n  \n  eg. (for [a :- (U nil Int) [1 nil 2 3]\n            :when a]\n        :- Number\n        (inc a))\"\n  [seq-exprs & maybe-ann-body-expr]\n  (@#'core/assert-args\n     (vector? seq-exprs) \"a vector for its binding\"\n     (even? (count seq-exprs)) \"an even number of forms in binding vector\")\n  (let [[ret-ann body-expr] (if (#{:-} (first maybe-ann-body-expr))\n                              (let [_ (assert (#{3} (count maybe-ann-body-expr))\n                                              (str \"Wrong arguments to for: \" maybe-ann-body-expr))\n                                    [colon t body] maybe-ann-body-expr]\n                                [t body])\n                              (let [_ (assert (#{1} (count maybe-ann-body-expr))\n                                              (str \"Wrong arguments to for: \" maybe-ann-body-expr))\n                                    [body] maybe-ann-body-expr]\n                                [`Any body]))\n        normalise-args\n        ; change [a :- b c] to [[a :- b] c]\n        (fn [seq-exprs]\n          (loop [flat-result []\n                 seq-exprs seq-exprs]\n            (cond\n              (empty? seq-exprs) flat-result\n\n              ;for options (:let, :while etc)\n              (keyword? (first seq-exprs)) (let [_ (assert (#{2} (count (take 2 seq-exprs)))\n                                                           (str \"for option missing \" (first seq-exprs)))\n                                                 [k v & rst] seq-exprs]\n                                             (recur (conj flat-result k v)\n                                                    rst))\n              :else (if (#{:-} (second seq-exprs))\n                      (let [_ (assert (#{4} (count (take 4 seq-exprs)))\n                                      (str \"for parameter missing after ':-'\"))\n                            [b colon t init & rst] seq-exprs]\n                        (recur (conj flat-result [b colon t] init)\n                               rst))\n                      (let [_ (assert (#{2} (count (take 2 seq-exprs)))\n                                      (str \"for binding needs initial values\"))\n                            [b init & rst] seq-exprs]\n                        (recur (conj flat-result [b :- `Any] init)\n                               rst))))))\n\n        ; normalise seq-exprs to be flat pairs\n        seq-exprs (normalise-args seq-exprs)\n\n        to-groups (fn [seq-exprs]\n                    (reduce (fn [groups [k v]]\n                              (if (keyword? k)\n                                (conj (pop groups) (conj (peek groups) [k v]))\n                                (conj groups [k v])))\n                            [] (partition 2 seq-exprs)))\n        err (fn [& msg] (throw (IllegalArgumentException. ^String (apply str msg))))\n        emit-bind (fn emit-bind [[[bind expr & mod-pairs]\n                                  & [[_ next-expr] :as next-groups]]]\n                    (let [_ (assert (and (vector? bind)\n                                         (#{3} (count bind))\n                                         (#{:-} (second bind))) \n                                    \"Binder must be of the form [lhs :- type]\")\n                          bind-ann (nth bind 2)\n                          bind (nth bind 0)\n                          giter (gensym \"iter__\")\n                          gxs (gensym \"s__\")\n                          do-mod (fn do-mod [[[k v :as pair] & etc]]\n                                   (cond\n                                     ;typed let\n                                     (= k :let) `(let ~v ~(do-mod etc))\n                                     (= k :while) `(when ~v ~(do-mod etc))\n                                     (= k :when) `(if ~v\n                                                    ~(do-mod etc)\n                                                    (recur (rest ~gxs)))\n                                     (keyword? k) (err \"Invalid 'for' keyword \" k)\n                                     next-groups\n                                      `(let [iterys# ~(emit-bind next-groups)\n                                             fs# (seq (iterys# ~next-expr))]\n                                         (if fs#\n                                           (concat fs# (~giter (rest ~gxs)))\n                                           (recur (rest ~gxs))))\n                                     :else `(cons ~body-expr\n                                                  (~giter (rest ~gxs)))))]\n                      (if next-groups\n                        #_\"not the inner-most loop\"\n                        `(fn ~giter [~gxs :- (Option (Seqable ~bind-ann))]\n                           :- (Seq ~ret-ann)\n                           (lazy-seq\n                             (loop [~gxs :- (Option (Seqable ~bind-ann)) ~gxs]\n                               (when-first [~bind ~gxs]\n                                 ~(do-mod mod-pairs)))))\n                        #_\"inner-most loop\"\n                        (let [gi (gensym \"i__\")\n                              gb (gensym \"b__\")\n                              do-cmod (fn do-cmod [[[k v :as pair] & etc]]\n                                        (cond\n                                          ; typed let\n                                          (= k :let) `(let ~v ~(do-cmod etc))\n                                          (= k :while) `(when ~v ~(do-cmod etc))\n                                          (= k :when) `(if ~v\n                                                         ~(do-cmod etc)\n                                                         (recur\n                                                           (unchecked-inc ~gi)))\n                                          (keyword? k)\n                                            (err \"Invalid 'for' keyword \" k)\n                                          :else\n                                            `(do (chunk-append ~gb \n                                                               ; put an ann-form here so at least one error message\n                                                               ; points to code the user can recognise.\n                                                               (ann-form ~body-expr\n                                                                         ~ret-ann))\n                                                 (recur (unchecked-inc ~gi)))))]\n                          `(fn ~giter [~gxs :- (Option (Seqable ~bind-ann))]\n                             :- (Seq ~ret-ann)\n                             (lazy-seq\n                               (loop [~gxs :- (Option (Seqable ~bind-ann)) ~gxs]\n                                 (when-let [~gxs (seq ~gxs)]\n                                   (if (chunked-seq? ~gxs)\n                                     (let [c# (chunk-first ~gxs)\n                                           size# (int (count c#))\n                                           ~gb (ann-form (chunk-buffer size#)\n                                                         (~'clojure.lang.ChunkBuffer ~ret-ann))]\n                                       (if (loop [~gi :- Int, (int 0)]\n                                             (if (< ~gi size#)\n                                               (let [;~bind (.nth c# ~gi)]\n                                                     ~bind (nth c# ~gi)]\n                                                 ~(do-cmod mod-pairs))\n                                               true))\n                                         (chunk-cons\n                                           (chunk ~gb)\n                                           (~giter (chunk-rest ~gxs)))\n                                         (chunk-cons (chunk ~gb) nil)))\n                                     (let [~bind (first ~gxs)]\n                                       ~(do-mod mod-pairs)))))))))))]\n    `(let [iter# ~(emit-bind (to-groups seq-exprs))]\n        (iter# ~(second seq-exprs)))))", :column 1, :line 326, :macro true, :arglists ([seq-exprs & maybe-ann-body-expr]), :doc "Like clojure.core/for with optional type annotations.\n\n  All types default to Any.\n\n  The :let option uses clojure.core.typed/let.\n  \n  eg. (for [a :- (U nil Int) [1 nil 2 3]\n            :when a]\n        :- Number\n        (inc a))"}
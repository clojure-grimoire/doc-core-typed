{:type :var, :src "(def init-aliases\n  '[\n  ^{:doc \"A type that returns true for clojure.core/integer?\"\n    :forms '[AnyInteger]}\nAnyInteger (U Integer Long clojure.lang.BigInt BigInteger Short Byte)\n\n    ^{:doc \"A type that returns true for clojure.core/integer?\"\n      :forms '[Int]}\nInt (U Integer Long clojure.lang.BigInt BigInteger Short Byte)\n      ^{:doc \"A type that returns true for clojure.core/number?\"\n        :forms '[Num]}\nNum Number\n      ^{:doc \"A keyword\"\n        :forms '[Keyword]}\nKeyword clojure.lang.Keyword\n      ^{:doc \"A keyword\"\n        :forms '[Kw]}\nKw clojure.lang.Keyword\n      ^{:doc \"A symbol\"\n        :forms '[Symbol]}\nSymbol clojure.lang.Symbol\n      ^{:doc \"A symbol\"\n        :forms '[Sym]}\nSym clojure.lang.Symbol\n\n      ^{:doc \"A string\"\n        :forms '[Str]}\nStr java.lang.String\n\n      ^{:doc \"A boolean\"\n        :forms '[Bool]}\nBool java.lang.Boolean\n\n; TODO: IMapEntry\n\n      ^{:doc \"A namespace\"\n        :forms '[Namespace]}\nNamespace clojure.lang.Namespace\n\n    ^{:doc \"An atom that can read and write type x.\"\n      :forms '[(Atom1 t)]}\nAtom1 (TFn [[x :variance :invariant]] \n                              (clojure.lang.Atom x x))\n    ^{:doc \"An atom that can write type w and read type r.\"\n      :forms '[(Atom2 t)]}\nAtom2 (TFn [[w :variance :contravariant]\n                               [r :variance :covariant]] \n                              (clojure.lang.Atom w r))\n    ^{:doc \"An var that can read and write type x.\"\n      :forms '[(Var1 t)]}\nVar1 \n    (TFn [[x :variance :invariant]] \n         (clojure.lang.Var x x))\n    ^{:doc \"An var that can write type w and read type r.\"\n      :forms '[(Var2 w r)]}\nVar2 \n    (TFn [[w :variance :contravariant]\n          [r :variance :covariant]] \n         (clojure.lang.Var w r))\n    ^{:doc \"A ref that can read and write type x.\"\n      :forms '[(Ref1 t)]}\nRef1 (TFn [[x :variance :invariant]] (clojure.lang.Ref x x))\n    ^{:doc \"A ref that can write type w and read type r.\"\n      :forms '[(Ref2 w r)]}\nRef2 (TFn [[w :variance :contravariant]\n                              [r :variance :covariant]] \n                             (clojure.lang.Ref w r))\n    ^{:doc \"An agent that can read and write type x.\"\n      :forms '[(Agent1 t)]}\nAgent1 (TFn [[x :variance :invariant]] \n                               (clojure.lang.Agent x x))\n    ^{:doc \"An agent that can write type w and read type r.\"\n      :forms '[(Agent2 t t)]}\nAgent2 (TFn [[w :variance :contravariant]\n                                [r :variance :covariant]] \n                               (clojure.lang.Agent w r))\n\n    ^{:doc \"A union of x and nil.\"\n      :forms '[(Option t)]}\nOption (TFn [[x :variance :covariant]] (U nil x))\n\n    ^{:doc \"A union of x and nil.\"\n      :forms '[(Nilable t)]}\nNilable (TFn [[x :variance :covariant]] (U nil x))\n\n      ^{:doc \"The identity function at the type level.\"\n        :forms '[Id]}\nId (TFn [[x :variance :covariant]] x)\n\n      ^{:doc \"A persistent collection with member type x.\"\n        :forms '[(Coll t)]}\nColl (TFn [[x :variance :covariant]]\n                             (clojure.lang.IPersistentCollection x))\n    ^{:doc \"A persistent collection with member type x and count greater than 0.\"\n      :forms '[(NonEmptyColl t)]}\nNonEmptyColl (TFn [[x :variance :covariant]]\n                                      (I (clojure.lang.IPersistentCollection x) (CountRange 1)))\n    ^{:doc \"A persistent vector with member type x.\"\n      :forms '[(Vec t)]}\nVec (TFn [[x :variance :covariant]]\n                            (clojure.lang.IPersistentVector x))\n    ^{:doc \"A persistent vector with member type x and count greater than 0.\"\n      :forms '[(NonEmptyVec t)]}\nNonEmptyVec (TFn [[x :variance :covariant]]\n                                     (I (clojure.lang.IPersistentVector x) (CountRange 1)))\n    ^{:doc \"A persistent vector returned from clojure.core/vector (and others)\"\n      :forms '[(AVec t)]}\nAVec (TFn [[x :variance :covariant]]\n                             (I (clojure.lang.IPersistentVector x)\n                                (java.lang.Iterable x)\n                                (java.util.Collection x)\n                                (java.util.List x)\n                                clojure.lang.IObj))\n    ^{:doc \"A persistent vector returned from clojure.core/vector (and others) and count greater than 0.\"\n      :forms '[(NonEmptyAVec t)]}\nNonEmptyAVec (TFn [[x :variance :covariant]]\n                                     (I (clojure.lang.IPersistentVector x)\n                                        (java.lang.Iterable x)\n                                        (java.util.Collection x)\n                                        (java.util.List x)\n                                        clojure.lang.IObj\n                                        (CountRange 1)))\n    ^{:doc \"A non-empty lazy sequence of type t\"\n      :forms '[(NonEmptyLazySeq t)]}\nNonEmptyLazySeq (TFn [[t :variance :covariant]]\n                                        (I (clojure.lang.LazySeq t) (CountRange 1)))\n    ^{:doc \"A persistent map with keys k and vals v.\"\n      :forms '[(Map t t)]}\nMap (TFn [[k :variance :covariant]\n                             [v :variance :covariant]]\n                            (clojure.lang.IPersistentMap k v))\n    ^{:doc \"A persistent set with member type x\"\n      :forms '[(Set t)]}\nSet (TFn [[x :variance :covariant]]\n                            (clojure.lang.IPersistentSet x))\n    ^{:doc \"A sorted persistent set with member type x\"\n      :forms '[(SortedSet t)]}\nSortedSet (TFn [[x :variance :covariant]]\n                               (Extends [(clojure.lang.IPersistentSet x) clojure.lang.Sorted]))\n    ^{:doc \"A type that can be used to create a sequence of member type x.\"\n      :forms '[(Seqable t)]}\nSeqable (TFn [[x :variance :covariant]]\n                                (clojure.lang.Seqable x))\n    ^{:doc \"A type that can be used to create a sequence of member type x\nwith count greater than 0.\"\n      :forms '[(NonEmptySeqable t)]}\n\nNonEmptySeqable (TFn [[x :variance :covariant]]\n                                         (I (clojure.lang.Seqable x) (CountRange 1)))\n    ^{:doc \"A type that can be used to create a sequence of member type x\nwith count 0.\"\n      :forms '[(EmptySeqable t)]}\nEmptySeqable (TFn [[x :variance :covariant]]\n                                  (I (clojure.lang.Seqable x) (ExactCount 0)))\n      ^{:doc \"A persistent sequence of member type x.\"\n        :forms '[(Seq t)]}\nSeq (TFn [[x :variance :covariant]]\n                            (clojure.lang.ISeq x))\n\n    ^{:doc \"A persistent sequence of member type x with count greater than 0.\"\n      :forms '[(NonEmptySeq t)]}\nNonEmptySeq (TFn [[x :variance :covariant]]\n                                     (I (clojure.lang.ISeq x) (CountRange 1)))\n\n    ^{:doc \"A persistent sequence of member type x with count greater than 0, or nil.\"\n      :forms '[(NilableNonEmptySeq t)]}\nNilableNonEmptySeq (TFn [[x :variance :covariant]]\n                                         (U nil (I (clojure.lang.ISeq x) (CountRange 1))))\n\n    ^{:doc \"The type of all things with count 0. Use as part of an intersection.\neg. See EmptySeqable.\"\n      :forms '[EmptyCount]}\n\nEmptyCount (ExactCount 0)\n    ^{:doc \"The type of all things with count greater than 0. Use as part of an intersection.\neg. See NonEmptySeq\"\n      :forms '[NonEmptyCount]}\nNonEmptyCount (CountRange 1)\n\n    ^{:doc \"A hierarchy for use with derive, isa? etc.\"\n      :forms '[Hierarchy]}\nHierarchy '{:parents (clojure.lang.IPersistentMap Any Any)\n                               :ancestors (clojure.lang.IPersistentMap Any Any)\n                               :descendants (clojure.lang.IPersistentMap Any Any)}\n\n    ^{:doc \"A Clojure future (see clojure.core/{future-call,future}).\"\n      :forms '[(Future t)]}\nFuture \n                      (TFn [[x :variance :covariant]]\n                       (Extends [(clojure.lang.IDeref x)\n                                 (clojure.lang.IBlockingDeref x)\n                                 clojure.lang.IPending\n                                 java.util.concurrent.Future]))\n\n    ^{:doc \"A Clojure promise (see clojure.core/{promise,deliver}).\"\n      :forms '[(Promise t)]}\nPromise \n              (TFn [[x :variance :invariant]]\n               (Rec [p]\n                (I (Extends [(clojure.lang.IDeref x)\n                             (clojure.lang.IBlockingDeref x)\n                             clojure.lang.IPending])\n                   [x -> (U nil p)])))\n\n    ^{:doc \"A Clojure delay (see clojure.core/{delay,force}).\"\n      :forms '[(Delay t)]}\nDelay\n              (TFn [[x :variance :covariant]]\n                   (clojure.lang.Delay x))\n\n    ^{:doc \"A Clojure derefable (see clojure.core/deref).\"\n      :forms '[(Deref t)]}\nDeref\n              (TFn [[x :variance :covariant]]\n                   (clojure.lang.IDeref x))\n\n    ^{:doc \"A Clojure blocking derefable (see clojure.core/deref).\"\n      :forms '[(BlockingDeref t)]}\nBlockingDeref\n              (TFn [[x :variance :covariant]]\n                   (clojure.lang.IBlockingDeref x))\n\n    ^{:doc \"A Clojure persistent list.\"\n      :forms '[(List t)]}\nList\n              (TFn [[x :variance :covariant]]\n                   (clojure.lang.IPersistentList x))\n\n    ^{:doc \"A Clojure custom exception type.\"\n      :forms '[ExInfo]}\nExInfo\n              (I clojure.lang.IExceptionInfo\n                 RuntimeException)\n\n    ^{:doc \"A Clojure proxy.\"\n      :forms '[Proxy]}\nProxy\n              clojure.lang.IProxy\n\n; Should c.l.Sorted be parameterised? Is it immutable?\n;    ^{:doc \"A sorted Clojure collection.\"\n;      :forms '[Sorted]}\n;Sorted\n;              clojure.lang.Sorted\n\n    ^{:doc \"A Clojure stack.\"\n      :forms '[(Stack t)]}\nStack\n              (TFn [[x :variance :covariant]]\n                   (clojure.lang.IPersistentStack x))\n\n    ^{:doc \"A Clojure reversible collection.\"\n      :forms '[(Reversible t)]}\nReversible\n              (TFn [[x :variance :covariant]]\n                   (clojure.lang.Reversible x))\n\n    ^{:doc \"A sequential collection.\"\n      :forms '[Sequential]}\nSequential\n             clojure.lang.Sequential\n\n    ^{:doc \"A sequential, seqable collection. Seq's aren't always Sequential.\"\n      :forms '[(SequentialSeqable t)]}\nSequentialSeqable\n      (TFn [[x :variance :covariant]]\n             (I clojure.lang.Sequential\n                (clojure.lang.Seqable x)))\n\n    ^{:doc \"A Clojure sequential sequence. Seq's aren't always Sequential.\"\n      :forms '[(SequentialSeq t)]}\nSequentialSeq\n      (TFn [[x :variance :covariant]]\n             (I clojure.lang.Sequential\n                (clojure.lang.ISeq x)))\n\n    ^{:doc \"A sequential seq returned from clojure.core/seq\"\n      :forms '[(ASeq t)]}\nASeq\n      (TFn [[x :variance :covariant]]\n           (I (clojure.lang.ISeq x)\n              clojure.lang.Sequential\n              (Iterable x)\n              (java.util.Collection x)\n              (java.util.List x)\n              clojure.lang.IObj))\n\n    ^{:doc \"A sequential non-empty seq retured from clojure.core/seq\"\n      :forms '[(NonEmptyASeq t)]}\nNonEmptyASeq\n      (TFn [[x :variance :covariant]]\n           (I (clojure.lang.ISeq x)\n              clojure.lang.Sequential\n              (Iterable x)\n              (java.util.Collection x)\n              (java.util.List x)\n              clojure.lang.IObj\n              (CountRange 1)))\n\n    ^{:doc \"The result of clojure.core/seq.\"\n      :forms '[(NilableNonEmptyASeq t)]}\nNilableNonEmptyASeq\n      (TFn [[x :variance :covariant]]\n           (U nil\n              (I (clojure.lang.ISeq x)\n                 clojure.lang.Sequential\n                 (Iterable x)\n                 (java.util.Collection x)\n                 (java.util.List x)\n                 clojure.lang.IObj\n                 (CountRange 1))))\n\n    ^{:doc \"A type that returns true for clojure.core/fn?\"\n      :forms '[Fn]}\nFn\n              clojure.lang.Fn\n\n    ^{:doc \"A Clojure multimethod.\"\n      :forms '[Multi]}\nMulti\n              clojure.lang.MultiFn\n])", :ns "clojure.core.typed.current-impl", :name "init-aliases", :file "clojure/core/typed/current_impl.clj", :column 1, :line 189}
{:ns "clojure.core.typed", :name "doseq", :file "clojure/core/typed.clj", :type :macro, :src "(defmacro doseq\n  \"Like clojure.core/doseq with optional annotations.\n\n  :let option uses clojure.core.typed/let\n  \n  eg.\n  (doseq [a :- (U nil AnyInteger) [1 nil 2 3]\n          :when a]\n     (inc a))\"\n  [seq-exprs & body]\n  (@#'core/assert-args\n     (vector? seq-exprs) \"a vector for its binding\"\n     (even? (count seq-exprs)) \"an even number of forms in binding vector\")\n  (let [normalise-args\n        ; change [a :- b c] to [[a :- b] c]\n        (fn [seq-exprs]\n          (loop [flat-result []\n                 seq-exprs seq-exprs]\n            (cond\n              (empty? seq-exprs) flat-result\n\n              ;for options (:let, :while etc)\n              (keyword? (first seq-exprs)) (let [_ (assert (#{2} (count (take 2 seq-exprs)))\n                                                           (str \"for option missing \" (first seq-exprs)))\n                                                 [k v & rst] seq-exprs]\n                                             (recur (conj flat-result k v)\n                                                    rst))\n              :else (if (#{:-} (second seq-exprs))\n                      (let [_ (assert (#{4} (count (take 4 seq-exprs)))\n                                      (str \"for parameter missing after ':-'\"))\n                            [b colon t init & rst] seq-exprs]\n                        (recur (conj flat-result [b colon t] init)\n                               rst))\n                      (let [_ (assert (#{2} (count (take 2 seq-exprs)))\n                                      (str \"for binding needs initial values\"))\n                            [b init & rst] seq-exprs]\n                        (recur (conj flat-result [b :- `Any] init)\n                               rst))))))\n\n        ; normalise seq-exprs to be flat pairs\n        seq-exprs (normalise-args seq-exprs)\n        step (fn step [recform exprs]\n               (if-not exprs\n                 [true `(do ~@body)]\n                 (let [k (first exprs)\n                       v (second exprs)]\n                   (if (keyword? k)\n                     (let [steppair (step recform (nnext exprs))\n                           needrec (steppair 0)\n                           subform (steppair 1)]\n                       (cond\n                         ;typed let\n                         (= k :let) [needrec `(let ~v ~subform)]\n                         (= k :while) [false `(when ~v\n                                                ~subform\n                                                ~@(when needrec [recform]))]\n                         (= k :when) [false `(if ~v\n                                               (do\n                                                 ~subform\n                                                 ~@(when needrec [recform]))\n                                               ~recform)]))\n                     ;; k is [k :- k-ann]\n                     (let [_ (assert (and (vector? k)\n                                          (#{3} (count k))\n                                          (#{:-} (second k))) \n                                     \"Binder must be of the form [lhs :- type]\")\n                           k-ann (nth k 2)\n                           k (nth k 0)\n                           ; k is the lhs binding\n                           seq- (gensym \"seq_\")\n                           chunk- (with-meta (gensym \"chunk_\")\n                                             {:tag 'clojure.lang.IChunk})\n                           count- (gensym \"count_\")\n                           i- (gensym \"i_\")\n                           recform `(recur (next ~seq-) nil 0 0)\n                           steppair (step recform (nnext exprs))\n                           needrec (steppair 0)\n                           subform (steppair 1)\n                           recform-chunk \n                             `(recur ~seq- ~chunk- ~count- (unchecked-inc ~i-))\n                           steppair-chunk (step recform-chunk (nnext exprs))\n                           subform-chunk (steppair-chunk 1)]\n                       [true\n                        `(loop [~seq- :- (U nil (Seq ~k-ann)) (seq ~v), \n                                ~chunk- :- (U nil (clojure.lang.IChunk ~k-ann)) nil\n                                ~count- :- Int 0,\n                                ~i- :- Int 0]\n                           (if (and (< ~i- ~count-)\n                                    ;; FIXME review this\n                                    ;; core.typed thinks chunk- could be nil here\n                                    ~chunk-)\n                             (let [;~k (.nth ~chunk- ~i-)\n                                   ~k (nth ~chunk- ~i-)]\n                               ~subform-chunk\n                               ~@(when needrec [recform-chunk]))\n                             (when-let [~seq- (seq ~seq-)]\n                               (if (chunked-seq? ~seq-)\n                                 (let [c# (chunk-first ~seq-)]\n                                   (recur (chunk-rest ~seq-) c#\n                                          (int (count c#)) (int 0)))\n                                 (let [~k (first ~seq-)]\n                                   ~subform\n                                   ~@(when needrec [recform]))))))])))))]\n    (nth (step nil (seq seq-exprs)) 1)))", :column 1, :line 572, :macro true, :arglists ([seq-exprs & body]), :doc "Like clojure.core/doseq with optional annotations.\n\n  :let option uses clojure.core.typed/let\n  \n  eg.\n  (doseq [a :- (U nil AnyInteger) [1 nil 2 3]\n          :when a]\n     (inc a))"}
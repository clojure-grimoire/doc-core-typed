{:ns "cljs.core.typed.async", :name "go>", :file "cljs/core/typed/async.clj", :type :macro, :src "(defmacro go>\n  \"Asynchronously executes the body, returning immediately to the\n  calling thread. Additionally, any visible calls to <!, >! and alt!/alts!\n  channel operations within the body will block (if necessary) by\n  'parking' the calling thread rather than tying up an OS thread (or\n  the only JS thread when in ClojureScript). Upon completion of the\n  operation, the body will be resumed.\n\n  The first argument is the type for the channel being created/returned.\n\n  Returns a channel which will receive the result of the body when\n  completed\"\n  [t & body]\n  `(let [c# (chan> ~t 1)]\n     (t/tc-ignore\n     (cljs.core.async.impl.dispatch/run\n       (fn []\n         (let [f# ~(ioc/state-machine body 1 &env ioc/async-custom-terminators)\n               state# (-> (f#)\n                          (ioc/aset-all! cljs.core.async.impl.ioc-helpers/USER-START-IDX c#))]\n           (cljs.core.async.impl.ioc-helpers/run-state-machine state#))))\n       )\n     c#))", :column 1, :line 16, :macro true, :arglists ([t & body]), :doc "Asynchronously executes the body, returning immediately to the\n  calling thread. Additionally, any visible calls to <!, >! and alt!/alts!\n  channel operations within the body will block (if necessary) by\n  'parking' the calling thread rather than tying up an OS thread (or\n  the only JS thread when in ClojureScript). Upon completion of the\n  operation, the body will be resumed.\n\n  The first argument is the type for the channel being created/returned.\n\n  Returns a channel which will receive the result of the body when\n  completed"}
{:type :fn, :src "(defn check-ns-info\n  \"Same as check-ns, but returns a map of results from type checking the\n  namespace.\n\n  Options\n  - :collect-only    Don't type check the given namespace/s, but collect the \n                     top level type annotations like ann, ann-record.\n  - :type-provided?  If true, use the expected type to check the form\n  - :profile         Use Timbre to profile the type checker. Timbre must be\n                     added as a dependency.\n  - :file-mapping    If true, return map provides entry :file-mapping, a hash-map\n                     of (Map '{:line Int :column Int :file Str} Str).\n\n  Default return map\n  - :delayed-errors  A sequence of delayed errors (ex-info instances)\"\n  ([] (check-ns-info *ns*))\n  ([ns-or-syms & opt]\n   (load-if-needed)\n   (apply (impl/v 'clojure.core.typed.check-ns-clj/check-ns-info) ns-or-syms opt)))", :ns "clojure.core.typed", :name "check-ns-info", :file "clojure/core/typed.clj", :column 1, :line 2182, :doc "Same as check-ns, but returns a map of results from type checking the\n  namespace.\n\n  Options\n  - :collect-only    Don't type check the given namespace/s, but collect the \n                     top level type annotations like ann, ann-record.\n  - :type-provided?  If true, use the expected type to check the form\n  - :profile         Use Timbre to profile the type checker. Timbre must be\n                     added as a dependency.\n  - :file-mapping    If true, return map provides entry :file-mapping, a hash-map\n                     of (Map '{:line Int :column Int :file Str} Str).\n\n  Default return map\n  - :delayed-errors  A sequence of delayed errors (ex-info instances)"}
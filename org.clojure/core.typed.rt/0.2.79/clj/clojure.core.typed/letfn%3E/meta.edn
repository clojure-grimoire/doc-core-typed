{:ns "clojure.core.typed", :name "letfn>", :file "clojure/core/typed.clj", :type :macro, :src "(defmacro \n  ^{:forms '[(letfn> [fn-spec-or-annotation*] expr*)]}\n  letfn>\n  \"Like letfn, but each function spec must be annotated.\n\n  eg. (letfn> [a :- [Number -> Number]\n               (a [b] 2)\n\n               c :- [Symbol -> nil]\n               (c [s] nil)]\n        ...)\"\n  [fn-specs-and-annotations & body]\n  (let [bindings fn-specs-and-annotations\n        ; (Vector (U '[Symbol TypeSyn] LetFnInit))\n        normalised-bindings\n        (loop [[fbnd :as bindings] bindings\n               norm []]\n          (cond\n            (empty? bindings) norm\n            (symbol? fbnd) (do\n                             (assert (#{:-} (second bindings))\n                                     \"letfn> annotations require :- separator\")\n                             (assert (<= 3 (count bindings)))\n                             (recur \n                               (drop 3 bindings)\n                               (conj norm [(nth bindings 0)\n                                           (nth bindings 2)])))\n            (list? fbnd) (recur\n                           (next bindings)\n                           (conj norm fbnd))\n            :else (throw (Exception. (str \"Unknown syntax to letfn>: \" fbnd)))))\n        {anns false inits true} (group-by list? normalised-bindings)\n        ; init-syn unquotes local binding references to be compatible with hygienic expansion\n        init-syn (into {}\n                   (for [[lb type] anns]\n                     [lb `'~type]))]\n    `(core/letfn ~(vec inits)\n       ;unquoted to allow bindings to resolve with hygiene\n       ~init-syn\n       ;preserve letfn empty body\n       ~@(or body [nil]))))", :column 1, :line 796, :macro true, :arglists ([fn-specs-and-annotations & body]), :doc "Like letfn, but each function spec must be annotated.\n\n  eg. (letfn> [a :- [Number -> Number]\n               (a [b] 2)\n\n               c :- [Symbol -> nil]\n               (c [s] nil)]\n        ...)", :forms [(letfn> [fn-spec-or-annotation*] expr*)]}
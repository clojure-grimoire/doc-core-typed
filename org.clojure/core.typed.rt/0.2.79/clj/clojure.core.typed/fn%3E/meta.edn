{:ns "clojure.core.typed", :name "fn>", :file "clojure/core/typed.clj", :type :macro, :src "(defmacro \n  ^{:forms '[(fn> name? :- type? [param :- type* & param :- type * ?] exprs*)\n             (fn> name? (:- type? [param :- type* & param :- type * ?] exprs*)+)]}\n  ^{:deprecated \"0.2.45\"}\n  fn> \n  \"DEPRECATED: use clojure.core.typed/fn\n\n  Like fn, but with annotations. Annotations are mandatory\n  for parameters, with optional annotations for return type.\n  If fn is named, return type annotation is mandatory.\n\n  Suggested idiom: use commas between parameter annotation triples.\n\n  eg. (fn> [a :- Number, b :- (U Symbol nil)] ...)\n\n      ;annotate return\n      (fn> :- String [a :- String] ...)\n\n      ;named fn\n      (fn> fname :- String [a :- String] ...)\n\n      ;multi-arity\n      (fn> fname \n        (:- String [a :- String] ...)\n        (:- Long   [a :- String, b :- Number] ...))\"\n  [& forms]\n  (err/deprecated-macro-syntax\n    &form\n    (str \"clojure.core.typed/fn> renamed to clojure.core.typed/fn. \"\n         \"Note return type annotation now goes after the binder: (fn [a :- t] :- r, b)\"))\n  (let [{:keys [fn parsed-methods]} (internal/parse-fn> false forms)]\n    `(fn>-ann ~fn '~parsed-methods)))", :column 1, :line 688, :macro true, :deprecated "0.2.45", :arglists ([& forms]), :doc "DEPRECATED: use clojure.core.typed/fn\n\n  Like fn, but with annotations. Annotations are mandatory\n  for parameters, with optional annotations for return type.\n  If fn is named, return type annotation is mandatory.\n\n  Suggested idiom: use commas between parameter annotation triples.\n\n  eg. (fn> [a :- Number, b :- (U Symbol nil)] ...)\n\n      ;annotate return\n      (fn> :- String [a :- String] ...)\n\n      ;named fn\n      (fn> fname :- String [a :- String] ...)\n\n      ;multi-arity\n      (fn> fname \n        (:- String [a :- String] ...)\n        (:- Long   [a :- String, b :- Number] ...))", :forms [(fn> name? :- type? [param :- type* & param :- type * ?] exprs*) (fn> name? (:- type? [param :- type* & param :- type * ?] exprs*) +)]}
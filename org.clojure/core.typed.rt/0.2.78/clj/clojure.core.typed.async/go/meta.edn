{:ns "clojure.core.typed.async", :name "go", :file "clojure/core/typed/async.clj", :type :macro, :src "(defmacro go\n  \"Like go but with optional annotations. Channel annotation defaults to Any.\n\n  eg.\n    (let [c (chan :- Str)]\n      ;; same as (go :- Any ...)\n      (go (a/>! c \\\"hello\\\"))\n      (assert (= \\\"hello\\\" (a/<!! (go :- Str (a/<! c)))))\n      (a/close! c))\n  \n  Notes\n    This macro will macroexpand the body twice: once for type checking\n    and again for the actual return value.\"\n  [& body]\n  (let [[t? t body] (maybe-annotation body)]\n    `(let [c# (chan :- ~(if t? t `t/Any), 1)\n           captured-bindings# (clojure.lang.Var/getThreadBindingFrame)]\n       ~(when vs/*checking*\n          ; wrap unexpanded go body in a thunk for type checking.\n          ; Will result in the body expanding twice.\n          `(fn [] ~@body))\n       ; we don't want to touch this.\n       (t/tc-ignore\n         (dispatch/run\n           (fn []\n             (let [f# ~(ioc/state-machine `(do ~@body) 1 (keys &env) ioc/async-custom-terminators)\n                   state# (-> (f#)\n                              (ioc/aset-all! ioc/USER-START-IDX c#\n                                             ioc/BINDINGS-IDX captured-bindings#))]\n               (ioc/run-state-machine-wrapped state#)))))\n       c#)))", :column 1, :line 303, :macro true, :arglists ([& body]), :doc "Like go but with optional annotations. Channel annotation defaults to Any.\n\n  eg.\n    (let [c (chan :- Str)]\n      ;; same as (go :- Any ...)\n      (go (a/>! c \"hello\"))\n      (assert (= \"hello\" (a/<!! (go :- Str (a/<! c)))))\n      (a/close! c))\n  \n  Notes\n    This macro will macroexpand the body twice: once for type checking\n    and again for the actual return value."}
{:type :var, :src "(def init-aliases\n  '[\n  ^{:doc \"A type that returns true for clojure.core/integer?\"\n    :forms [AnyInteger]}\nclojure.core.typed/AnyInteger (U Integer Long clojure.lang.BigInt BigInteger Short Byte)\n\n    ^{:doc \"A type that returns true for clojure.core/integer?\"\n      :forms [Int]}\nclojure.core.typed/Int (U Integer Long clojure.lang.BigInt BigInteger Short Byte)\n      ^{:doc \"A type that returns true for clojure.core/number?\"\n        :forms [Num]}\nclojure.core.typed/Num Number\n      ^{:doc \"A keyword\"\n        :forms [Keyword]}\nclojure.core.typed/Keyword clojure.lang.Keyword\n      ^{:doc \"A keyword\"\n        :forms [Kw]}\nclojure.core.typed/Kw clojure.lang.Keyword\n      ^{:doc \"A symbol\"\n        :forms [Symbol]}\nclojure.core.typed/Symbol clojure.lang.Symbol\n      ^{:doc \"A symbol\"\n        :forms [Sym]}\nclojure.core.typed/Sym clojure.lang.Symbol\n\n      ^{:doc \"A string\"\n        :forms [Str]}\nclojure.core.typed/Str java.lang.String\n\n      ^{:doc \"A boolean\"\n        :forms [Bool]}\nclojure.core.typed/Bool java.lang.Boolean\n\n; TODO: IMapEntry\n\n      ^{:doc \"A namespace\"\n        :forms [Namespace]}\nclojure.core.typed/Namespace clojure.lang.Namespace\n\n    ^{:doc \"An atom that can read and write type x.\"\n      :forms [(Atom1 t)]}\nclojure.core.typed/Atom1 (TFn [[x :variance :invariant]] \n                              (clojure.lang.Atom x x))\n    ^{:doc \"An atom that can write type w and read type r.\"\n      :forms [(Atom2 t)]}\nclojure.core.typed/Atom2 (TFn [[w :variance :contravariant]\n                               [r :variance :covariant]] \n                              (clojure.lang.Atom w r))\n    ^{:doc \"An var that can read and write type x.\"\n      :forms [(Var1 t)]}\nclojure.core.typed/Var1 \n    (TFn [[x :variance :invariant]] \n         (clojure.lang.Var x x))\n    ^{:doc \"An var that can write type w and read type r.\"\n      :forms [(Var2 w r)]}\nclojure.core.typed/Var2 \n    (TFn [[w :variance :contravariant]\n          [r :variance :covariant]] \n         (clojure.lang.Var w r))\n    ^{:doc \"A ref that can read and write type x.\"\n      :forms [(Ref1 t)]}\nclojure.core.typed/Ref1 (TFn [[x :variance :invariant]] (clojure.lang.Ref x x))\n    ^{:doc \"A ref that can write type w and read type r.\"\n      :forms [(Ref2 w r)]}\nclojure.core.typed/Ref2 (TFn [[w :variance :contravariant]\n                              [r :variance :covariant]] \n                             (clojure.lang.Ref w r))\n    ^{:doc \"An agent that can read and write type x.\"\n      :forms [(Agent1 t)]}\nclojure.core.typed/Agent1 (TFn [[x :variance :invariant]] \n                               (clojure.lang.Agent x x))\n    ^{:doc \"An agent that can write type w and read type r.\"\n      :forms [(Agent2 t t)]}\nclojure.core.typed/Agent2 (TFn [[w :variance :contravariant]\n                                [r :variance :covariant]] \n                               (clojure.lang.Agent w r))\n\n    ^{:doc \"A union of x and nil.\"\n      :forms [(Option t)]}\nclojure.core.typed/Option (TFn [[x :variance :covariant]] (U nil x))\n\n    ^{:doc \"A union of x and nil.\"\n      :forms [(Nilable t)]}\nclojure.core.typed/Nilable (TFn [[x :variance :covariant]] (U nil x))\n\n      ^{:doc \"The identity function at the type level.\"\n        :forms [Id]}\nclojure.core.typed/Id (TFn [[x :variance :covariant]] x)\n\n      ^{:doc \"A persistent collection with member type x.\"\n        :forms [(Coll t)]}\nclojure.core.typed/Coll (TFn [[x :variance :covariant]]\n                             (clojure.lang.IPersistentCollection x))\n    ^{:doc \"A persistent collection with member type x and count greater than 0.\"\n      :forms [(NonEmptyColl t)]}\nclojure.core.typed/NonEmptyColl (TFn [[x :variance :covariant]]\n                                      (I (clojure.lang.IPersistentCollection x) (CountRange 1)))\n    ^{:doc \"A persistent vector with member type x.\"\n      :forms [(Vec t)]}\nclojure.core.typed/Vec (TFn [[x :variance :covariant]]\n                            (clojure.lang.IPersistentVector x))\n    ^{:doc \"A persistent vector with member type x and count greater than 0.\"\n      :forms [(NonEmptyVec t)]}\nclojure.core.typed/NonEmptyVec (TFn [[x :variance :covariant]]\n                                     (I (clojure.lang.IPersistentVector x) (CountRange 1)))\n    ^{:doc \"A persistent vector returned from clojure.core/vector (and others)\"\n      :forms [(AVec t)]}\nclojure.core.typed/AVec (TFn [[x :variance :covariant]]\n                             (I (clojure.lang.IPersistentVector x)\n                                (java.lang.Iterable x)\n                                (java.util.Collection x)\n                                (java.util.List x)\n                                clojure.lang.IObj))\n    ^{:doc \"A persistent vector returned from clojure.core/vector (and others) and count greater than 0.\"\n      :forms [(NonEmptyAVec t)]}\nclojure.core.typed/NonEmptyAVec (TFn [[x :variance :covariant]]\n                                     (I (clojure.lang.IPersistentVector x)\n                                        (java.lang.Iterable x)\n                                        (java.util.Collection x)\n                                        (java.util.List x)\n                                        clojure.lang.IObj\n                                        (CountRange 1)))\n    ^{:doc \"A non-empty lazy sequence of type t\"\n      :forms [(NonEmptyLazySeq t)]}\nclojure.core.typed/NonEmptyLazySeq (TFn [[t :variance :covariant]]\n                                        (I (clojure.lang.LazySeq t) (CountRange 1)))\n    ^{:doc \"A persistent map with keys k and vals v.\"\n      :forms [(Map t t)]}\nclojure.core.typed/Map (TFn [[k :variance :covariant]\n                             [v :variance :covariant]]\n                            (clojure.lang.IPersistentMap k v))\n    ^{:doc \"A persistent set with member type x\"\n      :forms [(Set t)]}\nclojure.core.typed/Set (TFn [[x :variance :covariant]]\n                            (clojure.lang.IPersistentSet x))\n    ^{:doc \"A sorted persistent set with member type x\"\n      :forms [(SortedSet t)]}\nclojure.core.typed/SortedSet (TFn [[x :variance :covariant]]\n                               (Extends [(clojure.lang.IPersistentSet x) clojure.lang.Sorted]))\n    ^{:doc \"A type that can be used to create a sequence of member type x.\"\n      :forms [(Seqable t)]}\nclojure.core.typed/Seqable (TFn [[x :variance :covariant]]\n                                (clojure.lang.Seqable x))\n    ^{:doc \"A type that can be used to create a sequence of member type x\nwith count greater than 0.\"\n      :forms [(NonEmptySeqable t)]}\n\nclojure.core.typed/NonEmptySeqable (TFn [[x :variance :covariant]]\n                                         (I (clojure.lang.Seqable x) (CountRange 1)))\n    ^{:doc \"A type that can be used to create a sequence of member type x\nwith count 0.\"\n      :forms [(EmptySeqable t)]}\nclojure.core.typed/EmptySeqable (TFn [[x :variance :covariant]]\n                                  (I (clojure.lang.Seqable x) (ExactCount 0)))\n      ^{:doc \"A persistent sequence of member type x.\"\n        :forms [(Seq t)]}\nclojure.core.typed/Seq (TFn [[x :variance :covariant]]\n                            (clojure.lang.ISeq x))\n\n    ^{:doc \"A persistent sequence of member type x with count greater than 0.\"\n      :forms [(NonEmptySeq t)]}\nclojure.core.typed/NonEmptySeq (TFn [[x :variance :covariant]]\n                                     (I (clojure.lang.ISeq x) (CountRange 1)))\n\n    ^{:doc \"A persistent sequence of member type x with count greater than 0, or nil.\"\n      :forms [(NilableNonEmptySeq t)]}\nclojure.core.typed/NilableNonEmptySeq (TFn [[x :variance :covariant]]\n                                         (U nil (I (clojure.lang.ISeq x) (CountRange 1))))\n\n    ^{:doc \"The type of all things with count 0. Use as part of an intersection.\neg. See EmptySeqable.\"\n      :forms [EmptyCount]}\n\nclojure.core.typed/EmptyCount (ExactCount 0)\n    ^{:doc \"The type of all things with count greater than 0. Use as part of an intersection.\neg. See NonEmptySeq\"\n      :forms [NonEmptyCount]}\nclojure.core.typed/NonEmptyCount (CountRange 1)\n\n    ^{:doc \"A hierarchy for use with derive, isa? etc.\"\n      :forms [Hierarchy]}\nclojure.core.typed/Hierarchy '{:parents (clojure.lang.IPersistentMap Any Any)\n                               :ancestors (clojure.lang.IPersistentMap Any Any)\n                               :descendants (clojure.lang.IPersistentMap Any Any)}\n\n    ^{:doc \"A Clojure future (see clojure.core/{future-call,future}).\"\n      :forms [(Future t)]}\nclojure.core.typed/Future \n                      (TFn [[x :variance :covariant]]\n                       (Extends [(clojure.lang.IDeref x)\n                                 (clojure.lang.IBlockingDeref x)\n                                 clojure.lang.IPending\n                                 java.util.concurrent.Future]))\n\n    ^{:doc \"A Clojure promise (see clojure.core/{promise,deliver}).\"\n      :forms [(Promise t)]}\nclojure.core.typed/Promise \n              (TFn [[x :variance :invariant]]\n               (Rec [p]\n                (I (Extends [(clojure.lang.IDeref x)\n                             (clojure.lang.IBlockingDeref x)\n                             clojure.lang.IPending])\n                   [x -> (U nil p)])))\n\n    ^{:doc \"A Clojure delay (see clojure.core/{delay,force}).\"\n      :forms [(Delay t)]}\nclojure.core.typed/Delay\n              (TFn [[x :variance :covariant]]\n                   (clojure.lang.Delay x))\n\n    ^{:doc \"A Clojure derefable (see clojure.core/deref).\"\n      :forms [(Deref t)]}\nclojure.core.typed/Deref\n              (TFn [[x :variance :covariant]]\n                   (clojure.lang.IDeref x))\n\n    ^{:doc \"A Clojure blocking derefable (see clojure.core/deref).\"\n      :forms [(BlockingDeref t)]}\nclojure.core.typed/BlockingDeref\n              (TFn [[x :variance :covariant]]\n                   (clojure.lang.IBlockingDeref x))\n\n    ^{:doc \"A Clojure persistent list.\"\n      :forms [(List t)]}\nclojure.core.typed/List\n              (TFn [[x :variance :covariant]]\n                   (clojure.lang.IPersistentList x))\n\n    ^{:doc \"A Clojure custom exception type.\"\n      :forms [ExInfo]}\nclojure.core.typed/ExInfo\n              (I clojure.lang.IExceptionInfo\n                 RuntimeException)\n\n    ^{:doc \"A Clojure proxy.\"\n      :forms [Proxy]}\nclojure.core.typed/Proxy\n              clojure.lang.IProxy\n\n; Should c.l.Sorted be parameterised? Is it immutable?\n;    ^{:doc \"A sorted Clojure collection.\"\n;      :forms [Sorted]}\n;clojure.core.typed/Sorted\n;              clojure.lang.Sorted\n\n    ^{:doc \"A Clojure stack.\"\n      :forms [(Stack t)]}\nclojure.core.typed/Stack\n              (TFn [[x :variance :covariant]]\n                   (clojure.lang.IPersistentStack x))\n\n    ^{:doc \"A Clojure reversible collection.\"\n      :forms [(Reversible t)]}\nclojure.core.typed/Reversible\n              (TFn [[x :variance :covariant]]\n                   (clojure.lang.Reversible x))\n\n    ^{:doc \"A sequential collection.\"\n      :forms [Sequential]}\nclojure.core.typed/Sequential\n             clojure.lang.Sequential\n\n    ^{:doc \"A sequential, seqable collection. Seq's aren't always Sequential.\"\n      :forms [(SequentialSeqable t)]}\nclojure.core.typed/SequentialSeqable\n      (TFn [[x :variance :covariant]]\n             (I clojure.lang.Sequential\n                (clojure.lang.Seqable x)))\n\n    ^{:doc \"A Clojure sequential sequence. Seq's aren't always Sequential.\"\n      :forms [(SequentialSeq t)]}\nclojure.core.typed/SequentialSeq\n      (TFn [[x :variance :covariant]]\n             (I clojure.lang.Sequential\n                (clojure.lang.ISeq x)))\n\n    ^{:doc \"A sequential seq returned from clojure.core/seq\"\n      :forms [(ASeq t)]}\nclojure.core.typed/ASeq\n      (TFn [[x :variance :covariant]]\n           (I (clojure.lang.ISeq x)\n              clojure.lang.Sequential\n              (Iterable x)\n              (java.util.Collection x)\n              (java.util.List x)\n              clojure.lang.IObj))\n\n    ^{:doc \"A sequential non-empty seq retured from clojure.core/seq\"\n      :forms [(NonEmptyASeq t)]}\nclojure.core.typed/NonEmptyASeq\n      (TFn [[x :variance :covariant]]\n           (I (clojure.lang.ISeq x)\n              clojure.lang.Sequential\n              (Iterable x)\n              (java.util.Collection x)\n              (java.util.List x)\n              clojure.lang.IObj\n              (CountRange 1)))\n\n    ^{:doc \"The result of clojure.core/seq.\"\n      :forms [(NilableNonEmptyASeq t)]}\nclojure.core.typed/NilableNonEmptyASeq\n      (TFn [[x :variance :covariant]]\n           (U nil\n              (I (clojure.lang.ISeq x)\n                 clojure.lang.Sequential\n                 (Iterable x)\n                 (java.util.Collection x)\n                 (java.util.List x)\n                 clojure.lang.IObj\n                 (CountRange 1))))\n\n    ^{:doc \"A type that returns true for clojure.core/fn?\"\n      :forms [Fn]}\nclojure.core.typed/Fn\n              clojure.lang.Fn\n\n    ^{:doc \"A Clojure multimethod.\"\n      :forms [Multi]}\nclojure.core.typed/Multi\n              clojure.lang.MultiFn\n])", :ns "clojure.core.typed.current-impl", :name "init-aliases", :file "clojure/core/typed/current_impl.clj", :column 1, :line 189}
{:ns "clojure.core.typed.macros", :name "def", :file "clojure/core/typed/macros.clj", :type :macro, :src "(defmacro\n  ^{:forms '[(def name docstring? :- type? expr)]}\n  def\n  \"Like clojure.core/def with optional type annotations\n\n  NB: in Clojure it is impossible to refer a var called `def` as it is a\n  special form. Use an alias prefix (eg. `t/def`).\n\n  If an annotation is provided, a corresponding `ann` form\n  is generated, otherwise it expands identically to clojure.core/def\n\n  eg. ;same as clojure.core/def\n      (def vname 1)\n      \n      ;with Number `ann`\n      (def vname :- Number 1)\n\n      ;doc\n      (def vname\n        \\\"Docstring\\\"\n        :- Long\n        1)\"\n  [name & fdecl]\n  (core/let [[docstring fdecl] (internal/take-when string? fdecl)\n             [provided? t [body :as args]] (parse-colon fdecl 'def)]\n    (assert (= 1 (count args)) \"Wrong arguments to def\")\n    `(def ~(vary-meta name #(merge\n                              %\n                              (when docstring\n                                {:doc docstring})))\n       ~(if provided?\n          `(ann-form ~body ~t)\n          body))))", :column 1, :line 22, :macro true, :arglists ([name & fdecl]), :doc "Like clojure.core/def with optional type annotations\n\n  NB: in Clojure it is impossible to refer a var called `def` as it is a\n  special form. Use an alias prefix (eg. `t/def`).\n\n  If an annotation is provided, a corresponding `ann` form\n  is generated, otherwise it expands identically to clojure.core/def\n\n  eg. ;same as clojure.core/def\n      (def vname 1)\n      \n      ;with Number `ann`\n      (def vname :- Number 1)\n\n      ;doc\n      (def vname\n        \"Docstring\"\n        :- Long\n        1)", :forms [(def name docstring? :- type? expr)]}
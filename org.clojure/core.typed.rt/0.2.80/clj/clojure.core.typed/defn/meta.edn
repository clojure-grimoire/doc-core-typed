{:ns "clojure.core.typed", :name "defn", :file "clojure/core/typed/macros.clj", :type :macro, :src "(defmacro\n  ^{:forms '[(defn name docstring? [param :- type *] :- type exprs*)\n             (defn :forall poly name docstring? [param :- type *] :- type exprs*)\n             (defn poly? name docstring? ([param :- type *] :- type exprs*)+)\n             (defn :forall poly name docstring? ([param :- type *] :- type exprs*)+)]}\n  defn\n  \"Like defn, but expands to clojure.core.typed/fn. If a polymorphic binder is\n  supplied before the var name, expands to clojure.core.typed/pfn.\n\n  eg. (defn fname [a :- Number, b :- (U Symbol nil)] :- Integer ...)\n\n  ;annotate return\n  (defn fname [a :- String] :- String ...)\n\n  ;multi-arity\n  (defn fname \n    ([a :- String] :- String ...)\n    ([a :- String, b :- Number] :- Long ...))\n\n  ;polymorphic function\n  (defn :forall [x y]\n    fname \n    ([a :- x] :- (Coll y) ...)\n    ([a :- Str, b :- y] :- y ...))\"\n  [& args]\n  (let [{:keys [name args]} (internal/parse-defn* args)]\n    `(def ~name (fn ~@args))))", :column 1, :line 239, :macro true, :arglists ([& args]), :doc "Like defn, but expands to clojure.core.typed/fn. If a polymorphic binder is\n  supplied before the var name, expands to clojure.core.typed/pfn.\n\n  eg. (defn fname [a :- Number, b :- (U Symbol nil)] :- Integer ...)\n\n  ;annotate return\n  (defn fname [a :- String] :- String ...)\n\n  ;multi-arity\n  (defn fname \n    ([a :- String] :- String ...)\n    ([a :- String, b :- Number] :- Long ...))\n\n  ;polymorphic function\n  (defn :forall [x y]\n    fname \n    ([a :- x] :- (Coll y) ...)\n    ([a :- Str, b :- y] :- y ...))", :forms [(defn name docstring? [param :- type *] :- type exprs*) (defn :forall poly name docstring? [param :- type *] :- type exprs*) (defn poly? name docstring? ([param :- type *] :- type exprs*) +) (defn :forall poly name docstring? ([param :- type *] :- type exprs*) +)]}